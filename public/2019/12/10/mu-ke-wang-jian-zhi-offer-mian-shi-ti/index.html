<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="慕课网剑指offer面试题, 谦谦君子">
    <meta name="description" content="我在慕课网买的教程，整理出来。
1.赋值运算函数
思路:

将返回值类型声明为该类型的引用
把传入的参数类型声明为常量引用 释放实例自身已有的内存
判断传入的参数和当前的实例是不是同一个实例

2.单例设计模式思路:

静态内部类

3.在">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>慕课网剑指offer面试题 | 谦谦君子</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <link rel="stylesheet" type="text/css" href="/css/dark.css">
    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>
<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="谦谦君子" type="application/atom+xml">
</head>




<body>
<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">谦谦君子</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">谦谦君子</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>


<main id="main_wrap">
    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">慕课网剑指offer面试题</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 137px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-12-10
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>我在慕课网买的教程，整理出来。</p>
<p>1.赋值运算函数</p>
<p>思路:</p>
<ul>
<li>将返回值类型声明为该类型的引用</li>
<li>把传入的参数类型声明为常量引用 释放实例自身已有的内存</li>
<li>判断传入的参数和当前的实例是不是同一个实例</li>
</ul>
<p>2.单例设计模式<br>思路:</p>
<ul>
<li>静态内部类</li>
</ul>
<p>3.在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完 成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路:</p>
<ul>
<li>从右上角或左下角开始找，逐行删除，或者用二分法查找</li>
</ul>
<p>代码实现:</p>
<pre><code>public boolean find(int[][] array,int target) { if (array == null) {
      return false;
  }
int row = 0;
int column = array[0].length-1;
while (row &lt; array.length &amp;&amp; column &gt;= 0) { if(array[row][column] == target) {
          return true;
      }
if(array[row][column] &gt; target) { column--;
      } else {
          row++;
} }
  return false;
}
</code></pre>
<p>4.将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>思路:</p>
<ul>
<li>从后往前复制，数组长度会增加，或使用StringBuilder、StringBuffer类</li>
</ul>
<p>代码实现:</p>
<pre><code>public String replaceSpace(StringBuffer str) { if (str == null)
return null;
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; str.length(); i++) {
if (String.valueOf(str.charAt(i)).equals(" ")) {
sb.append("%20"); }else {
sb.append(str.charAt(i)); }
}
return String.valueOf(sb); }
</code></pre>
<p>5.输入一个链表，从尾到头打印链表每个节点的值。</p>
<p>思路:</p>
<ul>
<li>借助栈实现，或使用递归的方法。</li>
</ul>
<p>代码实现:</p>
<pre><code>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      if (listNode == null)
      return list;
      Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); 
      while (listNode != null) {
      stack.push(listNode);
       listNode = listNode.next; }
      while (!stack.isEmpty()) { 
      list.add(stack.pop().val);
      }
     return list;
     }
</code></pre>
<p>6.输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中 都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并 返回。</p>
<p>思路:</p>
<ul>
<li>先找出根节点，然后利用递归方法构造二叉树</li>
</ul>
<p>代码实现:</p>
<pre><code> static class TreeNode {
   int val;
 TreeNode left;
 TreeNode right;
 TreeNode(int x) { val = x; }
 }
 public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
 if (pre == null || in == null) { return null;
 }
 if (pre.length == 0 || in.length == 0) { return null;
 }
  if (pre.length != in.length) {
      return null;
  }
 TreeNode root = new TreeNode(pre[0]); for (int i = 0; i &lt; pre.length; i++) {
 if (pre[0] == in[i]) {
 root.left = reConstructBinaryTree(
 Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i)); root.right = reConstructBinaryTree(
 Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); }
 }
  return root;
 }
</code></pre>
<p>7.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>思路:</p>
<ul>
<li>一个栈压入元素，而另一个栈作为缓冲，将栈1的元素出栈后压入栈2中。也可以将栈1中的最后一个元<br>素直接出栈，而不用压入栈2中再出栈。</li>
</ul>
<p>代码实现:</p>
<pre><code> public void push(int node) { stack1.push(node);
  }
 public int pop() throws Exception {
 if (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) {
 throw new Exception("栈为空!"); }
 if (stack2.isEmpty()) { while(!stack1.isEmpty()) {
 stack2.push(stack1.pop()); }
 }
 return stack2.pop(); }
</code></pre>
<p>8.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一 个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE:给出的所有元素都大于0，若数组大小为0，请返回0</p>
<p>思路:</p>
<ul>
<li>利用二分法，找到中间的数，然后和最左边的值进行比较，若大于最左边的数，则最左边从mid开始， 若小于最右边值，则最右边从mid开始。若左中右三值相等，则取mid前后值中较小的数。</li>
</ul>
<p>代码实现:</p>
<pre><code> public int minNumberInRotateArray(int [] array) { if (array == null || array.length == 0)
 return 0; int left = 0;
 int right = array.length - 1; int mid = 0;
 while (array[left] &gt;= array[right]) { if(right - left &lt;= 1) {
 mid = right;
 break; }
 mid = (left + right)/2;
 if (array[left] == array[mid] &amp;&amp; array[mid] == array[right]) {
 if (array[left+1] != array[right-1]) {
 mid = array[left+1] &lt; array[right-1] ? left+1:right-1;
          } else {
            left++;
 right--; }
 } else {
 if (array[left] &lt;= array[mid]) {
 left = mid; } else {
 right = mid; }
 } }
  return array[mid];
 }
</code></pre>
<p>9.1现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
<p>思路:</p>
<ul>
<li>递归的效率低，使用循环方式。</li>
</ul>
<p>代码实现:</p>
<pre><code>public long fibonacci(int n) { long result=0;
long preOne=1; long preTwo=0; if(n==0) {
      return preTwo;
  }
if(n==1) {
return preOne;
preOne = result; }
  return result;
 }
</code></pre>
<p>9.2.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>9.2代码与9.1相同</p>
<p>9.3我们可以用21 矩形，n 21的小矩形无重叠地覆盖一个2*n的大总共有多少种方法?</p>
<p>思路:</p>
<ul>
<li>斐波那契数列思想</li>
</ul>
<p>代码实现:</p>
<pre><code>public int Fibonaccik(int n) { int number = 1;
  int sum = 1; if (n &lt;= 0)
  return 0; if (n == 1 ) {
  return 1; }
  while (n-- &gt;= 2) { sum += number;
  number = sum - number; }
  return sum; 
  }
</code></pre>
<p>9.4一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共 有多少种跳法。</p>
<p>思路:</p>
<ul>
<li>2^(n-1)</li>
</ul>
<p>代码实现:</p>
<pre><code>public int JumpFloor2(int target) { 
    return (int) Math.pow(2,target-1);
}
</code></pre>
<p>10.输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>思路:</p>
<ul>
<li>a&amp;(a-1)的结果会将a最右边的1变为0，直到a = 0，还可以先将a&amp;1 != 0，然后右移1位，但不能计算负<br>数的值，</li>
</ul>
<p>代码实现:</p>
<pre><code>public int NumberOf1(int n) {
int count = 0;
while (n != 0) { count++;
n = (n-1) &amp; n; }
  return count;
}
</code></pre>
<p>11.给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。不得使用库函数， 不需要考虑大数问题</p>
<p>思路:</p>
<ul>
<li>不能用==比较两个浮点数是否相等，因为有误差。考虑输入值的多种情况。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public double Power(double base, int exponent) { 
  double res = 0;
  if (equal(base,0)) {
      return 0;
   }
  if (exponent == 0) {
  return 1.0; }
  if (exponent &gt; 0) {
  res = mutiply(base,exponent);
  }else {
  res = mutiply(1/base,-exponent);
   }
  return res; }
  public double mutiply(double base, int e) { double sum = 1;
  for (int i = 0; i &lt; e; i++) { sum = sum * base;
  }
 return sum; }
 public boolean equal(double a, double b) {
 if (a - b &lt; 0.000001 &amp;&amp; a - b &gt; -0.000001) {
      return true;
  }
  return false;
  }
</code></pre>
<p>12.打印1到最大的n位数</p>
<p>思路:</p>
<ul>
<li>考虑大数问题，使用字符串或数组表示。</li>
</ul>
<p>代码实现:</p>
<pre><code> public void printToMaxOfNDigits(int n) {
 int[] array=new int[n];
 if(n &lt;= 0)
      return;
  printArray(array, 0);
  }
 private void printArray(int[] array,int n) { 
 for(int i = 0; i &lt; 10; i++) {
 if(n != array.length) { array[n] = i;
          printArray(array, n+1);
      } else {
  boolean isFirstNo0 = false;
  for(int j = 0; j &lt; array.length; j++) {
  if(array[j] != 0) { 
  System.out.print(array[j]); if(!isFirstNo0)
   isFirstNo0 = true; } else {
  if(isFirstNo0) System.out.print(array[j]);
  } }
 System.out.println();
 return ; }
  } }
</code></pre>
<p>13.O(1)时间删除链表节点</p>
<p>思路:</p>
<ul>
<li>将要删除节点的下一个节点的值赋给要删除的节点，然后指向下下一个节点</li>
</ul>
<p>代码实现:</p>
<pre><code> public void deleteNode(ListNode head, ListNode deListNode) { 
 if (deListNode == null || head == null)
 return;
 if (head == deListNode) { head = null;
 } else {
 // 若删除节点是末尾节点，往后移一个 if (deListNode.nextNode == null) {
 ListNode pointListNode = head;
 while (pointListNode.nextNode.nextNode != null) {
 pointListNode = pointListNode.nextNode; }
 pointListNode.nextNode = null; } else {
 deListNode.data = deListNode.nextNode.data;
deListNode.nextNode = deListNode.nextNode.nextNode; }
} }
</code></pre>
<p>14.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所 有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</p>
<p>思路:</p>
<ul>
<li>每次只和前面一个数交换位置。或者利用辅助数组</li>
</ul>
<p>代码实现:</p>
<pre><code> public void reOrderArray(int [] array) { 
 if(array == null)
 return ;
 for(int i = 1; i &lt; array.length; i++){ 
 int temp = array[i];
 int j = i - 1;
  if(array[i] % 2 != 0){
 while(j &gt;= 0){
 if(array[j] % 2 != 0){
 break; }
 if(array[j]%2 == 0){
  int t = array[j+1];
  array[j+1] = array[j]; 
  array[j] = t;
 j--;
  } }
  }
   array[j+1] = temp; }
 }
</code></pre>
<p>15.输入一个链表，输出该链表中倒数第k个结点。 扩展题:找中间节点，使用两个指针，一个走一步，一个走两步。找到中间节点</p>
<p>思路:</p>
<ul>
<li>定义一快一慢两个指针，快指针走K步，然后慢指针开始走，快指针到尾时，慢指针就找到了倒数第K个 节点。</li>
</ul>
<p>代码实现:</p>
<pre><code>public ListNode FindKthToTail(ListNode head,int k) { 
if (head == null || k &lt;= 0) {
      return null;
  }
ListNode fast = head; ListNode slow = head;
while(k-- &gt; 1) {
if (fast.next != null)
fast = fast.next; else
return null;
}
while (fast.next != null) {
fast = fast.next;
slow = slow.next; }
  return slow;
}
</code></pre>
<p>16.输入一个链表，反转链表后，输出链表的所有元素。 扩展题:输出反转后链表的头节点，定义三个指针反向输出。</p>
<p>思路:</p>
<ul>
<li>定义两个指针，反向输出</li>
</ul>
<p>代码实现:</p>
<pre><code>public ListNode ReverseList(ListNode head) { 
if (head == null) {
      return null;
  }
ListNode temp = null; while(head != null) {
ListNode p = head.next; head.next = temp;
temp = head;
head = p;
}
  return temp;
 }
</code></pre>
<p>17.输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>思路:</p>
<ul>
<li>递归与非递归求解，小数放在前面。</li>
</ul>
<p>代码实现:</p>
<pre><code>public ListNode Merge(ListNode list1,ListNode list2) { 
if (list1 == null) {
      return list2;
  }
if (list2 == null) { return list1;
}

ListNode newHead = null;
if (list1.val &lt;= list2.val) {
newHead = list1;
newHead.next = Merge(list1.next,list2)
 }else {
newHead = list2;
newHead.next = Merge(list1,list2.next); }
  return newHead;
  }
</code></pre>
<p>18.输入两棵二叉树A，B，判断B是不是A的子结构。(ps:我们约定空树不是任意一个树的子结构)</p>
<p>思路:</p>
<ul>
<li>若根节点相等，利用递归比较他们的子树是否相等，若根节点不相等，则利用递归分别在左右子树中查<br>找。</li>
</ul>
<p>代码实现:</p>
<pre><code>public boolean HasSubtree(TreeNode root1,TreeNode root2) { 
boolean result = false;
if (root2 != null &amp;&amp; root1 != null) { if(root1.val == root2.val){
result = doesTree1HaveTree2(root1,root2); }
if (!result)
return HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2);
}
  return result;
}
public boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) { 
if (node2 == null) {
      return true;
  }
if (node1 == null) { return false;
}
if (node1.val != node2.val) {
      return false;
  }
return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right);
 }
</code></pre>
<p>19.操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>思路:</p>
<ul>
<li>使用递归或非递归方式交换每个节点的左右子树位置。</li>
</ul>
<p>代码实现:</p>
<pre><code>public void Mirror(TreeNode root) { if 
(root == null) {
return; }
Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
while (root != null || !stack.isEmpty()) {
while (root != null) { 
TreeNode temp = root.left; 
root.left = root.right;
root.right = temp; 
stack.push(root);
root = root.left;
 }
if (!stack.isEmpty()) {
root = stack.pop();
root = root.right; }
} }
</code></pre>
<p>20.输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>思路:</p>
<ul>
<li>终止行号大于起始行号，终止列号大于起始列号，</li>
</ul>
<p>代码实现:</p>
<pre><code>public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) { 
ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 
if(matrix == null)
return list; int start = 0;
while(matrix[0].length &gt; start*2 &amp;&amp; matrix.length &gt; start*2) {    printOneCircle(matrix,start,list);
start++;
}
  return list;
}
private void printOneCircle(int[][] matrix,int start,ArrayList&lt;Integer&gt; list) {
int endX = matrix[0].length - 1 - start; // 列
int endY = matrix.length - 1 - start; // 行
 // 从左往右
for (int i = start; i &lt;= endX; i++) list.add(matrix[start][i]);
// 从上往下
if (start &lt; endY) {
for (int i = start + 1; i &lt;= endY; i++) 
list.add(matrix[i][endX]);
}
// 从右往左(判断是否会重复打印)
if (start &lt; endX &amp;&amp; start &lt; endY) {
for (int i = endX - 1; i &gt;= start; i--) 
list.add(matrix[endY][i]);
 }
 // 从下往上(判断是否会重复打印)
if (start &lt; endX &amp;&amp; start &lt; endY - 1) {
for (int i = endY - 1; i &gt;= start + 1; i--)
list.add(matrix[i][start]);
 } }
</code></pre>
<p>21.定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p>思路:</p>
<ul>
<li>定义两个栈，一个存放入的值。另一个存最小值。</li>
</ul>
<p>代码实现:</p>
<pre><code>public void push(int node) { stack1.push(node);
if (stack2.isEmpty()) {
stack2.push(node); }else {
if (stack2.peek() &gt; node) { stack2.push(node);
} }
}
public void pop() {
if (stack1.pop() == stack2.peek()) {
stack2.pop(); }
}
public int top() {
return stack1.peek();
 }
 public int min() {
 return stack2.peek();
 }
</code></pre>
<p>22.输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入 栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出 序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。(注意:这两个序列的长度是相等的)</p>
<p>思路:</p>
<ul>
<li>用栈来压入弹出元素，相等则出栈。</li>
</ul>
<p>代码实现:</p>
<pre><code>public boolean IsPopOrder(int [] pushA,int [] popA) { 
if (pushA == null || popA == null) {
      return false;
  }
Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
int index = 0;
for (int i = 0; i &lt; pushA.length; i++) { stack.push(pushA[i]);
while (!stack.isEmpty() &amp;&amp; stack.peek() == popA[index]) {
stack.pop();
index++; }
}
return stack.isEmpty(); }
</code></pre>
<p>23.从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路:</p>
<ul>
<li>利用队列(链表)辅助实现。</li>
</ul>
<p>代码实现:</p>
<pre><code>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) { 
ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
if (root == null) {
      return list;
  }
 LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root);
 while (!queue.isEmpty()) { TreeNode node = queue.poll(); list.add(node.val);
if (node.left != null) {
queue.addLast(node.left); }
if (node.right != null) { queue.addLast(node.right);
} }
  return list;
 }
</code></pre>
<p>24.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。 假设输入的数组的任意两个数字都互不相同。</p>
<p>思路:</p>
<ul>
<li>先找到右子树的开始位置，然后分别进行左右子树递归处理。</li>
</ul>
<p>代码实现:</p>
<pre><code> public boolean VerifySquenceOfBST(int[] sequence) { 
 if (sequence == null || sequence.length == 0)
 return false; int rstart = 0;
 int length = sequence.length;
  for (int i = 0; i &lt; length - 1; i++) {
 if (sequence[i] &lt; sequence[length - 1])
 rstart++; }
if (rstart == 0) {
VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,length-1));
 }else {
for (int i = rstart; i &lt; length - 1; i++) {
if (sequence[i] &lt;= sequence[length - 1]) { return false;
} }
VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,rstart));
VerifySquenceOfBST(Arrays.copyOfRange(sequence,rstart,length - 1)); }
  return true;
}
</code></pre>
<p>25.输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结 点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>思路:</p>
<ul>
<li>先保存根节点，然后分别递归在左右子树中找目标值，若找到即到达叶子节点，打印路径中的值</li>
</ul>
<p>代码实现:</p>
<pre><code> public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) { 
 if(root == null)
 return resultList; 
 list.add(root.val); 
 target -= root.val;
 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null){ 
 resultList.add(new ArrayList&lt;&gt;(list));
 }else { 
 FindPath(root.left,target);
 FindPath(root.right,target);
  } //每返回上一层一次就要回退一个节点 list.remove(list.size()-1); return resultList;
  }
</code></pre>
<p>26.输入一个复杂链表(每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任 意一个节点)，返回结果为复制后复杂链表的head。(注意，输出结果中请不要返回参数中的节点引用，否则 判题程序会直接返回空)</p>
<p>思路:</p>
<ul>
<li>先复制链表的next节点，将复制后的节点接在原节点后，然后复制其它的节点，最后取偶数位置的节点 (复制后的节点)。</li>
</ul>
<p>代码实现:</p>
<pre><code> public RandomListNode Clone2(RandomListNode pHead) { 
 if(pHead == null)
 return null;
 RandomListNode head = new RandomListNode(pHead.label) ;
 RandomListNode temp = head ;
 while(pHead.next != null) {
  temp.next = new RandomListNode(pHead.next.label) ; 
  if(pHead.random != null) {
  temp.random = new RandomListNode(pHead.random.label) ; }
 pHead = pHead.next ;
 temp = temp.next ; }
  return head ;
 }
</code></pre>
<p>27.输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调 整树中结点指针的指向。</p>
<p>思路:</p>
<ul>
<li>定义一个链表的尾节点，递归处理左右子树，最后返回链表的头节点</li>
</ul>
<p>代码实现:</p>
<pre><code>public TreeNode Convert(TreeNode pRootOfTree) { 
TreeNode lastlist = covertNode(pRootOfTree,null);
TreeNode pHead = lastlist;
while (pHead != null &amp;&amp; pHead.left != null) {
pHead = pHead.left; }
  return pHead;
}
public TreeNode covertNode(TreeNode root, TreeNode lastlist) { if (root == null)
return null; TreeNode cur = root;
if (cur.left != null) {
lastlist = covertNode(cur.left,lastlist); }
cur.left = lastlist;
if (lastlist != null) {
lastlist.right = cur; }
lastlist = cur;
if (cur.right != null) {
lastlist = covertNode(cur.right,lastlist); }
  return lastlist;
}
</code></pre>
<p>28.输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所 能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>思路:</p>
<ul>
<li>将当前位置的字符和前一个字符位置交换，递归。</li>
</ul>
<p>代码实现:</p>
<pre><code> public ArrayList&lt;String&gt; Permutation(String str) { 
 ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;() ; if(str == null || str.length() == 0)
 return result;
 char[] chars = str.toCharArray() ; 
 TreeSet&lt;String&gt; temp = new TreeSet&lt;&gt;() ;
 Permutation(chars, 0, temp); result.addAll(temp) ;
 return result ;
  }
public void Permutation(char[] chars, int index, TreeSet&lt;String&gt; result) { 
if(chars == null || chars.length == 0 )
 return ;
if (index &lt; 0 || index &gt; chars.length - 1)
return;
if(index == chars.length-1) {
result.add(String.valueOf(chars)) ; }else {
for(int i=index ; i&lt;=chars.length-1 ;
i++) { swap(chars, index, i) ;
Permutation(chars, index+1, result);
// 回退
          swap(chars, index, i) ;
      }
 } }
public void swap(char[] c, int a,int b) { 
char temp = c[a];
c[a] = c[b];
c[b] = temp;
}
</code></pre>
<p>29.数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p>
<p>思路:</p>
<ul>
<li>将首次出现的数count+1，与之后的数进行比较，相等则+1，否则—1，最后进行校验是否超过长度的一<br>半。</li>
</ul>
<p>代码实现:</p>
<pre><code>public int MoreThanHalfNum_Solution(int [] array) { 
 int maxCount = array[0];
 int number = array[0];
  int count = 1;
for (int i = 1; i &lt; array.length; i++) { 
if (number != array[i]) {
if (count == 0) { number = array[i]; count = 1;
}else { count--;
} }else {
 count++; }
if (count == 1) { maxCount = number;
} }
// 验证
int num = 0;
for (int j = 0; j &lt; array.length; j++) {
if (array[j] == maxCount) { num++;
} }
if (num * 2 &gt; array.length) { return maxCount;
}
return 0; }
</code></pre>
<p>30.输入n个整数，找出其中最小的K个数。</p>
<p>思路:</p>
<ul>
<li>先将前K个数放入数组，进行堆排序，若之后的数比它还小，则进行调整</li>
</ul>
<p>代码实现:</p>
<pre><code>public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { 
ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
if (input == null || k &lt;= 0 || k &gt; input.length) {
      return list;
  }
int[] kArray = Arrays.copyOfRange(input,0,k); // 创建大根堆
buildHeap(kArray);
for(int i = k; i &lt; input.length; i++) { if(input[i] &lt; kArray[0]) {
kArray[0] = input[i];
          maxHeap(kArray, 0);
      }
 for (int i = kArray.length - 1; i &gt;= 0; i--) { 
 list.add(kArray[i]);
}
  return list;
 }
public void buildHeap(int[] input) {
for (int i = input.length/2 - 1; i &gt;= 0; i--) {
      maxHeap(input,i);
  }
}
private void maxHeap(int[] array,int i) { int left=2*i+1;
int right=left+1; int largest=0;
if(left &lt; array.length &amp;&amp; array[left] &gt; array[i]) largest=left;
 else largest=i;
 if(right &lt; array.length &amp;&amp; array[right] &gt; array[largest]) largest = right;
 if(largest != i) {
 int temp = array[i]; 
 array[i] = array[largest];
 array[largest] = temp;
 maxHeap(array, largest);
} }
</code></pre>
<p>31.求连续子数组(包含负数)的最大和</p>
<p>思路:</p>
<ul>
<li>若和小于0，则将最大和置为当前值，否则计算最大和。</li>
</ul>
<p>代码实现:</p>
<pre><code>public int FindGreatestSumOfSubArray(int[] array) { if (array == null || array.length == 0)
return 0;
int cur = array[0]; int greast = array[0];
for (int i = 1; i &lt; array.length; i++) { if (cur &lt; 0) {
cur = array[i]; }else {
cur += array[i];
}
if (cur &gt; greast) { greast = cur;
} }
  return greast;
 }
</code></pre>
<p>32.从1到整数n中1出现的次数</p>
<p>思路:</p>
<ul>
<li>若百位上数字为0，百位上可能出现1的次数由更高位决定;若百位上数字为1，百位上可能出现1的次数<br>不仅受更高位影响还受低位影响;若百位上数字大于1，则百位上出现1的情况仅由更高位决定</li>
</ul>
<p>代码实现:</p>
<pre><code>public long CountOne2(long n) {
long count = 0; // 1的个数
longi=1; // 当前位
long current = 0,after = 0,before = 0;
while((n / i) != 0) { before=n/(i*10);
// 高位 current=(n/i)%10;// 当前位 after=n-(n/i)*i; // 低位
if (current == 0) //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数 count = count + before * i;
 else if(current == 1) //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1 count = count + before * i + after + 1;
else if (current &gt; 1)
// 如果大于1,出现1的次数由高位决定,(高位数字+1)* 当前位数 count = count + (before + 1) * i;
//前移一位
i = i * 10; }
  return count;
 }
</code></pre>
<p>解法二:公式法</p>
<pre><code>public int NumberOf1Between1AndN_Solution(int n){ int count=0;
for(int i = 1; i &lt;= n; i *= 10){ inta=n/i;// 高位 intb=n%i;// 低位
count += (a+8) / 10 * i; if(a % 10 == 1){
count += b + 1; }
 }
  return count;
 }
</code></pre>
<p>33.输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</p>
<p>思路:</p>
<ul>
<li>先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就 是制定排序规则。或使用比较和快排的思想，将前面的数和最后的数比较，若小则放到最前面，最后再递归调 用。</li>
</ul>
<p>代码实现:</p>
<pre><code>public String PrintMinNumber(int [] numbers) { if(numbers == null || numbers.length == 0)
return "";
int len = numbers.length;
String[] str = new String[len]; 
StringBuilder sb = new StringBuilder();
for(int i = 0; i &lt; len; i++){
str[i] = String.valueOf(numbers[i]); }
Arrays.sort(str,new Comparator&lt;String&gt;(){ @Override
public int compare(String s1, String s2) { String c1 = s1 + s2;
String c2 = s2 + s1;
return c1.compareTo(c2);
 } });
for(int i = 0; i &lt; len; i++){ sb.append(str[i]);
 }
 return sb.toString(); }
</code></pre>
<p>34.丑数是只包含因子2、3和5的数，求从小到大的第N个丑数。</p>
<p>思路:</p>
<ul>
<li>乘2或3或5，之后比较取最小值。</li>
</ul>
<p>代码实现:</p>
<pre><code>public int GetUglyNumber_Solution(int index) { if (index &lt;= 0)
 return 0;
int[] arr = new int[index]; arr[0] = 1;
int multiply2 = 0;
 int multiply3 = 0;
int multiply5 = 0;
 for (int i = 1; i &lt; index; i++) {
int min = Math.min(arr[multiply2] * 2,Math.min(arr[multiply3] * 3,arr[multiply5] * 5)); 
arr[i] = min;
 if (arr[multiply2] * 2 == min)
 multiply2++;
 if (arr[multiply3] * 3 == min)
  multiply3++;
  if (arr[multiply5] * 5 == min)
          multiply5++;
 }
 return arr[index - 1]; }
</code></pre>
<p>35.在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
<p>思路:</p>
<ul>
<li>利用LinkedHashMap保存字符和出现次数。</li>
</ul>
<p>代码实现:</p>
<pre><code> public int FirstNotRepeatingChar(String str) { if (str == null || str.length() == 0)
 return -1;
 char[] c = str.toCharArray();
  LinkedHashMap&lt;Character,Integer&gt; hash=new LinkedHashMap&lt;Character,Integer&gt;();
 for(char item : c) { if(hash.containsKey(item))
  hash.put(item, hash.get(item)+1); else
  hash.put(item, 1);
   }
   for(int i = 0;i &lt; str.length(); i++){ if (hash.get(str.charAt(i)) == 1) {
 return i; }
   }
 return -1; }
</code></pre>
<p>36.在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组, 求出这个数组中的逆序对的总数P</p>
<p>思路:</p>
<ul>
<li>本质是归并排序，在比较时加入全局变量count进行记录逆序对的个数，若data[start] &gt;= data[index] ， 则count值为mid+1-start</li>
</ul>
<p>代码实现:</p>
<pre><code>int count = 0;
public int InversePairs(int [] array) {
if(array==null)
return 0; mergeSort(array,0,array.length-1); return count;
 }
private void mergeSort(int[] data,int start,int end) { int mid = (start + end) / 2;
if (start &lt; end) {
      mergeSort(data, start, mid);
      mergeSort(data, mid + 1, end);
      merge(data, start, mid, end);
 } }
public void merge(int[] data,int start,int mid,int end) { 
int arr[] = new int[end - start + 1];
 int c = 0;
 int s = start;
int index = mid + 1;
while (start &lt;= mid &amp;&amp; index &lt;= end) {
if (data[start] &lt; data[index]) { arr[c++] = data[start++];
} else {
 arr[c++] = data[index++]; count += mid +1 - start; count %= 1000000007;
 } }
 while (start &lt;= mid) { arr[c++] = data[start++];
 }
  while (index &lt;= end) { arr[c++] = data[index++];
  }
 for (int d : arr) { data[s++] = d;
  } }
</code></pre>
<p>37.输入两个链表，找出它们的第一个公共结点。</p>
<p>思路:</p>
<ul>
<li>先求出链表长度，然后长的链表先走多出的几步，然后两个链表同时向下走去寻找相同的节点，代码量<br>少的方法需要将两个链表遍历两次，然后从头开始相同的节点。</li>
</ul>
<p>代码实现:</p>
<pre><code>  // 不需要遍历链表的解法
 public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
 ListNode p1 = pHead1;
 ListNode p2 = pHead2; while (p1 != p2){
 p1 = (p1 != null ? p1.nextNode : pHead2);
 p2 = (p2 != null ? p2.nextNode : pHead1); }
 return p1; }
</code></pre>
<p>38.统计一个数字在排序数组中出现的次数。</p>
<p>思路:</p>
<ul>
<li><p>利用二分查找+递归思想，进行寻找。当目标值与中间值相等时进行判断 代码实现:</p>
<pre><code>public int GetNumberOfK(int[] array,int k) { int result=0;
int mid = array.length/2;
if(array==null || array.length == 0) return 0;
 if(array.length == 1) { if(array[0] == k)
        return 1;
    else
 return 0; }
 if(k &lt; array[mid])
  result += GetNumberOfK(Arrays.copyOfRange(array, 0, mid),k);
  else if(k &gt; array[mid])
result += GetNumberOfK(Arrays.copyOfRange(array, mid, array.length),k);
 else {
for(int i = mid;i &lt; array.length;i++) {
 if(array[i] == k) result++;
 else break;
   }
  for(int i = mid - 1;i &gt;= 0;i--) { if(array[i] == k)
            result++;
        else
break; }
}
return result;
}
</code></pre>
</li>
</ul>
<p>39.输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路 径，最长路径的长度为树的深度。</p>
<p>思路:</p>
<ul>
<li>利用递归遍历分别返回左右子树深度</li>
</ul>
<p>代码实现:</p>
<pre><code>public int TreeDepth(TreeNode root) { if (root == null)
  return 0;
 int left = TreeDepth(root.left);
int right = TreeDepth(root.right);
 return left &gt; right ? left + 1 : right + 1;
  }
</code></pre>
<p>39.1输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>思路:</p>
<ul>
<li>平衡因子的绝对值&lt;= 1.</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean IsBalanced_Solution(TreeNode root) { if (root == null)
  return true;
    int left = getDepth(root.left); 
    int right = getDepth(root.right); 
    int diff = left - right;
 if (diff &gt;= -1 &amp;&amp; diff &lt;= 1) {
      return true;
  }
  return false;
  }
  public int getDepth(TreeNode root) { if (root == null)
   return 0; int depth = 0;
     int leftNode = getDepth(root.left);
int rightNode = getDepth(root.right);
  depth = leftNode &gt; rightNode ? leftNode : rightNode; return depth + 1;
    }
</code></pre>
<p>40.一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>思路:</p>
<ul>
<li>两个相同的数异或后为0，将所有数异或后得到一个数，然后求得1在该数最右边出现的index，然后判<br>断每个数右移index后是不是1。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) { if (array == null)
  return; num1[0] = 0;
num2[0] = 0;
  int number = array[0];
  for (int i = 1; i &lt; array.length; i++)
  number ^= array[i];
  // 异或后的数1出现在第几位 int index = 0;
  while ((number &amp; 1) == 0) {
  number = number &gt;&gt; 1;
  index++; }
  for (int i = 0; i &lt; array.length; i++) {
  // 判断第index位是不是0
  boolean isBit = ((array[i] &gt;&gt; index) &amp; 1) == 0; if (isBit) {
  num1[0] ^= array[i]; } else {
  num2[0] ^= array[i]; }
  } }
</code></pre>
<p>41.输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<p>思路:</p>
<ul>
<li>定义两个指针，分别递增，寻找和为s的序列。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) {       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  if (sum &lt; 3)
  return arrayList; int small = 1;
  int big = 2;
  while (small &lt; (sum + 1) / 2) {
  int s = 0;
  for (int i = small; i &lt;= big; i++) {
  s += i; }
  if (s == sum) {
  for (int i = small; i &lt;= big; i++) {
  list.add(i); }
  arrayList.add(new ArrayList&lt;&gt;(list)); list.clear();
  small++;
          } else {
              if (s &gt; sum) {
                  small++;
              } else {
   big++;
    } }
  }
      return arrayList;
  }
</code></pre>
<p>41.1输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的 和等于S，输出两个数的乘积最小的。</p>
<p>思路:</p>
<ul>
<li>定义两个指针，分别从前面和后面进行遍历。间隔越远乘积越小，所以是最先出现的两个数乘积最小</li>
</ul>
<p>代码实现:</p>
<pre><code>  public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  if (array == null )
  return list; int left = 0;
  int right = array.length - 1;
  while (left &lt; right) {
  int s = array[left] + array[right]; if (s == sum) {
  list.add(array[left]); list.add(array[right]); return list;
      }else {
          if (s &gt; sum) {
  right--; }else {
  left++; }
  } }
  return list;
    }
</code></pre>
<p>42.翻转字符串</p>
<p>思路:</p>
<ul>
<li>先将整个字符串翻转，然后将每个单词翻转。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public String ReverseSentence(String str) { if (str == null || str.length() == 0)
  return str;
  if (str.trim().length() == 0)
  return str;
  StringBuilder sb = new StringBuilder(); String re = reverse(str);
  String[] s = re.split(" ");
  for (int i = 0; i &lt; s.length - 1; i++) {
     sb.append(reverse(s[i]) + " "); }
  sb.append(reverse(s[s.length-1]));
  return String.valueOf(sb); }
  public String reverse(String str) {
  StringBuilder sb = new StringBuilder();
  for (int i = str.length() - 1; i &gt;= 0 ; i--) {
  sb.append(str.charAt(i)); }
  return String.valueOf(sb); }
</code></pre>
<p>42.1对于一个给定的字符序列S，请你把其循环左移K位后的序列输出</p>
<p>思路:</p>
<ul>
<li>拼接或反转三次字符串</li>
</ul>
<p>代码实现:</p>
<pre><code>  public String LeftRotateString(String str,int n) { if (str == null || str.length() == 0)
  return str;
  String s1 = reverse(str.substring(0,n));
  String s2 = reverse(str.substring(n,str.length())); return reverse(s2)+reverse(s1);
  }
</code></pre>
<p>43.把n个骰子扔在地上，所有骰子朝上一面的点数之和为s,输入n,打印出s的所有可能出现的概率</p>
<p>思路:</p>
<ul>
<li>递归一般是自顶向下的分析求解，而循环则是自底向上，占用更少的空间和更少的时间，性能较好。定 义一个二维数组，第一次掷骰子有6种可能，第一个骰子投完的结果存到probabilities[0];第二次开始掷骰子， 在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为n-1,n- 2,n-3, n-4,n-5，n-6的次数总和，所以我们把另一个数组的第n个数字设为前一个数组对应n-1,n-2,n-3,n-4,n-5， n-6之和</li>
</ul>
<p>代码实现:</p>
<pre><code>  public void printProbability(int number) {
  if(number&lt;1)
  return ;
  int g_maxValue=6;
  int[][] probabilities=new int[2][]; probabilities[0]=new int[g_maxValue*number+1];       probabilities[1]=new int[g_maxValue*number+1]; int flag=0;
  // 当第一次抛掷骰子时，有6种可能，每种可能出现一次 for(int i=1;i&lt;=g_maxValue;i++)
    probabilities[0][i]=1;
     //从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数， for(int k=2;k&lt;=number;++k) {
  for(int i=0;i&lt;k;++i)
  // 第k次掷骰子，和最小为k，小于k的情况是不可能发生的,令不可能发生的次数设置为0! probabilities[1-flag][i]=0;
  // 第k次掷骰子，和最小为k，最大为g_maxValue*k for(int i=k;i&lt;=g_maxValue*k;++i) {
  // 初始化，因为这个数组要重复使用，上一次的值要清0 probabilities[1-flag][i]=0;
  for(int j=1;j&lt;=i &amp;&amp; j&lt;=g_maxValue;++j)
  probabilities[1-flag][i]+=probabilities[flag][i-j];
  }
  flag=1-flag; }
  double total=Math.pow(g_maxValue, number); for(int i=number;i&lt;=g_maxValue*number;i++) {
  double ratio=(double) probabilities[flag][i]/total; System.out.println(i);
  System.out.println(ratio);
  } }
</code></pre>
<p>44.扑克牌的顺子</p>
<p>思路:</p>
<ul>
<li>用数组记录五张扑克牌，将数组调整为有序的，若0出现的次数&gt;=顺子的差值，即为顺子。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean isContinuous(int [] numbers) { if (numbers == null || numbers.length == 0)
  return false; int count = 0;
  int diff = 0; Arrays.sort(numbers);
  for (int i = 0; i &lt; numbers.length - 1; i++) { if (numbers[i] == 0) {
  count++;
  continue; }
  if (numbers[i] != numbers[i+1]) {
  diff += numbers[i+1] - numbers[i] - 1;
      } else {
          return false;
  } }
  if (diff &lt;= count) return true;
    return false;
    }
</code></pre>
<p>45.圆圈中最后剩下的数字(约瑟夫环)</p>
<p>思路:</p>
<ul>
<li>利用循环链表实现</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int LastRemaining_Solution(int n, int m) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); int bt = 0;
  for (int i = 0; i &lt; n; i ++) { list.add(i);
  }
  while (list.size() &gt; 1) {
  bt = (bt + m - 1) % list.size(); list.remove(bt);
  }
  return list.size() == 1 ? list.get(0) : -1; }
</code></pre>
<p>46.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A? B:C)。</p>
<p>思路:</p>
<ul>
<li>巧用递归(返回值类型为Boolean)</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int Sum_Solution(int n) { int sum = n;
  boolean result = (n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n-1)) &gt; 0);
  return sum; }
</code></pre>
<p>47.写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>思路:</p>
<ul>
<li>利用位运算</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int Add(int num1,int num2) { while (num2 != 0) {
  // 计算个位
  int temp = num1 ^ num2;
  // 计算进位(1+1)
  num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp;
     }
      return num1;
    }
</code></pre>
<p>48.不能被继承的类</p>
<p>思路:</p>
<ul>
<li>私有构造器的类不能继承<br>49.将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法 的数值则返回0</li>
</ul>
<p>思路:</p>
<ul>
<li>若为负数，则输出负数，字符0对应48,9对应57，不在范围内则返回false。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int StrToInt(String str) {
  if (str == null || str.length() == 0)
  return 0; int mark = 0;
  int number = 0;
  char[] chars = str.toCharArray();
  if (chars[0] == '-') mark = 1;
  for (int i = mark; i &lt; chars.length; i++) { if (chars[i] == '+') {
  continue; }
      if (chars[i] &lt; 48 || chars[i] &gt; 57) {
          return 0;
  }
  number = number * 10 + chars[i] - 48; }
  return mark == 0 ? number : -number; }
</code></pre>
<p>50.求树中两个节点的最低公共祖先<br>(1)树是二叉搜索树</p>
<p>思路:</p>
<ul>
<li>从树的根节点开始遍历，如果根节点的值大于其中一个节点，小于另外一个节点，则根节点就是最低公 共祖先。否则如果根节点的值小于两个节点的值，则递归求根节点的右子树，如果大于两个节点的值则递归求 根的左子树。如果根节点正好是其中的一个节点，那么说明这两个节点在一条路径上，所以最低公共祖先则是 根节点的父节点，时间复杂度是O(logn)，空间复杂度是O(1)</li>
</ul>
<p>代码实现:</p>
<pre><code>    public static BinaryTreeNode getLowestCommonAncestor(BinaryTreeNode rootParent,BinaryTreeNode root,  BinaryTreeNode node1,BinaryTreeNode node2){
  if(root == null || node1 == null || node2 == null){ return null;
  }
   if((root.value - node1.value)*(root.value - node2.value) &lt; 0){ return root;
  }else if((root.value - node1.value)*(root.value - node2.value) &gt; 0){
  BinaryTreeNode newRoot = ((root.value &gt; node1.value) &amp;&amp; (root.value &gt; node2.value))
  ? root.leftNode : root.rightNode;
  return getLowestCommonAncestor(root,newRoot, node1, node2);
  }else{
      return rootParent;
  } }
</code></pre>
<ul>
<li>(2)若树是普通树，但有指向父节点的指针 思路:两个节点如果在两条路径上，类似于求两个链表的第一个公共节点。由于每个节点的深度最多为logn，<br>所以时间复杂度为O(logn),空间复杂度O(1)</li>
</ul>
<p>代码实现:</p>
<pre><code>  public static BinaryTreeNode  getLowestCommonAncestor1(BinaryTreeNode root,BinaryTreeNode node1,
                                                     BinaryTreeNode node2){
  if(root == null || node1 == null || node2 == null){ return null;
  }
  int depth1 = findTheDepthOfTheNode(root, node1, node2); if(depth1 == -1){
  return node2.parentNode; }
  int depth2 = findTheDepthOfTheNode(root, node2, node1); if(depth2 == -1){
  return node1.parentNode; }
  //p指向较深的节点q指向较浅的节点
  BinaryTreeNode p = depth1 &gt; depth2 ? node1 : node2; BinaryTreeNode q = depth1 &gt; depth2 ? node2 : node1; int depth = Math.abs(depth1 - depth2);
  while(depth &gt; 0){
  p = p.parentNode; depth --;
  }
  while(p != q){
  p = p.parentNode;
  q = q.parentNode; }
  return p; }
  //求node1的深度，如果node1和node2在一条路径上，则返回-1，否则返回node1的深度
  public static int findTheDepthOfTheNode(BinaryTreeNode root,BinaryTreeNode node1,
  int depth = 0; while(node1.parentNode != null){
   node1 = node1.parentNode; depth ++;
  if(node1 == node2){
  return -1; }
  }
  return depth;
    }
</code></pre>
<ul>
<li>(3)若树是普通树，并没有指向父节点的指针 思路:用栈来实现类似于指向父节点指针的功能，获取node节点的路径时间复杂度为O(n),所以总的时间复杂<br>度是O(n),空间复杂度是O(logn)</li>
</ul>
<p>代码实现:</p>
<pre><code>  public static BinaryTreeNode getLowestCommonAncestor2(BinaryTreeNode root, BinaryTreeNode node1,
                                                    BinaryTreeNode node2){
  if(root == null || node1 == null || node2 == null){ return null;
  }
  Stack&lt;BinaryTreeNode&gt; path1 = new Stack&lt;BinaryTreeNode&gt;(); boolean flag1 = getThePathOfTheNode(root, node1,path1); if(!flag1){//树上没有node1节点
      return null;
  }
  Stack&lt;BinaryTreeNode&gt; path2 = new Stack&lt;BinaryTreeNode&gt;(); boolean flag2 = getThePathOfTheNode(root, node2,path2); if(!flag2){//树上没有node2节点
      return null;
  }
  if(path1.size() &gt; path2.size()){ //让两个路径等长 while(path1.size() != path2.size()){
  path1.pop(); }
  }else{
  while(path1.size() != path2.size()){
  path2.pop(); }
  }
  if(path1 == path2){//当两个节点在一条路径上时 path1.pop();
  return path1.pop(); }else{
  BinaryTreeNode p = path1.pop(); BinaryTreeNode q = path2.pop(); while(q != p){
  p = path1.pop();
  q = path2.pop(); }
    return p; }
  //获得根节点到node节点的路径
  public static boolean getThePathOfTheNode(BinaryTreeNode root,BinaryTreeNode node,
  }
  path.push(root); if(root == node){
return true;
  }
  boolean found = false; if(root.leftNode != null){
  Stack&lt;BinaryTreeNode&gt; path){
  found = getThePathOfTheNode(root.leftNode, node, path); }
  if(!found &amp;&amp; root.rightNode != null){
  found = getThePathOfTheNode(root.rightNode, node, path);
  }
  if(!found){
  path.pop(); }
  return found;
    }
</code></pre>
<p>51.在一个长度为n的数组里的所有数字都在0到n-1的范围内，找出数组中任意一个重复的数字</p>
<p>思路:</p>
<ul>
<li>若下标大于length，则减去length，最后再加上length，若下标的数组值大于length，则返回true。或使<br>用辅助空间(HashSet)</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean duplicate(int numbers[],int length,int [] duplication) { if (numbers == null || length == 0 || length == 1)
  return false;
  for (int i = 0; i &lt; length; i++) {
  int index = numbers[i]; if (index &gt;= length) index -= length;
  if (numbers[index] &gt;= length) { duplication[0] = index; return true;
  }
  numbers[index] += length; }
  return false;
    }
</code></pre>
<p>52.给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。 其中A[i] = 1。不能使用除法，</p>
<p>思路:</p>
<ul>
<li>使用矩阵法求解，将矩阵分为上三角矩阵和下三角矩阵，分别求乘积</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int[] multiply(int[] A) { int length = A.length;
  int[] B = new int[length]; if(length != 0 ){
  B[0] = 1;
  //计算下三角连乘
  for(int i = 1; i &lt; length; i++){
  B[i] = B[i-1] * A[i-1]; }
  int temp = 1;
  //计算上三角连乘
  for(int j = length-2; j &gt;= 0; j--){
  temp *= A[j+1];
  B[j] *= temp; }
  }
  return B; }
</code></pre>
<p>53.请实现一个函数用来匹配包括’.’和’’ 符可以出现任意次(包含0次)false 2 “”时:如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配;如果字符串第一个<br>字符跟模式第一个字符匹配或是点，可以有3种匹配方式:1 &gt;模式后移2字符，相当于x 2&gt;<br>‘.’ ‘’表示它前面的字</p>
<p>思路:</p>
<ul>
<li>当字符串只有一个字符时，进行判断，否则就有两种递归情况，(1)当模式中的第二个字符不是“”</li>
</ul>
<p>1 2 3&gt; 1</p>
<p>代码实现:</p>
<pre><code>  public boolean match(char[] str, char[] pattern) { if (str == null || pattern == null)
  return false;
  // 若字符串的长度为1
  if (str.length == 1) {
  if (pattern.length == 1){
  if (str[0] == pattern[0] || pattern[0] == '.')
              return true;
          return false;
  } }
  int sindex = 0;
  int pindex = 0;
  return matchIndex(str,sindex,pattern,pindex);
  }
  public boolean matchIndex(char[] str,int sindex, char[] pattern, int pindex) { // str和pattern同时到达末尾，则匹配成功
</code></pre>
<p>可以匹配多位;</p>
<pre><code>    if (sindex == str.length &amp;&amp; pindex == pattern.length) return true;
  // 若pattern先到尾，而str没有到达末尾，则匹配失败
  if (sindex != str.length &amp;&amp; pindex == pattern.length)
  return false;
  // 若pattern第二个字符是*
  if (pindex + 1 &lt; pattern.length &amp;&amp; pattern[pindex + 1] == '*') {
  if (sindex != str.length &amp;&amp; pattern[pindex] == str[sindex] || sindex != str.length &amp;&amp; pattern[pindex] == '.') {
          return matchIndex(str,sindex+1,pattern,pindex+2)
                  || matchIndex(str,sindex,pattern,pindex+2)
                  || matchIndex(str,sindex+1,pattern,pindex);
      } else {
          return matchIndex(str,sindex,pattern,pindex+2);
  } }
  // 若pattern第二个字符不是*
  if (sindex != str.length &amp;&amp; pattern[pindex] == str[sindex] ||
  sindex != str.length &amp;&amp; pattern[pindex] == '.') return matchIndex(str,sindex+1,pattern,pindex+1);
  return false;
    }
</code></pre>
<p>54.请实现一个函数用来判断字符串是否表示数值(包括整数和小数)</p>
<p>思路:</p>
<ul>
<li>逐个字符进行判断，e或E和小数点最多出现一次，而e或E的前一个必须是数字，且不能是第一个或最<br>后一个字符，符号的前一个字符不能是e或E。也可用正则表达式判断!</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean isNumeric(char[] str) { if (str == null)
   return false; int index = 0;
  int ecount = 0;
  int point = 0;
  // 如果第一个字符是符号就跳过 if (str[0] == '-' || str[0]
  index++;
  == '+')
  for (int i = index; i &lt; str.length; i++) { if (str[i] == '-' || str[i] == '+') {
  if (str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false;
  continue; }
  if (str[i] == 'e' || str[i] == 'E') { ecount++;
    if (ecount &gt; 1)
        return false;
  if (i == 0 || str[i-1] &lt; 48 || str[i-1] &gt; 57 || i == str.length-1)
    return false;
point++;
  continue; }
  if (str[i] == '.') { point++;
if (point &gt; 1)
    return false;
  continue; }
  // 出现非数字且不是e/E则返回false(小数点和符号用continue跳过了)
  if ((str[i] &lt; 48 || str[i] &gt; 57) &amp;&amp; (str[i] != 'e') &amp;&amp; (str[i] != 'E'))
return false;
  return true;
    }
</code></pre>
<p>55.请实现一个函数用来找出字符流中第一个只出现一次的字符。</p>
<p>思路:</p>
<ul>
<li>借助辅助空间进行判断，如字符数组。</li>
</ul>
<p>代码实现:</p>
<pre><code>  char[] chars = new char[256]; StringBuilder sb = new StringBuilder();
  public void Insert(char ch) { sb.append(ch);
  chars[ch]++;
    }
  public char FirstAppearingOnce() {
  char[] str = sb.toString().toCharArray(); for (char c : str) {
  if (chars[c] == 1) { return c;
  } }
  return '#'; }
</code></pre>
<p>56.一个链表中包含环，请找出该链表的环的入口结点。</p>
<p>思路:</p>
<ul>
<li>定义快慢两个指针，相遇后(环中相汇点)将快指针指向pHead 然后一起走，每次往后挪一位，相遇的 节点即为所求。详细分析:相遇即p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2 比p1多走一圈有2x=n+x; n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2 每次走一步直到p1==p2; 此时p1指向环的入口。</li>
</ul>
<p>代码实现:</p>
<pre><code>   public ListNode EntryNodeOfLoop(ListNode pHead) { if (pHead == null || pHead.next == null)
  return null; ListNode slow = pHead; ListNode fast = pHead;
  while (fast != null &amp;&amp; fast.next != null) { slow = slow.next;
  fast = fast.next.next;
  if (slow == fast){
  fast = pHead;
  while (fast != slow) {
  fast = fast.next;
  slow = slow.next; }
  if (fast == slow) return slow;
  } }
  return null;
    }
</code></pre>
<p>57.在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指 针。</p>
<p>思路:</p>
<ul>
<li>先新建一个头节点，然后向后查找值相同的节点，重复查找后删除</li>
</ul>
<p>代码实现:</p>
<pre><code>  public ListNode deleteDuplication(ListNode pHead) { if (pHead == null)
  return null;
  // 新建一个节点，防止头结点被删除 ListNode first = new ListNode(-1); first.next = pHead;
  ListNode p = pHead;
  // 指向前一个节点
  ListNode preNode = first;
  while (p != null &amp;&amp; p.next != null) { if (p.val == p.next.val) {
  int val = p.val;
  // 向后重复查找
  while (p != null &amp;&amp; p.val == val) {
  p = p.next; }
  // 上个非重复值指向下一个非重复值:即删除重复值
  preNode.next = p; }else {
  // 如果当前节点和下一个节点值不等，则向后移动一位 preNode = p;
    p = p.next; }
  }
  return first.next; }
</code></pre>
<p>58.给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅 包含左右子结点，同时包含指向父结点的指针。</p>
<p>思路:</p>
<ul>
<li>若节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子 节点即为下一个节点;若节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点;否则继续向上遍 历其父节点的父节点，重复之前的判断，返回结果</li>
</ul>
<p>代码实现:</p>
<pre><code>  public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null)
  return null;
  if (pNode.right != null) {
  pNode = pNode.right;
  while (pNode.left != null) {
  pNode = pNode.left; }
      return pNode;
  }
  while (pNode.next != null) {
  // 找第一个当前节点是父节点左孩子的节点 if (pNode.next.left == pNode)
  return pNode.next; pNode = pNode.next;
  }
  return null;
    }
</code></pre>
<p>59.请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样 的，定义其为对称的。</p>
<p>思路:</p>
<ul>
<li>利用递归进行判断，若左子树的左孩子等于右子树的右孩子且左子树的右孩子等于右子树的左孩子，并 且左右子树节点的值相等，则是对称的。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean isSymmetrical(TreeNode pRoot){ if (pRoot == null)
  return true;
  return isCommon(pRoot.left, pRoot.right);
  }
  public boolean isCommon(TreeNode leftNode, TreeNode rightNode) { if (leftNode == null &amp;&amp; rightNode == null)
     return true;
  if (leftNode != null &amp;&amp; rightNode != null) return leftNode.val == rightNode.val &amp;&amp;
  isCommon(leftNode.left,rightNode.right) &amp;&amp;
  isCommon(leftNode.right,rightNode.left); return false;
  }
</code></pre>
<p>60.请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序 打印，第三行按照从左到右的顺序打印，依此类推。</p>
<p>思路:</p>
<ul>
<li>利用两个栈的辅助空间分别存储奇数偶数层的节点，然后打印输出。或使用链表的辅助空间来实现，利 用链表的反向迭实现逆序输出。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null)
  return res;
  Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); // s1表示奇数，从右向左输出 Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); // s2表示偶数，从左向右输出 s1.push(pRoot);
  int level = 1;
  while (!s1.empty() || !s2.empty()) {
  if (level % 2 != 0) {
  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!s1.empty()) {
  TreeNode node = s1.pop(); if (node != null) {
  list.add(node.val); s2.push(node.left); s2.push(node.right);
  } }
  if (!list.isEmpty()) { res.add(list);
  level++; }
  } else {
  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!s2.empty()) {
  TreeNode node = s2.pop(); if (node != null) {
  list.add(node.val); s1.push(node.right); s1.push(node.left);
  } }
    if (!list.isEmpty()) { res.add(list);
  level++; }
  } }
  return res; }
</code></pre>
<p>61.从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>思路:</p>
<ul>
<li>利用辅助空间链表或队列来存储节点，每层输出。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null)
  return res;
  LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot);
  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  int start = 0;
  int end = 1;
  while (!queue.isEmpty()) { TreeNode node = queue.pop(); list.add(node.val);
  start++;
  if (node.left != null) queue.offer(node.left);
  if (node.right != null) queue.offer(node.right);
  if (start == end) { start = 0;
  end = queue.size();
  res.add(new ArrayList&lt;&gt;(list)); list.clear();
  } }
  return res; }
  62.请实现两个函数，分别用来序列化和反序列化二叉树 思路:序列化:前序遍历二叉树存入字符串中;反序列化:根据前序遍历重建二叉树。 代码实现:
  public String Serialize(TreeNode root) { StringBuffer sb = new StringBuffer();
  if (root == null){ sb.append("#,");
  return sb.toString(); }
  sb.append(root.val + ","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString();
  }
  public int index = -1;
  public TreeNode Deserialize(String str) {
  index++;
  int len = str.length(); String[] strr = str.split(","); TreeNode node = null;
  if (index &gt;= len) return null;
  if (!strr[index].equals("#")){
  node = new TreeNode(Integer.valueOf(strr[index])); node.left = Deserialize(str);
  node.right = Deserialize(str);
  }
  return node;
    }
</code></pre>
<p>63.给定一颗二叉搜索树，请找出其中的第k大的结点</p>
<p>思路:</p>
<ul>
<li>二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序，第k个结点就是第K大的节点，分别递<br>归查找左右子树的第K个节点，或使用非递归借用栈的方式查找，当count=k时返回根节点。</li>
</ul>
<p>代码实现:</p>
<pre><code>  int count = 0;
  public TreeNode KthNode(TreeNode pRoot, int k) {
  if (pRoot == null || k &lt; 1) return null;
  count++;
  if (count == k) {
      return pRoot;
  }
  TreeNode leftNode = KthNode(pRoot.left,k); if (leftNode != null)
      return leftNode;
  TreeNode rightNode = KthNode(pRoot.right,k); if (rightNode != null)
   return rightNode;
    return null;
    }
</code></pre>
<p>64.如何得到一个数据流中的中位数?如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位 于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>思路:</p>
<ul>
<li>创建优先级队列维护大顶堆和小顶堆两个堆，并且小顶堆的值都大于大顶堆的值，2个堆个数的差值小 于等于1，所以当插入个数为奇数时:大顶堆个数就比小顶堆多1，中位数就是大顶堆堆头;当插入个数为偶数 时，使大顶堆个数跟小顶堆个数一样，中位数就是 2个堆堆头平均数。也可使用集合类的排序方法。</li>
</ul>
<p>代码实现:</p>
<pre><code>  int count = 0;
  PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
  PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(16, new Comparator&lt;Integer&gt;() {
  @Override
  public int compare(Integer o1, Integer o2) {
  return o2.compareTo(o1); }
  });
    public void Insert(Integer num) {
  count++;
  // 当数据的个数为奇数时，进入大根堆 if ((count &amp; 1) == 1) {
  minHeap.offer(num);
  maxHeap.offer(minHeap.poll()); } else {
  maxHeap.offer(num);
  minHeap.offer(maxHeap.poll()); }
  }
  public Double GetMedian() { if (count == 0)
  return null;
  // 当数据个数是奇数时，中位数就是大根堆的顶点 if ((count &amp; 1) == 1) {
  return Double.valueOf(maxHeap.peek()); } else {
  return Double.valueOf((minHeap.peek() + maxHeap.peek())) / 2; }
  }
</code></pre>
<p>65.给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值</p>
<p>思路:</p>
<ul>
<li>两个for循环，第一个for循环滑动窗口，第二个for循环滑动窗口中的值，寻找最大值。还可以使用时间<br>复杂度更低的双端队列求解。</li>
</ul>
<p>代码实现:</p>
<pre><code>   public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  if (num == null || size &lt; 1 || num.length &lt; size)
  return list;
  int length = num.length - size + 1;
  for (int i = 0; i &lt; length; i++) {
  int current = size + i;
  int max = num[i];
  for (int j = i; j &lt; current; j++) {
  if (max &lt; num[j]) { max = num[j];
  } }
  list.add(max); }
  return list;
    }
</code></pre>
<p>66.请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中 的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵 中的某一个格子，则该路径不能再进入该格子。</p>
<p>思路:</p>
<ul>
<li>回溯法，双层for循环，判断每一个点，每次递归调用上下左右四个点，用flag标志是否已经匹配 (return)，进行判断点的位置是否越界，是否已经正确匹配，判断矩阵的路径与模式串的第index个字符是否 匹配。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public boolean hasPath(char[] matrix, int rows, int cols, char[] str) { int flag[] = new int[matrix.length];
  for (int i = 0; i &lt; rows; i++) {
  for (int j = 0; j &lt; cols; j++) {
  if (helper(matrix, rows, cols, i, j, str, 0, flag))
  return true;
  } }
  return false;
    }
  private boolean helper(char[] matrix,int rows,int cols,int i,int j,char[] str,int k,int[] flag) { int index = i * cols + j;
  if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1)
      return false;
  if(k == str.length - 1) return true;
  flag[index] = 1;
  if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)
  || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)
    || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)
          || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) {
      return true;
  }
  flag[index] = 0; return false;
  }
</code></pre>
<p>67.地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方 向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。</p>
<p>思路:</p>
<ul>
<li>利用递归实现，每次只能走上下左右四个点，进行判断点的位置是否越界，点数之和是否大于K，是否 已经走过了。</li>
</ul>
<p>代码实现:</p>
<pre><code>  public int movingCount(int threshold, int rows, int cols) { int flag[][] = new int[rows][cols]; //记录是否已经走过 return helper(0, 0, rows, cols, flag, threshold);
  }
  private int helper(int i, int j, int rows, int cols, int[][] flag, int threshold) { if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols ||
  numSum(i) + numSum(j) &gt; threshold || flag[i][j] == 1) return 0;
  flag[i][j] = 1;
  return helper(i - 1, j, rows, cols, flag, threshold)
  + helper(i + 1, j, rows, cols, flag, threshold)
  + helper(i, j - 1, rows, cols, flag, threshold)
  + helper(i, j + 1, rows, cols, flag, threshold) + 1;
  }
  private int numSum(int i) { int sum = 0;
  while (i &gt; 0) { sum += i % 10;
  i = i / 10; }
  return sum; }
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">lichongbing</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.lichongbing.com/2019/12/10/mu-ke-wang-jian-zhi-offer-mian-shi-ti/">https://www.lichongbing.com/2019/12/10/mu-ke-wang-jian-zhi-offer-mian-shi-ti/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">lichongbing</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/12/11/osi-qi-ceng-mo-xing/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="OSI七层模型">
                        
                        <span class="card-title">OSI七层模型</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-12-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            lichongbing
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/12/09/jiang-bo-ke-ban-zhi-csdn/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="《将博客搬至CSDN》">
                        
                        <span class="card-title">《将博客搬至CSDN》</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-12-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            lichongbing
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src=""></script>
<script>
    $.getScript("/libs/tocbot/tocbot.min.js",function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    })
</script>

    

</main>



<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

</main>

<footer class="page-footer bg-color">
    
    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2018-2022</span>
            
            <a href="/about" target="_blank">lichongbing</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
                <span id="icp"><img src="/medias/icp.png"
                                    style="vertical-align: text-bottom;"/>
                <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">蜀ICP备18037498号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lichongbing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:873610008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=873610008" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 873610008" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/lichongbing" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/lichongbing" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

<!-- 深色模式按钮 -->
<a onclick="switchNightMode()" id="sma" title="模式切换">
    <i class="fa fa-moon" id="nightMode" aria-hidden="true"></i>
</a>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


<script type="text/javascript">
    $.getScript("https://files.islu.cn/static/pjax/pjax.min.js",loadPjax)
    function loadPjax(){
        var pjax = new Pjax({
            selectors: [
                "head title",
                'head meta[name="keywords"]',
                'head meta[name="description"]',
                "main#main_wrap",
                "#rightside"
            ],
            cache: true,
            cacheBust: false
        });
    }

    // 开始 PJAX 执行的函数
    document.addEventListener('pjax:send', function () {
    });
    // PJAX 完成之后执行的函数，可以和上面的重载放在一起
    document.addEventListener('pjax:complete', function () {
        document.querySelectorAll('script[data-pjax]').forEach(item => {
            const newScript = document.createElement('script')
            const content = item.text || item.textContent || item.innerHTML || ""
            Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
            newScript.appendChild(document.createTextNode(content))
            item.parentNode.replaceChild(newScript, item)
        })
    });

    // Pjax请求错误时，跳转到404页面
    document.addEventListener('pjax:error', (err) => {
        if (err.request.status === 404) {
            pjax.loadUrl('/404.html')
        }
    })
</script>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>





<!-- 雪花特效 -->


<!-- 鼠标星星特效 -->



    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button"
            hidden></button>


<!-- Baidu Analytics -->

<!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


    <script src="/libs/others/clicklove.js" async="async"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>






<!--腾讯兔小巢-->








    <script src="/libs/instantpage/instantpage.js" type="module"></script>


</body>

</html>

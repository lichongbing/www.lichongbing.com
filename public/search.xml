<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>目标任务执行管理时间自动记录App</title>
      <link href="/2022/04/25/mu-biao-ren-wu-zhi-xing-guan-li-shi-jian-zi-dong-ji-lu-app/"/>
      <url>/2022/04/25/mu-biao-ren-wu-zhi-xing-guan-li-shi-jian-zi-dong-ji-lu-app/</url>
      
        <content type="html"><![CDATA[<h2 id="不忘初心"><a href="#不忘初心" class="headerlink" title="不忘初心"></a>不忘初心</h2><blockquote><p>大概2012年的时候，老王同学带着ipad，给我玩了一下，从那以后，我爱上了ipad，没过多久，我带上我的老汪同学，去成都百脑汇买ipad，从那以后，我更加崇拜乔布斯，后来买了iPhone。乔布斯有句话影响了我，就是“活着就是改变世界”，于是开始成为产品经理，打算设计自己的一款产品，后来学习UI设计，当时我和朋友编程技术欠缺，但因考虑眼前的苟活，最终没能做出一款成品。发现产品经理，UI设计入门容易，但是无法不能真正的想法落地，为了实现我的产品梦，验证我的想法，对编程技术的略知一二是无法真正的把想法创意落地，于是走上编程不归之路。自己的需求和想法，没有人比自己更加了解，因此自己写的产品肯定适合自己，如果自己喜欢，我就强烈推荐大家使用。</p></blockquote><h2 id="开发目标任务执行管理时间自动记录的动机"><a href="#开发目标任务执行管理时间自动记录的动机" class="headerlink" title="开发目标任务执行管理时间自动记录的动机"></a>开发目标任务执行管理时间自动记录的动机</h2><blockquote><p>年龄越大，恰好一事无成，深知人最宝贵的是生命。但是仔细分析一下这个生命，可以说，最宝贵的是时间。因为生命是由时间构成的，是一小时一小时、一分钟一分钟累积起来的。于是我深深明白了对时间的高效利用和自由支配才能增加生活的幸福指数。把时间拿去刷抖音、玩游戏、甚至是购买不需要的东西，这些时间反而成了你的负债。要学会思考时间的利用与管理，如果昨天的时间再给我重新使用，会拿去做什么？深度反思具体问题，对于成年人的进步具有重大的意义。道理都懂了，就开始行动，于是我开发一款开发目标任务执行管理和时间自动记录统计花费。理念来自柳比歇夫时间统计法和番茄工作法。柳比歇夫通过他的时间统计法对自己进行了研究和试验：试验在写、读、听、工作、思索各方面，他到底能干多少？干多少？怎么干？他不让自己负担过重，力不胜任；他总是循着他能力的边缘前进，他对自己能力的掂量精确无疑。番茄工作法是如何保持做事专注，劳逸结合的科学工作法。如果每个人都能知道自己能干些什么，那生活会变得多么美好！因为每个人的能力都比他自己感觉到的大得多，也就不会有那么多的人感叹自己因能力有限而导致一事无成。</p></blockquote><h2 id="开发目标任务执行管理时间自动记录介绍"><a href="#开发目标任务执行管理时间自动记录介绍" class="headerlink" title="开发目标任务执行管理时间自动记录介绍"></a>开发目标任务执行管理时间自动记录介绍</h2><blockquote><p>软件名称是Timing，时间记录规划统计的意思。</p></blockquote><ul><li><p>目标清单</p><ul><li>目标添加<blockquote><p>添加目标任务名称，预计花费多少时间</p></blockquote></li></ul><p> <img src="http://image.lichongbing.com/IMG_4494.PNG" alt="IMG_4494"></p><ul><li>目标修改<blockquote><p>修改目标是否完成</p></blockquote></li></ul><p> <img src="http://image.lichongbing.com/IMG_4496.PNG" alt="IMG_4496"></p><ul><li>目标删除显示<blockquote><p>短期目标，临时目标，错误目标可以删除显示，后期在目标历史查看<br><img src="http://image.lichongbing.com/IMG_4495.PNG" alt="IMG_4495"></p></blockquote></li></ul></li><li><p>任务执行</p><blockquote><p>有了目标就要去落地执行，具体到可执行的事上。  </p></blockquote><p>  <img src="http://image.lichongbing.com/IMG_4497.PNG" alt="IMG_4497"></p><p>  <img src="http://image.lichongbing.com/IMG_4498.PNG" alt="IMG_4498"></p><ul><li>任务添加<blockquote><p>添加任务名称</p></blockquote></li><li>任务修改<blockquote><p>修改任务信息<br><img src="http://image.lichongbing.com/IMG_4499.PNG" alt="IMG_4499"></p></blockquote></li><li>删除任务<blockquote><p>有错误的，需要删除。</p></blockquote></li></ul></li><li><p>标签分类</p><blockquote><p>标签分类方便目标管理统计，后期复盘分析。  </p></blockquote><p>  <img src="http://image.lichongbing.com/IMG_4500.PNG" alt="IMG_4500"></p><ul><li>标签添加<blockquote><p>添加名称，颜色参数</p></blockquote></li></ul><p><img src="http://image.lichongbing.com/IMG_4501.PNG" alt="IMG_4501"></p><ul><li>标签修改<blockquote><p>修改名称，颜色参数</p></blockquote></li><li>删除标签<blockquote><p>有错误的，需要删除。   </p></blockquote></li></ul></li><li><p>时间轴 </p><blockquote><p>自动记录每天每件事花费时间，形成时间轴，数据实时刷新更新。从周日到下周六，方便复盘整理。</p></blockquote><p> <img src="http://image.lichongbing.com/IMG_4503.PNG" alt="IMG_4503"></p></li><li><p>目标进度</p><blockquote><p>自动计算目标的进度和预期，方便以后做新的计划参考，做到对自己能力掂量预估。展示的是未完成的目标进度<br> <img src="http://image.lichongbing.com/IMG_4504.PNG" alt="IMG_4504"></p></blockquote></li><li><p>快捷指令创建</p><blockquote><p>快捷指令是苹果手机工作流，自动化执行，不用打开app，自动执行</p></blockquote><ul><li>目前实现添加自动记录时间功能，支持下拉框选择自动记录的目标和任务，和标签。</li></ul><p><img src="http://image.lichongbing.com/IMG_4505.PNG" alt="IMG_4505"><br>下拉框任务名称选择，这是来源App里的任务创建<br><img src="http://image.lichongbing.com/IMG_4506.PNG" alt="IMG_4506"><br>下拉框选择标签 这是来源App里的标签创建<br><img src="http://image.lichongbing.com/IMG_4507.PNG" alt="IMG_4507"><br>下拉框选择目标 这是来源App里的目标创建，这里是展示未完成的目标<br><img src="http://image.lichongbing.com/IMG_4508.PNG" alt="IMG_4507"><br>时间选择当前时间 格式为 RFC2822<br><img src="http://image.lichongbing.com/IMG_4509.PNG" alt="IMG_4507"></p><ul><li>快捷指令支持多场景触法事件，网络请求事件，Wi-Fi连接事件，地点到达触法事件，NFC感应触碰事件等<blockquote><p>下面是场景情况，根据自己情况去选择。</p></blockquote></li></ul><p><img src="http://image.lichongbing.com/IMG_4512.PNG" alt="IMG_4512"></p><p><img src="http://image.lichongbing.com/IMG_4513.PNG" alt="IMG_4512"></p><blockquote><p>下面是手动触法的快捷指令</p></blockquote><p><img src="http://image.lichongbing.com/IMG_4510.PNG" alt="IMG_4510"></p><blockquote><p>下面是自动化触法快捷指令 </p></blockquote><p><img src="http://image.lichongbing.com/IMG_4511.PNG" alt="IMG_4511"></p><blockquote><p>还支持Siri语音交互。</p></blockquote></li></ul><h2 id="体验公测地址"><a href="#体验公测地址" class="headerlink" title="体验公测地址"></a>体验公测地址</h2><blockquote><p>下面是我使用的拍照</p></blockquote><p> <img src="http://image.lichongbing.com/IMG_4490.JPG" alt="IMG_4490"></p><p> <img src="http://image.lichongbing.com/IMG_4489.JPG" alt="IMG_4489"></p><p> <img src="http://image.lichongbing.com/IMG_4488.JPG" alt="IMG_4488"></p><blockquote><p>特别说明，照片中我用到nfc贴纸，用亚克力透明盒相框，我一天做事分四类学习，总结，工作，休息，用到沙漏计时休息5分钟，工作学习的时长根据自身精力来决定，累了就打卡休息。期间可以喝水，上厕所。</p></blockquote><blockquote><p><a href="https://testflight.apple.com/join/F8hVrLzs">公测地址</a>,系统版本ios14以上。有什么好的意见给我发电子邮件，我会改进软件，提升用户体验。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从0到1开发开发打包和上架苹果商店（一）</title>
      <link href="/2022/04/10/cong-0-dao-1-kai-fa-kai-fa-da-bao-he-shang-jia-ping-guo-shang-dian-yi/"/>
      <url>/2022/04/10/cong-0-dao-1-kai-fa-kai-fa-da-bao-he-shang-jia-ping-guo-shang-dian-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这次系统记录从0到1开发开发打包和上架苹果商店。前提条件拥有开发者会员的AppID</p></blockquote><h2 id="第一步-创建-App-IDs-和申请开发调试证书和打包发布证书"><a href="#第一步-创建-App-IDs-和申请开发调试证书和打包发布证书" class="headerlink" title="第一步 创建 App IDs 和申请开发调试证书和打包发布证书"></a>第一步 创建 App IDs 和申请开发调试证书和打包发布证书</h2><ul><li>本地证书生成准备用来申请下载申请开发调试证书Certificates和打包发布证书Certificates<br><img src="http://image.lichongbing.com/IMG_4397.PNG" alt="IMG_4397"><br><img src="http://image.lichongbing.com/IMG_4400.PNG" alt="IMG_4400"><br><img src="http://image.lichongbing.com/IMG_4398.PNG" alt="IMG_4398"><br><img src="http://image.lichongbing.com/IMG_4399.PNG" alt="IMG_4399"></li><li> apple 官网申请 创建 Certificates 对应申请并下载<br><img src="http://image.lichongbing.com/IMG_4405.PNG" alt="IMG_4405"><br><img src="http://image.lichongbing.com/IMG_4406.PNG" alt="IMG_4406"><br><img src="http://image.lichongbing.com/IMG_4407.PNG" alt="IMG_4407"></li><li>创建 Identifiers<blockquote><p>创建 App IDs 以 ‘com.lichongbing.demo’ 为例</p></blockquote></li></ul><p><img src="http://image.lichongbing.com/IMG_4401.PNG" alt="IMG_4401"><br><img src="http://image.lichongbing.com/IMG_4402.PNG" alt="IMG_4402"><br><img src="http://image.lichongbing.com/IMG_4404.PNG" alt="IMG_4404"><br><img src="http://image.lichongbing.com/IMG_4403.PNG" alt="IMG_4403"></p><ul><li>创建 对应的Profiles<blockquote><p>申请开发 iOS App Development 和打包发布 iOS App Distribution</p></blockquote></li></ul><p><img src="http://image.lichongbing.com/IMG_4410.PNG" alt="IMG_4410"><br><img src="http://image.lichongbing.com/IMG_4408.PNG" alt="IMG_4408"><br><img src="http://image.lichongbing.com/IMG_4414.PNG" alt="IMG_4414"><br><img src="http://image.lichongbing.com/IMG_4413.PNG" alt="IMG_4413"></p><ul><li>下载密钥keys</li></ul><h2 id="第二步-创建-对应-App-IDs-开发工程"><a href="#第二步-创建-对应-App-IDs-开发工程" class="headerlink" title="第二步 创建 对应 App IDs 开发工程"></a>第二步 创建 对应 App IDs 开发工程</h2><ul><li>创建工程</li></ul><p><img src="http://image.lichongbing.com/IMG_4421.PNG" alt="IMG_4421"></p><blockquote><p>手动配置开发证书和手动配置打包证书</p></blockquote><ul><li>手动上传Proflie </li></ul><p><img src="http://image.lichongbing.com/IMG_4423.PNG" alt="IMG_4423"></p><ul><li>对应配置Profile</li></ul><p><img src="http://image.lichongbing.com/IMG_4415.PNG" alt="IMG_4415"></p><h2 id="第三步-测试打包证书"><a href="#第三步-测试打包证书" class="headerlink" title="第三步 测试打包证书"></a>第三步 测试打包证书</h2><p><img src="http://image.lichongbing.com/IMG_4417.PNG" alt="IMG_4417"></p><ul><li>输入密钥keys的密码</li></ul><p><img src="http://image.lichongbing.com/IMG_4420.PNG" alt="IMG_4420"></p><h2 id="第四步-测试开发证书"><a href="#第四步-测试开发证书" class="headerlink" title="第四步 测试开发证书"></a>第四步 测试开发证书</h2><p><img src="http://image.lichongbing.com/IMG_4418.PNG" alt="IMG_4418"></p><ul><li>输入密钥keys的密码</li></ul><p><img src="http://image.lichongbing.com/IMG_4416.PNG" alt="IMG_4416"></p><h2 id="第五步-登录至-App-Store-Connect"><a href="#第五步-登录至-App-Store-Connect" class="headerlink" title="第五步 登录至 App Store Connect"></a>第五步 登录至 App Store Connect</h2><blockquote><p>如果您是“帐户持有人”，请使用注册“Apple 开发者计划”的 Apple ID 登录；其他用户请使用收到邀请的电子邮件地址登录</p></blockquote><ul><li>请前往<a href="https://appstoreconnect.apple.com/">App Store Connect</a>然后使用您的 Apple ID 登录</li><li>点按首页上的MyAPP</li><li>添加App</li></ul><p><img src="http://image.lichongbing.com/IMG_4427.PNG" alt="IMG_4427"></p><h2 id="第六步-在Xcode中打包上传App"><a href="#第六步-在Xcode中打包上传App" class="headerlink" title="第六步 在Xcode中打包上传App"></a>第六步 在Xcode中打包上传App</h2><p>选中菜单<code>Product</code> -&gt; <code>Archive</code> </p><p><img src="http://image.lichongbing.com/IMG_4456.PNG" alt="IMG_4456"></p><p>选择语言<br><img src="http://image.lichongbing.com/IMG_4453.PNG" alt="IMG_4453"></p><p>默认<br><img src="http://image.lichongbing.com/IMG_4449.PNG" alt="IMG_4449"></p><p>发布 App Store Connect<br><img src="http://image.lichongbing.com/IMG_4455.PNG" alt="IMG_4455"></p><p>选择打包证书Certificates 和Profile文件<br><img src="http://image.lichongbing.com/IMG_4448.PNG" alt="IMG_4448"></p><p>开始 输入密钥keys密码<br><img src="http://image.lichongbing.com/IMG_4446.PNG" alt="IMG_4446"></p><p>选择导出本地<br><img src="http://image.lichongbing.com/IMG_4445.PNG" alt="IMG_4445"></p><p><img src="http://image.lichongbing.com/IMG_4444.PNG" alt="IMG_4444"></p><p>上传工具</p><p><img src="http://image.lichongbing.com/IMG_4443.PNG" alt="IMG_4443"></p><p><img src="http://image.lichongbing.com/IMG_4442.PNG" alt="IMG_4442"></p><p>选中刚才打包的ipa</p><p><img src="http://image.lichongbing.com/IMG_4435.PNG" alt="IMG_4435"></p><p>开始验证<br><img src="http://image.lichongbing.com/IMG_4433.PNG" alt="IMG_4433"></p><p>交付发送到 App Store Connect<br><img src="http://image.lichongbing.com/IMG_4434.PNG" alt="IMG_4434"></p><p>在 App Store Connect 后台查看如下 说明上传成功，可以邀请测试<br><img src="http://image.lichongbing.com/IMG_4457.PNG" alt="IMG_4457"></p>]]></content>
      
      
      <categories>
          
          <category> IOS App 移动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 脚手架环境搭建</title>
      <link href="/2021/05/13/vue-js-jiao-shou-jia-huan-jing-da-jian/"/>
      <url>/2021/05/13/vue-js-jiao-shou-jia-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h4 id="npm镜像源设置"><a href="#npm镜像源设置" class="headerlink" title="npm镜像源设置"></a>npm镜像源设置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g cnpm --registry<span class="token operator">=</span>https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装Yarn"><a href="#安装Yarn" class="headerlink" title="安装Yarn"></a>安装Yarn</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> i <span class="token function">yarn</span> -g -verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Yarn镜像源设置"><a href="#Yarn镜像源设置" class="headerlink" title="Yarn镜像源设置"></a>Yarn镜像源设置</h4><pre class="line-numbers language-none"><code class="language-none">yarn config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><pre class="line-numbers language-none"><code class="language-none">sudo cnpm install webpack -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h4><pre class="line-numbers language-none"><code class="language-none">sudo cnpm install -g vue-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><pre class="line-numbers language-none"><code class="language-none">sudo vue init webpack blog-ui<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><pre class="line-numbers language-none"><code class="language-none">.├── README.md├── build├── config├── index.html├── node_modules├── package.json├── src├── static├── test└── yarn.lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre class="line-numbers language-none"><code class="language-none">cd blog-uiyarn install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装成功如下</p> <pre class="line-numbers language-none"><code class="language-none"> yarn install v1.22.10[1/5] ?  Validating package.json...[2/5] ?  Resolving packages...success Already up-to-date.✨  Done in 0.59s.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目结构如下</p><pre class="line-numbers language-none"><code class="language-none">.├── README.md├── build├── config├── index.html├── node_modules├── package.json├── src├── static├── test└── yarn.lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h4><pre class="line-numbers language-none"><code class="language-none">cnpm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功显示如下</p><pre class="line-numbers language-none"><code class="language-none"> DONE  Compiled successfully in 2405ms                                                                      上午10:07:45 I  Your application is running here: http://localhost:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>访问地址<br><a href="http://localhost:8080/">http://localhost:8080</a></p><p>显示如下表示项目脚手架搭建成功</p><p><img src="http://image.lichongbing.com/IMG_2970.JPG" alt="IMG_2970"></p><h4 id="依赖包异常问题"><a href="#依赖包异常问题" class="headerlink" title="依赖包异常问题"></a>依赖包异常问题</h4><p><img src="http://image.lichongbing.com/IMG_2991.JPG" alt="IMG_2991"></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf node_modules<span class="token function">rm</span> package-lock.json<span class="token function">npm</span> cache <span class="token function">clear</span> --force<span class="token function">npm</span> <span class="token function">install</span>cnpm run serve<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人大金仓数据库KingBase+SpringBoot+MyBatis的使用</title>
      <link href="/2021/05/12/ren-da-jin-cang-shu-ju-ku-kingbase-springboot-mybatis-de-shi-yong/"/>
      <url>/2021/05/12/ren-da-jin-cang-shu-ju-ku-kingbase-springboot-mybatis-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="驱动包下载"><a href="#驱动包下载" class="headerlink" title="驱动包下载"></a>驱动包下载</h3><p>访问人大金仓<a href="https://www.kingbase.com.cn/">官网</a></p><p><img src="https://image.lichongbing.com/IMG_2963.JPG" alt="IMG_2963"></p><p>找到下载与服务中软件下载<br><img src="https://image.lichongbing.com/IMG_2964.JPG" alt="IMG_2964"></p><p>选择金仓数据库管理系统<br><img src="https://image.lichongbing.com/IMG_2965.JPG" alt="IMG_2965"></p><p>选择v8R3</p><p><img src="https://image.lichongbing.com/IMG_2966.JPG" alt="IMG_2966"></p><p>下载驱动</p><p><img src="https://image.lichongbing.com/IMG_2967.JPG" alt="IMG_2967"></p><h2 id="通过IDEA导入外库依赖jar包"><a href="#通过IDEA导入外库依赖jar包" class="headerlink" title="通过IDEA导入外库依赖jar包"></a>通过IDEA导入外库依赖jar包</h2><p><img src="https://image.lichongbing.com/IMG_2968.JPG" alt="IMG_2968"></p><p>POM配置</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.4.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.lichongbing&lt;/groupId&gt;    &lt;artifactId&gt;demo2&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;demo2&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;kingbase&lt;/groupId&gt;            &lt;artifactId&gt;kingbase8&lt;/artifactId&gt;            &lt;version&gt;8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span> <span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> dghy    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>kingbase<span class="token punctuation">:</span>locahost<span class="token punctuation">:</span>5432/dghy<span class="token punctuation">?</span>zeroDateTimeBehavior=convertToNull<span class="token important">&amp;useUnicode=true&amp;characterEncoding=utf-</span><span class="token number">8</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.kingbase.Driver <span class="token key atrule">mybatis</span><span class="token punctuation">:</span>  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>mapping/<span class="token important">*Mapper.xml</span> <span class="token comment">#showSql</span><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">level</span><span class="token punctuation">:</span>    <span class="token key atrule">com</span><span class="token punctuation">:</span>      <span class="token key atrule">example</span><span class="token punctuation">:</span>        <span class="token key atrule">mapper</span> <span class="token punctuation">:</span> debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span> <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.lichongbing.demo2.mapper.FavoriteMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.lichongbing.demo2.entity.Favorite<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>favorite_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>favorite_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>resource_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>resource_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wname<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wname<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wid<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wid<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>collection_user_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>collection_user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create_user_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create_user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create_date<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DATE<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create_date<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update_user_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update_user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update_date<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DATE<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update_date<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isvalid<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>NUMERIC<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isvalid<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>note<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>note<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>iid<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>iid<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>class_type<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>class_type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>remark<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>remark<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Sel<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.lichongbing.demo2.entity.Favorite<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from cf_favorite where favorite_id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>entity</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span><span class="token punctuation">;</span><span class="token comment">/** * @author lichongbing * @version 1.0.0 * @date 2021/5/12 9:43 上午 * @description: 收藏实体类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Favorite</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 主键id     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> favoriteId<span class="token punctuation">;</span>    <span class="token comment">/**     * 资源编号     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> resourceId<span class="token punctuation">;</span>    <span class="token comment">/**     * 业务类型名称     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> wname<span class="token punctuation">;</span>    <span class="token comment">/**     * 业务类型ID     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> wid<span class="token punctuation">;</span>    <span class="token comment">/**     * 收藏人编号     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> collectionUserId<span class="token punctuation">;</span>    <span class="token comment">/**     * 创建用户编号     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createUserId<span class="token punctuation">;</span>    <span class="token comment">/**     * 创建时间     */</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> createDate<span class="token punctuation">;</span>    <span class="token comment">/**     * 更新用户编号     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updateUserId<span class="token punctuation">;</span>    <span class="token comment">/**     * 更新时间     */</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> updateDate<span class="token punctuation">;</span>    <span class="token comment">/**     * 是否有效,默认0: 有限，1：无效     */</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> isvalid<span class="token punctuation">;</span>    <span class="token comment">/**     * 备注     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> note<span class="token punctuation">;</span>    <span class="token comment">/**     * 业务主键     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> iID<span class="token punctuation">;</span>    <span class="token comment">/**     * 所属分类     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> classType<span class="token punctuation">;</span>    <span class="token comment">/**     * 标注     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> remark<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFavoriteId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> favoriteId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFavoriteId</span><span class="token punctuation">(</span><span class="token class-name">String</span> favoriteId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>favoriteId <span class="token operator">=</span> favoriteId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getResourceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> resourceId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setResourceId</span><span class="token punctuation">(</span><span class="token class-name">String</span> resourceId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>resourceId <span class="token operator">=</span> resourceId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getWname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> wname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWname</span><span class="token punctuation">(</span><span class="token class-name">String</span> wname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>wname <span class="token operator">=</span> wname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getWid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> wid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWid</span><span class="token punctuation">(</span><span class="token class-name">String</span> wid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>wid <span class="token operator">=</span> wid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCollectionUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> collectionUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCollectionUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> collectionUserId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>collectionUserId <span class="token operator">=</span> collectionUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCreateUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> createUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCreateUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> createUserId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>createUserId <span class="token operator">=</span> createUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">getCreateDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> createDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCreateDate</span><span class="token punctuation">(</span><span class="token class-name">Date</span> createDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>createDate <span class="token operator">=</span> createDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUpdateUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> updateUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUpdateUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> updateUserId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>updateUserId <span class="token operator">=</span> updateUserId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">getUpdateDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> updateDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUpdateDate</span><span class="token punctuation">(</span><span class="token class-name">Date</span> updateDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>updateDate <span class="token operator">=</span> updateDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getIsvalid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> isvalid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIsvalid</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> isvalid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isvalid <span class="token operator">=</span> isvalid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> note<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNote</span><span class="token punctuation">(</span><span class="token class-name">String</span> note<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>note <span class="token operator">=</span> note<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getiID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> iID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setiID</span><span class="token punctuation">(</span><span class="token class-name">String</span> iID<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iID <span class="token operator">=</span> iID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getClassType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> classType<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setClassType</span><span class="token punctuation">(</span><span class="token class-name">String</span> classType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>classType <span class="token operator">=</span> classType<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getRemark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> remark<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token class-name">String</span> remark<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>remark <span class="token operator">=</span> remark<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Favorite{"</span> <span class="token operator">+</span>                <span class="token string">"favoriteId='"</span> <span class="token operator">+</span> favoriteId <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", resourceId='"</span> <span class="token operator">+</span> resourceId <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", wname='"</span> <span class="token operator">+</span> wname <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", wid='"</span> <span class="token operator">+</span> wid <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", collectionUserId='"</span> <span class="token operator">+</span> collectionUserId <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", createUserId='"</span> <span class="token operator">+</span> createUserId <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", createDate="</span> <span class="token operator">+</span> createDate <span class="token operator">+</span>                <span class="token string">", updateUserId='"</span> <span class="token operator">+</span> updateUserId <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", updateDate="</span> <span class="token operator">+</span> updateDate <span class="token operator">+</span>                <span class="token string">", isvalid="</span> <span class="token operator">+</span> isvalid <span class="token operator">+</span>                <span class="token string">", note='"</span> <span class="token operator">+</span> note <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", iID='"</span> <span class="token operator">+</span> iID <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", classType='"</span> <span class="token operator">+</span> classType <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", remark='"</span> <span class="token operator">+</span> remark <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token char">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据访问层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>mapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Favorite</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Repository</span><span class="token punctuation">;</span><span class="token comment">/** * @author lichongbing * @version 1.0.0 * @date 2021/5/12 10:03 上午 * @description: TODO */</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FavoriteMapper</span> <span class="token punctuation">{</span>    <span class="token class-name">Favorite</span> <span class="token class-name">Sel</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>业务逻辑层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>service</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Favorite</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span></span><span class="token class-name">FavoriteMapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Service</span><span class="token punctuation">;</span><span class="token comment">/** * @author lichongbing * @version 1.0.0 * @date 2021/5/12 10:02 上午 * @description: TODO */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FavoriteService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">FavoriteMapper</span> favoriteMapper<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Favorite</span> <span class="token class-name">Sel</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">favoriteMapper<span class="token punctuation">.</span></span>Sel</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制访问层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Favorite</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">FavoriteService</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">PathVariable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span><span class="token punctuation">;</span><span class="token comment">/** * @author lichongbing * @version 1.0.0 * @date 2021/5/12 9:59 上午 * @description: TODO */</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/favorite"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FavoriteController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">FavoriteService</span> favoriteService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"getFavorite/{id1}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Favorite</span> <span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> id <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">favoriteService<span class="token punctuation">.</span></span>Sel</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主程序入口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>lichongbing<span class="token punctuation">.</span>demo2</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">ComponentScan</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"com.lichongbing.demo2.mapper"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Demo2Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gitlab部署教程</title>
      <link href="/2021/03/21/gitlab-bu-shu-jiao-cheng/"/>
      <url>/2021/03/21/gitlab-bu-shu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="gitlab-部署"><a href="#gitlab-部署" class="headerlink" title="gitlab 部署"></a>gitlab 部署</h1><pre class="line-numbers language-none"><code class="language-none">apt-get updateapt-get install -y curl openssh-server ca-certificatesapt-get install -y postfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">https://packages.gitlab.com/gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo apt install gitlab-ee<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo vim /etc/gitlab/gitlab.rbexternal_url 'https://192.168.3.9' #修改gitlab页面访问的地址sudo gitlab-ctl reconfigure #重新加载配置文件 sudo gitlab-ctl restart #重启服务sudo gitlab-ctl status #查看状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改nginx端口"><a href="#修改nginx端口" class="headerlink" title="修改nginx端口"></a>修改nginx端口</h2><p>sudo vi /etc/gitlab/gitlab.rb</p><pre class="line-numbers language-none"><code class="language-none">nginx['listen_port'] = 8081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sudo vi /var/opt/gitlab/nginx/conf/gitlab-http.conf</p><pre class="line-numbers language-none"><code class="language-none">server {    listen *:8081;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="修改unicorn端口"><a href="#修改unicorn端口" class="headerlink" title="修改unicorn端口"></a>修改unicorn端口</h2><p>sudo vi /etc/gitlab/gitlab.rb</p><pre class="line-numbers language-none"><code class="language-none">unicorn['port'] = 8092<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="保存配置，重启"><a href="#保存配置，重启" class="headerlink" title="保存配置，重启"></a>保存配置，重启</h2><pre class="line-numbers language-none"><code class="language-none">sudo gitlab-ctl reconfiguresudo gitlab-ctl restartsudo gitlab-ctl status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><pre class="line-numbers language-none"><code class="language-none">sudo gitlab-ctl tail<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04 安装 MySQL 8.0 教程</title>
      <link href="/2021/03/20/ubuntu-18-04-an-zhuang-mysql-8-0-jiao-cheng/"/>
      <url>/2021/03/20/ubuntu-18-04-an-zhuang-mysql-8-0-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-18-04-安装-MySQL-8-0-教程"><a href="#Ubuntu-18-04-安装-MySQL-8-0-教程" class="headerlink" title="Ubuntu 18.04 安装 MySQL 8.0 教程"></a>Ubuntu 18.04 安装 MySQL 8.0 教程</h1><p>下载MySQL配置文件，网址：<a href="https://dev.mysql.com/downloads/repo/apt/">https://dev.mysql.com/downloads/repo/apt/</a></p><pre class="line-numbers language-none"><code class="language-none">wget https://dev.mysql.com/get/mysql-apt-config_0.8.16-1_all.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo dpkg -i  mysql-apt-config_0.8.16-1_all.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo apt install mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入Y同意继续安装:</p><p>设置root密码</p><p>阅读配置MySQ社区服务器，翻到末尾点使用Tab键选中按钮，击Enter键</p><p>加密方式选择Retain MySQL 5.x Compatibility</p><p>登录MySQL ：</p><pre class="line-numbers language-none"><code class="language-none">mysql –u root –p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并输入密码</p><pre class="line-numbers language-none"><code class="language-none">show variables like ‘%char%’;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改数据库配置 允许其他设备访问</p><p>登录mysql服务器，执行以下命令<br>选择mysql数据库:</p><pre class="line-numbers language-none"><code class="language-none">use mysql;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改host值:</p><pre class="line-numbers language-none"><code class="language-none">update user set host = '%' where user = 'root';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刷新:</p><pre class="line-numbers language-none"><code class="language-none">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出:</p><pre class="line-numbers language-none"><code class="language-none">exit;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动mysql数据库<br>1、使用 service 启动：</p><pre class="line-numbers language-none"><code class="language-none">service mysql start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启<br>1、使用 service 启动：</p><pre class="line-numbers language-none"><code class="language-none">service mysql restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自建ngrok服务支持https访问</title>
      <link href="/2020/05/10/zi-jian-ngrok-fu-wu-zhi-chi-https-fang-wen/"/>
      <url>/2020/05/10/zi-jian-ngrok-fu-wu-zhi-chi-https-fang-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近从事第三方平台代小程序实现业务开发，很多业务交互请求需要https，本地调试开发实现不了，不可能把部署到生产服务器调试，那又很不方便。我参考网上很多教程，很多不完整，不系统。我于是整理出完整教程当备用。</p><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p>内网穿透,又叫NAT穿透，是计算机用语，翻译过来就是 你的电脑可以直接被你朋友访问。 通常我们的电脑是无法自己被访问的。因为我们的电脑缺少自己的独立的ip地址。现在ip稀缺，电信运营商已经不会随便分配固定ip给个人。<br>通常实现内网穿透，是通过路由器上端口映射来实现的。但是路由器通常不是每个人都有权限可以访问和设置,而且可能存在多级路由器较为复杂的网络结构。端口映射也无法实现。这就需要ngrok来实现了。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ngrok 建立一个隧道,将主机A的http请求 传递给 主机B,从而实现内网穿透。<br>ngrok分为client端(ngrok)和服务端(ngrokd)，<br><img src="http://image.lichongbing.com/static/f03da5fde08081c901d42a9f92759517.png" alt="32778-0c1af0a3d5798ba6.png"><br>实际使用中的部署如下：<img src="http://image.lichongbing.com/static/d0664248923f20d84a8dd4efb3b0296a.png" alt="32778-428dc58babf925c8.png"><br>图中内网主机上安装客户端。<br>公网主机 安装服务端。<br>client public 则代表 访问你电脑的用户或者朋友。<br>现在都云时代，各种服务都能找到提供商。内网穿透也是如此。ngrok服务端相当麻烦,如果你只是简单的穿透，又不是什么敏感信息，可以找到很多 服务提供商。例如<a href="https://ngrok.com/">https://ngrok.com/</a></p><ul><li>下载客户端根据你的个人电脑系统下载匹配的客户端。下载地址: <a href="https://ngrok.com/download">https://ngrok.com/download</a></li><li>启动</li></ul><pre class="line-numbers language-none"><code class="language-none">./ngrok http 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ngrok by @inconshreveable                                                                                                                                                                                                     (Ctrl+C to quit)Session Status                onlineSession Expires               7 hours, 59 minutesVersion                       2.2.8Region                        United States (us)Web Interface                 http://127.0.0.1:4040Forwarding                    http://ada02116.ngrok.io -&gt; localhost:4444Forwarding                    https://ada02116.ngrok.io -&gt; localhost:4444Connections                   ttl     opn     rt1     rt5     p50     p90                              0       0       0.00    0.00    0.00    0.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时访问 <a href="http://ada02116.ngrok.io/">http://ada02116.ngrok.io</a> 则等于访问了 localhost:4444</p><h2 id="自建ngrok服务"><a href="#自建ngrok服务" class="headerlink" title="自建ngrok服务"></a>自建ngrok服务</h2><p>使用别人的服务，存在一些限制。例如不稳定、安全问题，费用昂贵等。因此可能需要自己搭建ngrok服务端。<br>自建服务需要具备的条件：</p><blockquote><p>1、具备独立ip的服务器。例如阿里云、腾讯云等。 我个人使用的阿里云ecs</p></blockquote><blockquote><p>2、需要域名。如果是国内则需要备案。我个人的域名是 xxxx.com</p></blockquote><ul><li><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3>增加2条A记录,指向你的服务器。这里我配置的是 ngrok.xxxx.com 和 *.ngrok.xxxx.com<br><img src="http://image.lichongbing.com/static/48f7409e04ecb9e643ec51b0cae524fb.png" alt="32778-2de852c725e147ef.png"></li><li><h3 id="添加安全组。"><a href="#添加安全组。" class="headerlink" title="添加安全组。"></a>添加安全组。</h3>开放3个端口。这里我选择4443、4444、8081端口。<br>其中4443是ngrok自身通信使用。<br>4444 后面tcp端口转发使用。<br>8081 则是http请求转发使用。默认是80 但是这里80端口我分配给nginx了。<br>截图中少截图了4444的配置。</li></ul><p><img src="http://image.lichongbing.com/static/de5962091a24f3d03ce23f4986343671.png" alt="32778-c5be55abf8d86869.png"></p><ul><li><h3 id="安装go（阿里云ESC服务器）"><a href="#安装go（阿里云ESC服务器）" class="headerlink" title="安装go（阿里云ESC服务器）"></a>安装go（阿里云ESC服务器）</h3>第一次照着其他教程直接apt-get install golang安装go语言环境，结果编译的时候报错，最终使用go 1.8版本顺利通过。</li><li> 下载go安装包并解包</li></ul> <pre class="line-numbers language-none"><code class="language-none"> wget https://storage.googleapis.com/golang/go1.8.linux-amd64.tar.gztar -zxvf go1.8.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul> <pre class="line-numbers language-none"><code class="language-none"> sudo vim /etc/profile# 添加以下内容export GOROOT=/usr/local/go # 注意此处为解压后文件夹的路径export GOPATH=$GOROOT/binexport PATH=$PATH:$GOPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使其生效</li></ul> <pre class="line-numbers language-none"><code class="language-none">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看go版本</li></ul> <pre class="line-numbers language-none"><code class="language-none">go version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><h3 id="安装ngrok（阿里云ESC服务器）"><a href="#安装ngrok（阿里云ESC服务器）" class="headerlink" title="安装ngrok（阿里云ESC服务器）"></a>安装ngrok（阿里云ESC服务器）</h3><ul><li>下载安装包并解压</li></ul><pre class="line-numbers language-none"><code class="language-none">wget htps://coding.net/u/sfantree/p/self_use_OSS/git/raw/master/source/ngrok.tar.gztar zxvf ngrok.tar.gzcd ngrok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>生成签名证书</li></ul><pre class="line-numbers language-none"><code class="language-none">export NGROK_DOMAIN="ngrok.xxx.com" # 此处为公网服务器域名(我是用的阿里云ESC服务器)openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ngrok目录下会生成6个新的文件<br>device.crt device.csr device.key<br>rootCA.key rootCA.pem rootCA.srl</p></li><li><p>替换证书</p><pre class="line-numbers language-none"><code class="language-none">cp rootCA.pem assets/client/tls/ngrokroot.crtcp device.crt assets/server/tls/snakeoil.crtcp device.key assets/server/tls/snakeoil.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>编译服务端与客户端口</p><pre class="line-numbers language-none"><code class="language-none">  make release-serverGOOS=linux GOARCH=386 make release-clientGOOS=linux GOARCH=amd64 make release-clientGOOS=windows GOARCH=386 make release-clientGOOS=windows GOARCH=amd64 make release-clientGOOS=darwin GOARCH=386 make release-clientGOOS=darwin GOARCH=amd64 make release-clientGOOS=linux GOARCH=arm make release-client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译成功后会在bin目录下找到ngrokd和ngrok这两个文件。其中ngrokd 是服务端程序ngrok是客户端程序。</p></li><li><p>运行服务端</p><pre class="line-numbers language-none"><code class="language-none">./ngrokd -domain="ngrok.xxx.com"  -httpAddr=":80" -httpsAddr=":443" -tunnelAddr=":4443" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将ngrok拷贝到客户端上我的是mac，下载对应darwin_amd64</p><pre class="line-numbers language-none"><code class="language-none">scp -P 22 -r  root@你的的ngrok服务器ip地址:/usr/local/ngrok/bin/darwin_amd64/ngrok  ./ngrok<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>并在同级文件夹下新建config.yml文件，其中内容如下：</p><pre class="line-numbers language-none"><code class="language-none">  server_addr: "ngrok.xxxx.com:4443"trust_host_root_certs: falsetunnels:  webapp:   proto:     http: 8000     https: 8000   subdomain: www  tcp12345:    remote_port: 4444    proto:      tcp: 12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动客户端</p><pre class="line-numbers language-none"><code class="language-none">./ngrok  -config=config.yml start-all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>穿透成功</p><pre class="line-numbers language-none"><code class="language-none">  ngrok                                                                                       Tunnel Status                 online                                                                                     Version                       1.7/1.7                                                                                    Forwarding                    https://www.open.yuelingnet.cn -&gt; 127.0.0.1:8000                                           Forwarding                    http://www.open.yuelingnet.cn -&gt; 127.0.0.1:8000                                            Web Interface                 127.0.0.1:4040                                                                             # Conn                        6                                                                                          Avg Conn Time                 6026.71ms                                                       HTTP Requests                                                       -------------                                                                                                                                                                                                                              GET /                         200 OK                                  GET /static/fonts/element-ico 304 Not Modified                        GET /static/img/login_center_ 304 Not Modified                        GET /155.js                   304 Not Modified                        GET /static/tinymce4.7.5/tiny 304 Not Modified                        GET /app.js                   200 OK                                  GET /                         304 Not Modified                        GET /favicon.ico              200 OK                                  GET /static/fonts/element-ico 200 OK  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务端和客户端</p></li><li><h3 id="网站配置SSL证书（https）-使网站可以通过https访问"><a href="#网站配置SSL证书（https）-使网站可以通过https访问" class="headerlink" title="网站配置SSL证书（https）,使网站可以通过https访问"></a>网站配置SSL证书（https）,使网站可以通过https访问</h3><p>我们申请的是Let’s Encrypt通配符SSL证书，因为他是免费的</p></li><li><p>1.获取 Certbot 客户端<br> 下载 Certbot 客户端 ,并且添加可执行权限</p> <pre class="line-numbers language-none"><code class="language-none">cd /usr/local/wget https://dl.eff.org/certbot-autochmod a+x certbot-auto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>2.申请通配符证书</p></li></ul><p>客户在申请Let’s Encrypt证书的时候，需要校验域名的所有权，证明操作者有权利为该域名申请证书，目前支持三种验证方式：dns-01：给域名添加一个 DNS TXT 记录。<br>http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。<br>tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件<br>使用Certbot客户端申请证书方法非常的简单，只需如下一行命令就搞定了。</p><ul><li>特别注意：</li></ul><p>申请通配符证书，只能使用 dns-01 的方式。<br>xxx.com 请根据自己的域名自行更改。如果要.xxx.com xxx.com都可以使用需要配置 -d “.xxx.com” -d “xxx.com”。</p>   <pre class="line-numbers language-none"><code class="language-none">./certbot-auto certonly  -d "*.ngrok.xxx.com" -d "ngrok.xxx.com" --manual --preferred-challenges dns-01  --server https://acme-v02.api.letsencrypt.org/directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>执行完这一步之后，就是命令行的输出，请根据提示输入相应内容：<br><img src="http://image.lichongbing.com/static/ce2be365e6b1928d1f0e600738017e87.png" alt="1534495467849643.png"></p></li><li><p>执行到上图最后一步时，先暂时不要回车。申请通配符证书是要经过DNS认证的，接下来需要按照提示在域名后台添加对应的DNS TXT记录。</p></li><li><p>确认生效后，回车继续执行，最后会输出如下内容：<br><img src="http://image.lichongbing.com/static/c2bfd6466e30fdb7752e0608da2dd0b8.png" alt="1534495645970573.png"><br>出现这个就代表成功了</p></li><li><p>3.更换证书，重新编译ngrok客户端和服务端</p><pre class="line-numbers language-none"><code class="language-none">  cd /home/ngrok/cp /etc/letsencrypt/live/open.yuelingnet.cn/privkey.pem /home/ngrok/assets/server/tls/snakeoil.keycp /etc/letsencrypt/live/open.yuelingnet.cn/fullchain.pem /home/ngrok/assets/server/tls/snakeoil.crtcp /etc/letsencrypt/live/open.yuelingnet.cn/fullchain.pem /home/ngrok/assets/client/tls/ngrokroot.crtmake release-serverGOOS=linux GOARCH=386 make release-clientGOOS=linux GOARCH=amd64 make release-clientGOOS=windows GOARCH=386 make release-clientGOOS=windows GOARCH=amd64 make release-clientGOOS=darwin GOARCH=386 make release-clientGOOS=darwin GOARCH=amd64 make release-clientGOOS=linux GOARCH=arm make release-client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>4.将ngrok重新拷贝到客户端上我的是mac，下载对应darwin_amd64</p><pre class="line-numbers language-none"><code class="language-none">scp -P 22 -r  root@你的的ngrok服务器ip地址:/usr/local/ngrok/bin/darwin_amd64/ngrok  ./ngrok<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>5.再次运行服务端</p><pre class="line-numbers language-none"><code class="language-none">./ngrokd -tlsKey="/home/ngrok//assets/server/tls/snakeoil.key" -tlsCrt="/home/ngrok/assets/server/tls/snakeoil.crt" -domain="open.yuelingnet.cn" -httpAddr=":80" -httpsAddr=":443" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 6.启动客户端</p></li></ul>  <pre class="line-numbers language-none"><code class="language-none">./ngrok  -config=config.yml start-all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后测试可以通过https访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信电商小程序直播带货开发</title>
      <link href="/2020/04/23/wei-xin-dian-shang-xiao-cheng-xu-zhi-bo-dai-huo-kai-fa/"/>
      <url>/2020/04/23/wei-xin-dian-shang-xiao-cheng-xu-zhi-bo-dai-huo-kai-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于众所周知的原因，全国人民经历了史上最长春节假期，实体经济遭遇重创，却反而成就了“宅经济”的发展。</p></blockquote><p><img src="http://image.lichongbing.com/static/009bc75ef1c3d0f5d66cdcc86d797fda.jpeg" alt="timg-4.jpeg"><br>在这样的背景下，微信不久前开放小程序直播能力，一时间引爆行业讨论，那么直播+小程序是如何赋能线下商家的，小程序直播又是如何开通的？</p><h2 id="为什么你需要小程序直播？"><a href="#为什么你需要小程序直播？" class="headerlink" title="为什么你需要小程序直播？"></a>为什么你需要小程序直播？</h2><ul><li>直播带货大势所趋</li></ul><p>在李佳琦与薇娅的成功背后，是视频电商的崛起，凭借更直观的信息传达效率，通过主播实时互动，打破了传统电商冰冷的消费体验痛点，使得一场成功的直播交易量就可能远超实体门店数月的业绩。</p><p>而放眼整个行业，内容平台做电商，电商平台做直播早已不是什么新鲜事，而微信作为社交平台，以小程序切入直播领域，表明布局直播带货已经成为互联网行业共识。</p><ul><li>11亿社交流量红利</li></ul><p>随着线上用户增长遭遇天花板，商家获客成本高企，而微信坐拥11亿活跃用户，有着令其他平台艳羡的庞大用户规模，几乎涵盖所有消费人群，其中还包含大量下沉及新增用户群体。</p><p>而基于小程序强大的营销能力（抽奖、领券、秒杀等），配合自带的社交入口，商家可轻松打造出裂变营销为直播间引流，最终通过带货完成转化。</p><ul><li>打造私域流量闭环</li></ul><p>对于商家来说，一方面，小程序可直接添加商品至直播间，且交易无抽成；另一方面，借助社群、订阅号、朋友圈等基础设施，微信生态也更利于商家搭建并沉淀自己的私域流量。</p><h2 id="如何开通小程序直播？"><a href="#如何开通小程序直播？" class="headerlink" title="如何开通小程序直播？"></a>如何开通小程序直播？</h2><ul><li>申请条件</li></ul><p>首先要说明的是小程序直播是以插件的形式存在的，就是说开通小程序直播的前提是有自己的小程序（且符合开放类目），在此基础上，小程序还需满足近半年无违规、连续7日日活用户＞100人、近90天有支付行为等条件。</p><ul><li>开通步骤</li></ul><p>在小程序代码中接入直播插件后，通过审核即可添加商品，商品经过审核入库后即可被添加至直播间，同时允许50个直播间同时直播带货。而对于没有开发能力的商家，就需要找到第三方服务商以搭建小程序直播方案。<br>随着线下商家意识到打造智慧零售体系的必要性，再加上微信的全力推动，有理由相信直播电商的全面爆发只是时间问题，而从抢占流量风口的角度看，越早入局无疑越有利于瓜分红利。<br>小程序开发联系电话17778479306</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信扫码支付时序图</title>
      <link href="/2020/04/06/wei-xin-sao-ma-zhi-fu-shi-xu-tu/"/>
      <url>/2020/04/06/wei-xin-sao-ma-zhi-fu-shi-xu-tu/</url>
      
        <content type="html"><![CDATA[<p><img src="http://image.lichongbing.com/static/ef09cb1b73927e039ad8feaec4a2e2cf.jpg" alt="用户注册时序图.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电商秒杀系统设计</title>
      <link href="/2020/04/06/dian-shang-miao-sha-xi-tong-she-ji/"/>
      <url>/2020/04/06/dian-shang-miao-sha-xi-tong-she-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="http://image.lichongbing.com/static/8f4c1b44ff771f9ce7d0f2e87e915f36.png" alt="mermaid-diagram-20200406101405.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>采用jekyll +gitee+jenkins构建求职简历</title>
      <link href="/2020/03/25/cai-yong-jekyll-gitee-jenkins-gou-jian-qiu-zhi-jian-li/"/>
      <url>/2020/03/25/cai-yong-jekyll-gitee-jenkins-gou-jian-qiu-zhi-jian-li/</url>
      
        <content type="html"><![CDATA[<h1 id="采用jekyll-gitee-jenkins-jekyll-minimal-resume构建求职简历"><a href="#采用jekyll-gitee-jenkins-jekyll-minimal-resume构建求职简历" class="headerlink" title="采用jekyll +gitee+jenkins+jekyll-minimal-resume构建求职简历"></a>采用jekyll +gitee+jenkins+jekyll-minimal-resume构建求职简历</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>疫情快要结束了，在家沉炼技术一段时间，为了找好工作，简历花时间精心设计制作一番。本次采用jekyll +gitee+jenkins+jekyll-minimal-resume构建自己的求职简历。</p></blockquote><h2 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h2><ul><li>本地提交博客 Markdown 文件 到 gitee 源文件 repository</li><li>gitee 触发 jenkins 执行自动编译</li><li>jenkins 编译后 push 静态文件到 gitee 静态文件 repository</li><li>由于resume与jenkins处于同一台服务器，采用nginx搭建。</li></ul><h2 id="本地和部署服务器均安装jekyll-命令工具"><a href="#本地和部署服务器均安装jekyll-命令工具" class="headerlink" title="本地和部署服务器均安装jekyll 命令工具"></a>本地和部署服务器均安装jekyll 命令工具</h2><blockquote><p>jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。<br>本地我用Mac，安装比较简单</p></blockquote><h3 id="服务器是Ubuntu安装比较繁琐"><a href="#服务器是Ubuntu安装比较繁琐" class="headerlink" title="服务器是Ubuntu安装比较繁琐"></a>服务器是Ubuntu安装比较繁琐</h3><p>我们将首先将所有系统软件包更新到最新版本，然后继续安装Jekyll：</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get update$ sudo apt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Jekyll需要一个包含库的Ruby开发环境，使用以下命令安装Jekyll和必需的构建工具：</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install make build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装Ruby包和开发工具：</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install ruby ruby-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考：在Ubuntu 18.04 LTS系统上安装Ruby的方法。<br>我们现在需要指示Ruby的gem包管理器将gem放在登录用户的主目录中，在<del>/.bashrc或</del>/.zshrc下添加以下行，具体取决于你的shell：</p><pre class="line-numbers language-none"><code class="language-none">export GEM_HOME=$HOME/gemsexport PATH=$HOME/gems/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在来源.bashrc|.zshrc文件以使更改生效：</p><pre class="line-numbers language-none"><code class="language-none">$ source ~/.bashrc$ source ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成此操作后，将使用gem安装Jekyll和Bundler，这是一个用于管理Gem依赖项的工具：</p><pre class="line-numbers language-none"><code class="language-none">$ gem install bundler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装Jekyll：</p><pre class="line-numbers language-none"><code class="language-none">$ gem install jekyll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="服务器安装自动化部署工具jenkins"><a href="#服务器安装自动化部署工具jenkins" class="headerlink" title="服务器安装自动化部署工具jenkins"></a>服务器安装自动化部署工具jenkins</h2><blockquote><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p></blockquote><h3 id="ubuntu-安装-Jenkins"><a href="#ubuntu-安装-Jenkins" class="headerlink" title="ubuntu 安装 Jenkins"></a>ubuntu 安装 Jenkins</h3><blockquote><p>安装前提是安装java和maven</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'sudo apt-get updatesudo apt-get install jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="linux中Jenkins启动-重启-停止命令"><a href="#linux中Jenkins启动-重启-停止命令" class="headerlink" title="linux中Jenkins启动/重启/停止命令"></a>linux中Jenkins启动/重启/停止命令</h3><p>启动</p><pre class="line-numbers language-none"><code class="language-none">service jenkins start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启</p><pre class="line-numbers language-none"><code class="language-none">service jenkins restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止</p><pre class="line-numbers language-none"><code class="language-none">service jenkins stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="解决服务器内存不足问题"><a href="#解决服务器内存不足问题" class="headerlink" title="解决服务器内存不足问题"></a>解决服务器内存不足问题</h3><p>创建swap文件<br>首先，选择你swap文件要放置的位置，比如直接在根目录/ 下创建或者选择一个目录，如/opt。比如我直接在根目录下创建，然后设置swap分区的名称为swapfile:</p><p>定义swap的大小及位置</p><pre class="line-numbers language-none"><code class="language-none"># dd if=/dev/zero of=/swapfile bs=1k count=2048000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面swapfile为你创建swap文件分区的名称，你可以根据需要改成你自己的名称;bs 即blocksizes，每个块大小为1k;count=2048000,总大小为2G的文件。因为建立swap分区大小的标准一般为物理内存的两倍，而我的内存是1G，所以我选择swap文件大小为2G，当然，也要考虑你硬盘剩余容量的大小。我的硬盘还剩15G，所以再划分2G给swap文件绰绰有余。如果你的内存是0.5G，那么count大小可以选择1024000(1G)。</p><p>建立swap</p><pre class="line-numbers language-none"><code class="language-none"># mkswap /swapfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动swap</p><pre class="line-numbers language-none"><code class="language-none"># swapon /swapfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查是否正确</p><pre class="line-numbers language-none"><code class="language-none"># free -m total        used        free      shared  buff/cache   available Mem:           1838         600          65           2        1172        1043 Swap:          1999           0        1999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者使用swapon -s 命令查看:</p><pre class="line-numbers language-none"><code class="language-none"># swapon -s <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置Nginx及Https服务"><a href="#配置Nginx及Https服务" class="headerlink" title="配置Nginx及Https服务"></a>配置Nginx及Https服务</h3><p>安装nginx</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置https服务</p><p>安装上传证书</p><pre class="line-numbers language-none"><code class="language-none">/home/resume.lichongbing.com/3641955_resume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建resume.lichongbing.com.conf</p><pre class="line-numbers language-none"><code class="language-none">server {    listen    80;    server_name resume.lichongbing.com;    rewrite ^(.*)$  https://$host$1 permanent;}server {                listen 443 ssl;                server_name resume.lichongbing.com;                ssl_certificate "/home/resume.lichongbing.com/3641955_resume/3641955_resume.lichongbing.com.pem";                ssl_certificate_key "/home/resume.lichongbing.com/3641955_resume/3641955_resume.lichongbing.com.key";                index index.html index.html;                root  /www/gfr_doc/_book;                access_log  /var/log/resume.lichongbing.com.log;                                                    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动https</p><pre class="line-numbers language-none"><code class="language-none">service nginx restart````### 简历安装测试#### 功能和特点* 简单、优雅、极简的设计* 桌面和移动友好，但桌面上的效果会更好* 支持输出 PDF 并且打印机友好* 简单的扩展方式#### 安装和使用#### 本地模式1. 克隆（可以先 fork）    ```shell    git clone https://github.com/lichongbing/resume.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>安装 Jekyll</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gem <span class="token function">install</span> jekyll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置简历数据</p><p>首先在 <code>_config.yml</code> 中配置 <code>baseurl</code>，如果需要部署在网站的话。在 <code>_data/resume.yml</code> 中填写教育（education）、技能（skills）、工作经验（experience）和项目（projects）。</p></li><li><p>运行和预览</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jekyll serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>构建</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jekyll build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="Gem-模式"><a href="#Gem-模式" class="headerlink" title="Gem 模式"></a>Gem 模式</h4><ol><li>创建 <code>Gemfile</code></li></ol>  <pre class="line-numbers language-none"><code class="language-none">source "https://rubygems.org"gem "jekyll-theme-minimal-resume"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并执行，</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bundle <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p>初始化 <code>_config.yml</code></p> <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> Résumé Title<span class="token key atrule">baseurl</span><span class="token punctuation">:</span> <span class="token string">"/resume/"</span><span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">"jekyll-theme-minimal-resume"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建 <code>index.html</code></p> <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> resume<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建 <code>_data/resume.yml</code> 并填写你的简历数据。[</p></li></ol><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="联系信息"><a href="#联系信息" class="headerlink" title="联系信息"></a>联系信息</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">contact</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> fa<span class="token punctuation">-</span>envelope    <span class="token key atrule">text</span><span class="token punctuation">:</span> youremail@example.com  <span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> fa<span class="token punctuation">-</span>phone<span class="token punctuation">-</span>square    <span class="token key atrule">text</span><span class="token punctuation">:</span> your<span class="token punctuation">-</span>phone<span class="token punctuation">-</span>num  <span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> fa<span class="token punctuation">-</span>globe    <span class="token key atrule">text</span><span class="token punctuation">:</span> your<span class="token punctuation">-</span>website.com    <span class="token key atrule">link</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//lichongbing.github.io/resume/resume.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板内置了 FontAwesome 图标字体，请使用<code>fa-</code>开头的类名作为图标。<code>link</code>是可选项，如果需要在 Web 或 PDF 版中支持链接，请填写此项。</p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>模板内置了一些主题配色，可以通过 <code>_config.yml</code> 中的 <code>color</code> 进行修改。默认是灰色 Gray。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">color</span><span class="token punctuation">:</span> gray<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>red</li><li>pink</li><li>grape</li><li>violet</li><li>indigo</li><li>blue</li><li>cyan</li><li>teal</li><li>green</li><li>lime</li><li>yellow</li><li>orange</li></ul><ul><li>nord</li></ul><h4 id="扩展简历内容"><a href="#扩展简历内容" class="headerlink" title="扩展简历内容"></a>扩展简历内容</h4><ol><li>在 <code>_data/resume.yml</code> 中增加段落，比如增加显示你的语言水平：</li></ol>  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">languages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 英语    <span class="token key atrule">proficiency</span><span class="token punctuation">:</span> 工作熟练  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 中文    <span class="token key atrule">proficiency</span><span class="token punctuation">:</span> 母语<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>把读取代码加入 <code>_layouts/resume.html</code>:</li></ol>  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>languages<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>section-title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    Language  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>section-content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    {% for lang in site.data.resume.languages %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>block<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>block-title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        {{ lang.name }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>block-content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        {{ lang.proficiency }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    {% endfor %}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简历web更新方法"><a href="#简历web更新方法" class="headerlink" title="简历web更新方法"></a>简历web更新方法</h2><h3 id="web-输出语言格式"><a href="#web-输出语言格式" class="headerlink" title="web 输出语言格式"></a>web 输出语言格式</h3><p>在文件根目录修改index.html<br>中文版渲染</p><pre class="line-numbers language-none"><code class="language-none">--- layout: resume_zh_cn ---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>英文版渲染</p><pre class="line-numbers language-none"><code class="language-none">--- layout: resume---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据修改<br>在_data文件夹_</p><pre class="line-numbers language-none"><code class="language-none">├── resume.yml # 英文简历└── resume_zhcn.yml # 中文简历<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">bundle exec jekyll build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-none"><code class="language-none">cp -r _site/ site <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交部署</p><pre class="line-numbers language-none"><code class="language-none">git add .git commitgit push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>经过以上步骤完成自动化部署简历。<br>以下是我的简历<br><a href="https://resume.lichongbing.com/">https://resume.lichongbing.com</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何写出优雅的开源项目文档( 转）</title>
      <link href="/2020/01/04/ru-he-xie-chu-you-ya-de-kai-yuan-xiang-mu-wen-dang-zhuan/"/>
      <url>/2020/01/04/ru-he-xie-chu-you-ya-de-kai-yuan-xiang-mu-wen-dang-zhuan/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><a href="https://github.com/macrozheng/mall">mall项目</a>是我去年写的SpringBoot实战电商项目，现在在Github上面已经有18k+star。去年12月份的时候，mall项目只有一些必要的说明文档和部署文档。mall项目涉及到的技术栈比较广泛，业务也比较复杂，却没有系统的学习教程。今年5月份的时候，我开始完善整套学习教程，目前已经更新了三十余篇。最近使用docsify搭建了一个小型的文档网站，希望大家能有更好的阅读体验。本文将介绍如何使用docsify来写开源项目文档。</p><h2 id="项目文档演示"><a href="#项目文档演示" class="headerlink" title="项目文档演示"></a>项目文档演示</h2><p><img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3dc26495db1db?imageslim" alt="展示图片"></p><h2 id="使用docsify来写项目文档"><a href="#使用docsify来写项目文档" class="headerlink" title="使用docsify来写项目文档"></a>使用docsify来写项目文档</h2><h3 id="docsify简介"><a href="#docsify简介" class="headerlink" title="docsify简介"></a>docsify简介</h3><p>docsify是一个动态生成网站的工具，它不会将.md文件转化为.html文件从而污染你的Github提交记录，所有转化都将在运行时完成。如果你需要快速搭建一个小型文档网站，这将非常实用。</p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><ul><li>  下载地址：<a href="https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi">nodejs.org/dist/v8.9.4…</a></li><li>  下载完成后直接安装即可。</li></ul><h4 id="安装docsify-cli工具"><a href="#安装docsify-cli工具" class="headerlink" title="安装docsify-cli工具"></a>安装docsify-cli工具</h4><ul><li><p>  在命令行中执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">npm i docsify-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>  安装完成后可以方便地在本地实时预览所编辑的文档。</p></li></ul><h4 id="初始化项目结构"><a href="#初始化项目结构" class="headerlink" title="初始化项目结构"></a>初始化项目结构</h4><ul><li><p>  新建一个docs文件夹，然后执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">docsify init ./docs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>  docsify会创建如下结构的目录：</p><pre class="line-numbers language-none"><code class="language-none">-| docs/  -| .nojekyll  -| index.html  -| README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h4><ul><li><p>  在命令行中输入如下命令：</p><pre class="line-numbers language-none"><code class="language-none">docsify serve docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>  访问该地址即可查看效果：<a href="http://localhost:3000/">http://localhost:3000/</a></p></li></ul><h3 id="定制侧边栏"><a href="#定制侧边栏" class="headerlink" title="定制侧边栏"></a>定制侧边栏</h3><ul><li>  在index.html中添加侧边栏的配置：</li></ul> <pre class="line-numbers language-none"><code class="language-none">window.$docsify = {  loadSidebar: true,  maxLevel: 2,  subMaxLevel: 4,  alias: {    '/.*/_sidebar.md': '/_sidebar.md'//防止意外回退  }}      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  添加_sidebar.md文件来配置侧边栏：</li></ul><pre class="line-numbers language-none"><code class="language-none">* 序章  * [mall架构及功能概览](foreword/mall_foreword_01.md)  * [mall学习所需知识点](foreword/mall_foreword_02.md)* 架构篇  * [mall整合SpringBoot+MyBatis搭建基本骨架](architect/mall_arch_01.md)  * [mall整合Swagger-UI实现在线API文档](architect/mall_arch_02.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  这样就可以生成一个二级的侧边栏：</li></ul><pre class="line-numbers language-none"><code class="language-none">![16c3dc264a5c081f.png](http://image.lichongbing.com/static/4e73119f54d10f39b1d484ebb30e9247.png)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="定制导航栏"><a href="#定制导航栏" class="headerlink" title="定制导航栏"></a>定制导航栏</h3><ul><li>  在index.html中添加导航栏的配置：</li></ul><pre class="line-numbers language-none"><code class="language-none">window.$docsify = {  loadNavbar: true,  alias: {    '/.*/_navbar.md': '/_navbar.md'//防止意外回退  }}      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  添加_navbar.md文件来配置导航栏：</li></ul><pre class="line-numbers language-none"><code class="language-none">* 演示  * [后台管理](http://39.98.190.128/index.html)  * [移动端](http://39.98.190.128/mall-app/mainpage.html)* 项目地址  * [后台项目](https://github.com/macrozheng/mall)  * [前端项目](https://github.com/macrozheng/mall-admin-web)  * [学习教程](https://github.com/macrozheng/mall-learning)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  这样就可以在右上角生成两个导航栏：</li></ul><p><img src="http://image.lichongbing.com/static/657f9bb9a3125cc78bf7505e59badcbe.png" alt="16c3dc264b8eda9c.png"></p><h3 id="定制封面页"><a href="#定制封面页" class="headerlink" title="定制封面页"></a>定制封面页</h3><ul><li>  在index.html中添加封面页的配置：</li></ul><pre class="line-numbers language-none"><code class="language-none">      window.$docsify = {  coverpage: true}      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  添加_coverpage.md文件来配置封面页：</li></ul><pre class="line-numbers language-none"><code class="language-none">![logo](images/mall.svg)# mall-learning&gt; mall学习教程，架构、业务、技术要点全方位解析。    此处填写详细简介。[GitHub](https://github.com/macrozheng/mall-learning)[Get Started](README.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  查看封面页效果：</li></ul><p><img src="http://image.lichongbing.com/static/e2693dbced9b2cf40d29a07059e98129.png" alt="16c3dc264f587585.png"></p><h3 id="添加全文搜索"><a href="#添加全文搜索" class="headerlink" title="添加全文搜索"></a>添加全文搜索</h3><ul><li>  在index.html中添加全文搜索的配置：</li></ul><pre class="line-numbers language-none"><code class="language-none">      window.$docsify = {  search: {    placeholder: '搜索',    noData: '找不到结果!',    depth: 3  },}            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  查看全文搜索效果：</li></ul><p><img src="http://image.lichongbing.com/static/c75bfa0eff72125b995cf3f5978d0374.png" alt="16c3dc264ff9d4c2.png"></p><h3 id="添加代码高亮"><a href="#添加代码高亮" class="headerlink" title="添加代码高亮"></a>添加代码高亮</h3><ul><li>  在index.html中添加代码高亮的配置：</li></ul><pre><code>复制代码</code></pre><ul><li>  其他支持高亮语言请参考：<a href="https://github.com/PrismJS/prism/tree/gh-pages/components">github.com/PrismJS/pri…</a></li><li>  查看代码高亮效果：</li></ul><p><img src="http://image.lichongbing.com/static/bf101f1447bdd37cec77420b18c460c9.png" alt="16c3dc264f95e6b1.png"></p><h3 id="添加一键拷贝代码"><a href="#添加一键拷贝代码" class="headerlink" title="添加一键拷贝代码"></a>添加一键拷贝代码</h3><ul><li><p>  在index.html中添加一键拷贝代码的配置：</p><pre class="line-numbers language-none"><code class="language-none">      <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>  查看一键拷贝代码效果：</p></li></ul><p><img src="http://image.lichongbing.com/static/f4e22bae7a0d7921bb70c08469c2c226.png" alt="16c3dc267b39172d.png"></p><h3 id="在Github上部署文档"><a href="#在Github上部署文档" class="headerlink" title="在Github上部署文档"></a>在Github上部署文档</h3><ul><li>  首先将你的代码提交到Github上去；</li><li>  然后点击项目的Settings按钮：</li></ul><p><img src="http://image.lichongbing.com/static/018a7151952a650911cb03bdf3eaf235.png" alt="16c3dc26a8ae17a7.png"></p><ul><li>  开启GitHub Pages服务：</li></ul><p><img src="http://image.lichongbing.com/static/feaaf27d9a7bb2e792be3ad73d4cb9fa.png" alt="16c3dc2683d928a3.png"></p><h2 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h2><p><a href="https://macrozheng.github.io/mall-learning/">macrozheng.github.io/mall-learni…</a></p><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/macrozheng/mall-learning">github.com/macrozheng/…</a></p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p><a href="https://github.com/macrozheng/mall">mall项目</a>全套学习教程连载中，<strong>关注公众号</strong>第一时间获取。</p><p>![公众号图片](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="258" height="258"></svg>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2.X整合 Swagger2并输出离线文档支持html,adoc,markdown,text格式</title>
      <link href="/2020/01/02/springboot2-x-zheng-he-swagger2-bing-shu-chu-chi-xian-wen-dang-zhi-chi-html-adoc-markdown-text-ge-shi/"/>
      <url>/2020/01/02/springboot2-x-zheng-he-swagger2-bing-shu-chu-chi-xian-wen-dang-zhi-chi-html-adoc-markdown-text-ge-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot2-X整合-Swagger2并输出离线文档支持html-adoc-markdown-text格式"><a href="#SpringBoot2-X整合-Swagger2并输出离线文档支持html-adoc-markdown-text格式" class="headerlink" title="SpringBoot2.X整合 Swagger2并输出离线文档支持html,adoc,markdown,text格式"></a>SpringBoot2.X整合 Swagger2并输出离线文档支持html,adoc,markdown,text格式</h1><h3 id="什么是-Swagger"><a href="#什么是-Swagger" class="headerlink" title="什么是 Swagger"></a>什么是 Swagger</h3><p>Swagger 是一系列 RESTful API 的工具，通过 Swagger 可以获得项目的一种交互式文档，客户端 SDK 的自动生成等功能。</p><p>Swagger 的目标是为 REST APIs 定义一个标准的、与语言无关的接口，使人和计算机在看不到源码或者看不到文档或者不能通过网络流量检测的情况下，能发现和理解各种服务的功能。当服务通过 Swagger 定义，消费者就能与远程的服务互动通过少量的实现逻辑。类似于低级编程接口，Swagger 去掉了调用服务时的很多猜测。</p><p>Swagger（丝袜哥）是世界上最流行的 API 表达工具。</p><p>Swagger 是一个简单但功能强大的 API 表达工具。它具有地球上最大的 API 工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，都在支持和使用 Swagger。使用 Swagger 生成 API，我们可以得到交互式文档，自动生成代码的 SDK 以及 API 的发现特性等。</p><p>使用 Spring Boot 集成 Swagger 的理念是，使用注解来标记出需要在 API 文档中展示的信息，Swagger 会根据项目中标记的注解来生成对应的 API 文档。Swagger 被号称世界上最流行的 API 工具，它提供了 API 管理的全套解决方案，API 文档管理需要考虑的因素基本都包含，这里将讲解最常用的定制内容。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>Spring Boot 集成 Swagger 2.X 很简单，需要引入依赖并做基础配置即可，下面我们来感受一下。</p><h4 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h4><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="创建-SwaggerConfig-配置类"><a href="#创建-SwaggerConfig-配置类" class="headerlink" title="创建 SwaggerConfig 配置类"></a>创建 SwaggerConfig 配置类</h4><pre><code>@Configuration@EnableSwagger2public class SwaggerConfig {}</code></pre><p>在 SwaggerConfig 的类上添加两个注解：</p><ul><li>  @Configuration，启动时加载此类</li><li>  @EnableSwagger2，表示此项目启用 Swagger API 文档</li></ul><p>在 SwaggerConfig 中添加两个方法：</p><pre><code>@Beanpublic Docket api() {    return new Docket(DocumentationType.SWAGGER_2)            .apiInfo(apiInfo())            .select()            // 自行修改为自己的包路径            .apis(RequestHandlerSelectors.basePackage("com.neo.xxx"))            .paths(PathSelectors.any())            .build();}</code></pre><p>此方法使用 @Bean，在启动时初始化，返回实例 Docket（Swagger API 摘要），这里需要注意的是 .apis(RequestHandlerSelectors.basePackage(“com.neo.xxx”)) 指定需要扫描的包路径，只有此路径下的 Controller 类才会自动生成 Swagger API 文档。</p><pre><code>private ApiInfo apiInfo() {    return new ApiInfoBuilder()            .title("客户管理")            .description("客户管理中心 API 1.0 操作文档")            //服务条款网址            .termsOfServiceUrl("http://www.ityouknow.com/")            .version("1.0")            .contact(new Contact("纯洁的微笑", "http://www.ityouknow.com/", "ityouknow@126.com"))            .build();}</code></pre><p>这块配置相对重要一些，主要配置页面展示的基本信息包括，标题、描述、版本、服务条款、联系方式等，查看 ApiInfo 类的源码还会发现支持 license 配置等。</p><pre><code>public class ApiInfo {    public static final Contact DEFAULT_CONTACT = new Contact("", "", "");    public static final ApiInfo DEFAULT;    private final String version;    private final String title;    private final String description;    private final String termsOfServiceUrl;    private final String license;    private final String licenseUrl;    private final Contact contact;    private final List&lt;VendorExtension&gt; vendorExtensions;    //...}</code></pre><p>以上信息皆可在此方法进行配置，也可以使用默认值。配置完成之后启动项目，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/swagger-ui.html，即可看到上面的配置信息，效果如下：</a></p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger1.png"></p><p>访问地址后，发现页面存在这样一句话：No operations defined in spec!，意思是没有找到相关的 API 内容，这是因为还没有添加对应的 Controller 信息，接下来结合代码一一介绍各个注解的使用。</p><h3 id="Swagger-常用注解"><a href="#Swagger-常用注解" class="headerlink" title="Swagger 常用注解"></a>Swagger 常用注解</h3><p>Swagger 通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息等，常用注解内容如下：</p><table><thead><tr><th>作用范围</th><th>API</th><th>使用位置</th></tr></thead><tbody><tr><td>协议集描述</td><td>@Api</td><td>用于 Controller 类上</td></tr><tr><td>协议描述</td><td>@ApiOperation</td><td>用在 Controller 的方法上</td></tr><tr><td>非对象参数集</td><td>@ApiImplicitParams</td><td>用在 @ApiImplicitParams 的方法里边</td></tr><tr><td>响应集</td><td>@ApiResponses</td><td>用在 Controller 的方法上</td></tr><tr><td>响应信息参数</td><td>@ApiResponse</td><td>用在 @ApiResponses 里边</td></tr><tr><td>描述返回对象的意义</td><td>@ApiModel</td><td>用在返回对象类上</td></tr><tr><td>对象属性</td><td>@ApiModelProperty</td><td>用在出入参数对象的字段上</td></tr></tbody></table><p>在第 2-8 课讲解的示例项目基础上，添加 RESTful API 文档示例。</p><h4 id="Api-的使用"><a href="#Api-的使用" class="headerlink" title="@Api 的使用"></a>@Api 的使用</h4><p>Api 作用在 Controller 类上，做为 Swagger 文档资源，该注解将一个 Controller（Class）标注为一个 Swagger 资源（API）。在默认情况下，Swagger-Core 只会扫描解析具有 @Api 注解的类，而会自动忽略其他类别资源（JAX-RS endpoints、Servlets 等）的注解。</p><p>使用示例：</p><pre><code>@Api(value = "消息", description = "消息操作 API", position = 100, protocols = "http")@RestController@RequestMapping("/")public class MessageController {}</code></pre><p>与 Controller 注解并列使用，属性配置如表所示：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url 的路径值</td></tr><tr><td>tags</td><td>如果设置这个值，value 的值会被覆盖</td></tr><tr><td>description</td><td>对 API 资源的描述</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为 true 将在文档中隐藏</td></tr></tbody></table><p>重启项目之后，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html#/message-controller%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost:8080/swagger-ui.html#/message-controller，可以看到如下效果：</a></p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger2.png"></p><p>自动将 MessageController 内的方法都添加了映射，并标明了每种方法的请求方式。</p><h4 id="ApiOperation-的使用"><a href="#ApiOperation-的使用" class="headerlink" title="@ApiOperation 的使用"></a>@ApiOperation 的使用</h4><p>ApiOperation 定义在方法上，描述方法名、方法解释、返回信息、标记等信息。</p><p>使用示例：</p><pre><code>@ApiOperation(            value = "消息列表",            notes = "完整的消息内容列表",            produces="application/json, application/xml",            consumes="application/json, application/xml",            response = List.class)@GetMapping(value = "messages")public List&lt;Message&gt; list() {}</code></pre><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url 的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的 值会被覆盖</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为 true 将在文档中隐藏</td></tr><tr><td>response</td><td>返回的对象</td></tr><tr><td>responseContainer</td><td>这些对象是有效的 “List”, “Set” or “Map”，其他无效</td></tr><tr><td>httpMethod</td><td>“GET”、”HEAD”、”POST”、”PUT”、”DELETE”、”OPTIONS” and “PATCH”</td></tr><tr><td>code</td><td>http 的状态码 默认 200</td></tr><tr><td>extensions</td><td>扩展属性</td></tr></tbody></table><p>重启项目之后，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html#/message-controller/listUsingGET%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost:8080/swagger-ui.html#/message-controller/listUsingGET，可以看到如下效果：</a></p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger3.png"></p><h4 id="ApiImplicitParams-和-ApiImplicitParam-的使用"><a href="#ApiImplicitParams-和-ApiImplicitParam-的使用" class="headerlink" title="@ApiImplicitParams 和 @ApiImplicitParam 的使用"></a>@ApiImplicitParams 和 @ApiImplicitParam 的使用</h4><p>@ApiImplicitParams 用于描述方法的返回信息，和 @ApiImplicitParam 注解配合使用；@ApiImplicitParam 用来描述具体某一个参数的信息，包括参数的名称、类型、限制等信息。</p><p>使用示例：</p><pre><code>@ApiOperation(value = "添加消息", notes = "根据参数创建消息")    @ApiImplicitParams({            @ApiImplicitParam(name = "id", value = "消息 ID", required = true, dataType = "Long", paramType = "query"),            @ApiImplicitParam(name = "text", value = "正文", required = true, dataType = "String", paramType = "query"),            @ApiImplicitParam(name = "summary", value = "摘要", required = false, dataType = "String", paramType = "query"),})@PostMapping(value = "message")public Message create(Message message) {}</code></pre><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>name    接收参数名</td><td></td></tr><tr><td>value    接收参数的意义描述</td><td></td></tr><tr><td>required    参数是否必填值为 true 或者 false</td><td></td></tr><tr><td>dataType    参数的数据类型只作为标志说明，并没有实际验证</td><td></td></tr><tr><td>paramType    查询参数类型，其值：path 以地址的形式提交数据 query 直接跟参数完成自动映射赋</td><td></td></tr><tr><td>body 以流的形式提交，仅支持 POST</td><td></td></tr><tr><td>header 参数在 request headers 里边提交</td><td></td></tr><tr><td>form 以 form 表单的形式提交 仅支持 POST</td><td></td></tr><tr><td>defaultValue    默认值</td><td></td></tr></tbody></table><p>重启项目之后，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html#/message-controller/createUsingPOST%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost:8080/swagger-ui.html#/message-controller/createUsingPOST，可以看到如下效果：</a></p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger4.png"></p><h4 id="ApiResponses-和-ApiResponse-的使用"><a href="#ApiResponses-和-ApiResponse-的使用" class="headerlink" title="@ApiResponses 和 @ApiResponse 的使用"></a>@ApiResponses 和 @ApiResponse 的使用</h4><p>@ApiResponses 主要封装方法的返回信息和 @ApiResponse 配置起来使用，@ApiResponse 定义返回的具体信息包括返回码、返回信息等。</p><p>使用示例：</p><pre><code>@ApiOperation(value = "修改消息", notes = "根据参数修改消息")@PutMapping(value = "message")@ApiResponses({        @ApiResponse(code = 100, message = "请求参数有误"),        @ApiResponse(code = 101, message = "未授权"),        @ApiResponse(code = 103, message = "禁止访问"),        @ApiResponse(code = 104, message = "请求路径不存在"),        @ApiResponse(code = 200, message = "服务器内部错误")})public Message modify(Message message) {}</code></pre><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>code    http 的状态码</td><td></td></tr><tr><td>message    描述</td><td></td></tr><tr><td>response    默认响应类 Void</td><td></td></tr><tr><td>reference    参考</td><td></td></tr><tr><td>responseHeaders    封装返回信息</td><td></td></tr><tr><td>responseContainer    字符串</td><td></td></tr></tbody></table><p>重启项目之后，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html#/message-controller/modifyUsingPUT%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost:8080/swagger-ui.html#/message-controller/modifyUsingPUT，可以看到如下效果：</a></p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger5.png"></p><h4 id="ApiModel-和-ApiModelProperty-的使用"><a href="#ApiModel-和-ApiModelProperty-的使用" class="headerlink" title="@ApiModel 和 @ApiModelProperty 的使用"></a>@ApiModel 和 @ApiModelProperty 的使用</h4><p>在实际的项目中我们常常会封装一个对象作为返回值，@ApiModel 就是负责描述对象的信息，@ApiModelProperty 负责描述对象中属性的相关内容。</p><p>使用示例：</p><pre><code>@ApiModel(description = "响应对象")public class BaseResult&lt;T&gt; {    private static final int SUCCESS_CODE = 0;    private static final String SUCCESS_MESSAGE = "成功";    @ApiModelProperty(value = "响应码", name = "code", required = true, example = "" + SUCCESS_CODE)    private int code;    @ApiModelProperty(value = "响应消息", name = "msg", required = true, example = SUCCESS_MESSAGE)    private String msg;    @ApiModelProperty(value = "响应数据", name = "data")    private T data;}</code></pre><p>属性配置如下表所示：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>属性描述</td></tr><tr><td>name</td><td>如果配置覆盖属性名称</td></tr><tr><td>allowableValues</td><td>允许的值</td></tr><tr><td>access</td><td>可以不配置</td></tr><tr><td>notes</td><td>没有使用</td></tr><tr><td>dataType</td><td>数据类型</td></tr><tr><td>required</td><td>是否为必传参数</td></tr><tr><td>position</td><td>显示的顺序位置</td></tr><tr><td>hidden</td><td>是否因此</td></tr><tr><td>example</td><td>举例</td></tr><tr><td>readOnly</td><td>只读</td></tr><tr><td>reference</td><td>引用</td></tr></tbody></table><p>这样我们在 Controller 中封装返还信息时就可以这样操作：</p><pre><code>@PatchMapping(value="/message/text")public BaseResult&lt;Message&gt; patch(Message message) {    Message messageResult=this.messageRepository.updateText(message);    return BaseResult.successWithData(messageResult);}</code></pre><p>重启项目之后，在浏览器中输入网址 <a href="http://localhost:8080/swagger-ui.html%EF%BC%8C%E7%82%B9%E8%A7%A3%E9%A1%B5%E9%9D%A2">http://localhost:8080/swagger-ui.html，点解页面</a> Models 折叠项，可以看到如下效果：</p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/swagger6.png"></p><p>以上就是在项目中最常用的一些注解，灵活地利用这些注解就可以自动构建出清晰的 API 文档。</p><h3 id="Try-it-out"><a href="#Try-it-out" class="headerlink" title="Try it out"></a>Try it out</h3><p>使用 Swagger 创建的在线 API 还有一个非常强大的功能，可以在页面直接测试接口的可用性，这样在前端和后端接口调试出现问题时，可以非常方便地利用此功能进行接口验证。在上面参数讲解过程中，我们发现每个接口描述右侧都有一个按钮 try it out，单击 try it out 按钮即可进入表单页面，如下：</p><p><img src="http://www.ityouknow.com/assets/images/2018/springboot/try.png"></p><p>在表单页面添加相关字段后，单击“Execute”按钮就会将请求发送到后台，从而进行接口验证，通过按钮下面的命令可以看出，实际上是使用了 curl 命令进行的 post 测试：</p><pre><code>curl -X POST "http://localhost:8080/message?id=6&amp;summary=%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF&amp;text=hello" -H "accept: */*"</code></pre><p>在后端调整 Swagger 方法上对应参数，即可看到 curl 命令参数的变化。</p><h3 id="使用Swagger2Markup导出swagger2文档"><a href="#使用Swagger2Markup导出swagger2文档" class="headerlink" title="使用Swagger2Markup导出swagger2文档"></a>使用Swagger2Markup导出swagger2文档</h3><p>引入依赖与插件</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--swagger静态化输出依赖--&gt;    &lt;dependency&gt;    &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;    &lt;artifactId&gt;swagger2markup&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;    &lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;!--swagger静态化插件 先执行测试类生成.adoc文件再运行maven命令 asciidoctor:process-asciidoc生成html--&gt;&lt;plugin&gt;&lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;&lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;&lt;version&gt;1.5.6&lt;/version&gt;&lt;configuration&gt;&lt;sourceDirectory&gt;./docs/asciidoc/generated&lt;/sourceDirectory&gt;&lt;outputDirectory&gt;./docs/asciidoc/html&lt;/outputDirectory&gt;&lt;headerFooter&gt;true&lt;/headerFooter&gt;&lt;doctype&gt;book&lt;/doctype&gt;&lt;backend&gt;html&lt;/backend&gt;&lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt;&lt;attributes&gt;&lt;!--菜单栏在左边--&gt;&lt;toc&gt;left&lt;/toc&gt;&lt;!--多标题排列--&gt;&lt;toclevels&gt;3&lt;/toclevels&gt;&lt;!--自动打数字序号--&gt;&lt;sectnums&gt;true&lt;/sectnums&gt;&lt;/attributes&gt;&lt;/configuration&gt;&lt;/plugin&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的pom</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;groupId&gt;com.lichongbing&lt;/groupId&gt;&lt;artifactId&gt;springboot-learn-swagger-docs-study&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;springboot-learn-swagger-docs-study&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--导出到markdown文件的依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;&lt;artifactId&gt;swagger2markup&lt;/artifactId&gt;&lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;nl.jworks.markdown_to_asciidoc&lt;/groupId&gt;&lt;artifactId&gt;markdown_to_asciidoc&lt;/artifactId&gt;&lt;version&gt;1.1-sources&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;!--swagger静态化插件 先执行测试类生成.adoc文件再运行maven命令 asciidoctor:process-asciidoc生成html--&gt;&lt;plugin&gt;&lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;&lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;&lt;version&gt;1.5.6&lt;/version&gt;&lt;configuration&gt;&lt;sourceDirectory&gt;./docs/asciidoc/generated&lt;/sourceDirectory&gt;&lt;outputDirectory&gt;./docs/asciidoc/html&lt;/outputDirectory&gt;&lt;headerFooter&gt;true&lt;/headerFooter&gt;&lt;doctype&gt;book&lt;/doctype&gt;&lt;backend&gt;html&lt;/backend&gt;&lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt;&lt;attributes&gt;&lt;!--菜单栏在左边--&gt;&lt;toc&gt;left&lt;/toc&gt;&lt;!--多标题排列--&gt;&lt;toclevels&gt;3&lt;/toclevels&gt;&lt;!--自动打数字序号--&gt;&lt;sectnums&gt;true&lt;/sectnums&gt;&lt;/attributes&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写一个测试类</p><pre class="line-numbers language-none"><code class="language-none">package com.lichongbing;import io.github.swagger2markup.GroupBy;import io.github.swagger2markup.Language;import io.github.swagger2markup.Swagger2MarkupConfig;import io.github.swagger2markup.Swagger2MarkupConverter;import io.github.swagger2markup.builder.Swagger2MarkupConfigBuilder;import io.github.swagger2markup.markup.builder.MarkupLanguage;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.net.URL;import java.nio.file.Paths;/** * @author lichongbing * @email 873610008@qq.com * @date 2020/01/02 19:31 * com.lichongbing */@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationIntfTests {    /**     * 生成AsciiDocs格式文档     *     * @throws Exception     */    @Test    public void generateAsciiDocs() throws Exception {        //  输出Ascii格式        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()                .withMarkupLanguage(MarkupLanguage.ASCIIDOC)                .withOutputLanguage(Language.ZH)                .withPathsGroupedBy(GroupBy.TAGS)                .withGeneratedExamples()                .withoutInlineSchema()                .build();        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs"))                .withConfig(config)                .build()                .toFolder(Paths.get("./docs/asciidoc/generated"));    }    /**     * 生成Markdown格式文档     *     * @throws Exception     */    @Test    public void generateMarkdownDocs() throws Exception {        //  输出Markdown格式        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()                .withMarkupLanguage(MarkupLanguage.MARKDOWN)                .withOutputLanguage(Language.ZH)                .withPathsGroupedBy(GroupBy.TAGS)                .withGeneratedExamples()                .withoutInlineSchema()                .build();        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs"))                .withConfig(config)                .build()                .toFolder(Paths.get("./docs/markdown/generated"));    }    /**     * 生成Confluence格式文档     *     * @throws Exception     */    @Test    public void generateConfluenceDocs() throws Exception {        //  输出Confluence使用的格式        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()                .withMarkupLanguage(MarkupLanguage.CONFLUENCE_MARKUP)                .withOutputLanguage(Language.ZH)                .withPathsGroupedBy(GroupBy.TAGS)                .withGeneratedExamples()                .withoutInlineSchema()                .build();        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs"))                .withConfig(config)                .build()                .toFolder(Paths.get("./docs/confluence/generated"));    }    /**     * 生成AsciiDocs格式文档,并汇总成一个文件     *     * @throws Exception     */    @Test    public void generateAsciiDocsToFile() throws Exception {        //  输出Ascii到单文件        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()                .withMarkupLanguage(MarkupLanguage.ASCIIDOC)                .withOutputLanguage(Language.ZH)                .withPathsGroupedBy(GroupBy.TAGS)                .withGeneratedExamples()                .withoutInlineSchema()                .build();        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs"))                .withConfig(config)                .build()                .toFile(Paths.get("./docs/asciidoc/generated/all"));    }    /**     * 生成Markdown格式文档,并汇总成一个文件     *     * @throws Exception     */    @Test    public void generateMarkdownDocsToFile() throws Exception {        //  输出Markdown到单文件        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()                .withMarkupLanguage(MarkupLanguage.MARKDOWN)                .withOutputLanguage(Language.ZH)                .withPathsGroupedBy(GroupBy.TAGS)                .withGeneratedExamples()                .withoutInlineSchema()                .build();        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs"))                .withConfig(config)                .build()                .toFile(Paths.get("./docs/markdown/generated/all"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目,拿到json文件的地址,拿到之后关闭项目,不然之后允许测试的时候会报端口被占用</p><p><img src="http://image.lichongbing.com/static/d852f42d538a2cfe4f1cf1f4c2745385.png" alt="截屏2020-01-0221.45.05.png"></p><p>运行步骤2中的五个Test,如果报docs/markdown文件夹不存在,请自己手动建文件夹;不出意外的话generated会生成.adoc文件</p><pre class="line-numbers language-none"><code class="language-none">.├── asciidoc│&nbsp;&nbsp; └── generated│&nbsp;&nbsp;     ├── all.adoc│&nbsp;&nbsp;     ├── definitions.adoc│&nbsp;&nbsp;     ├── overview.adoc│&nbsp;&nbsp;     ├── paths.adoc│&nbsp;&nbsp;     └── security.adoc├── confluence│&nbsp;&nbsp; └── generated│&nbsp;&nbsp;     ├── definitions.txt│&nbsp;&nbsp;     ├── overview.txt│&nbsp;&nbsp;     ├── paths.txt│&nbsp;&nbsp;     └── security.txt└── markdown    └── generated        ├── all.md        ├── definitions.md        ├── overview.md        ├── paths.md        └── security.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行maven命令asciidoctor:process-asciidoc生成html</p><pre class="line-numbers language-none"><code class="language-none">mvn asciidoctor:process-asciidoc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大功告成,访问all.html即可</p><pre class="line-numbers language-none"><code class="language-none">├── asciidoc│&nbsp;&nbsp; ├── generated│&nbsp;&nbsp; │&nbsp;&nbsp; ├── all.adoc│&nbsp;&nbsp; │&nbsp;&nbsp; ├── definitions.adoc│&nbsp;&nbsp; │&nbsp;&nbsp; ├── overview.adoc│&nbsp;&nbsp; │&nbsp;&nbsp; ├── paths.adoc│&nbsp;&nbsp; │&nbsp;&nbsp; └── security.adoc│&nbsp;&nbsp; └── html│&nbsp;&nbsp;     ├── all.html│&nbsp;&nbsp;     ├── definitions.html│&nbsp;&nbsp;     ├── overview.html│&nbsp;&nbsp;     ├── paths.html│&nbsp;&nbsp;     └── security.html├── confluence│&nbsp;&nbsp; └── generated│&nbsp;&nbsp;     ├── definitions.txt│&nbsp;&nbsp;     ├── overview.txt│&nbsp;&nbsp;     ├── paths.txt│&nbsp;&nbsp;     └── security.txt└── markdown    └── generated        ├── all.md        ├── definitions.md        ├── overview.md        ├── paths.md        └── security.md        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这节课的学习我们掌握了在 Spring Boot 项目中使用 Swagger，利用 Swagger 的相关注解可以容易地构建出丰富的 API 文档。使用 Swagger 之后可以帮助生成标准的 API 说明文档，避免接口交互中的低效沟通问题，Swagger 做为强大的 API 生成框架其实还有更多的功能，大家有机会可以在线下继续学习。</p><blockquote><p><a href="https://gitee.com/robbinelee/springboot-learn-swagger-docs-study">点击这里下载源码</a>。<br>本作品采用进行许可本文由李崇兵创作，采用 <a href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a> 进行许可。 可自由转载、引用，但需署名作者且注明文章出处。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 构建一个 RESTful Web 服务</title>
      <link href="/2020/01/02/spring-boot-gou-jian-yi-ge-restful-web-fu-wu/"/>
      <url>/2020/01/02/spring-boot-gou-jian-yi-ge-restful-web-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-构建一个-RESTful-Web-服务"><a href="#Spring-Boot-构建一个-RESTful-Web-服务" class="headerlink" title="Spring Boot 构建一个 RESTful Web 服务"></a>Spring Boot 构建一个 RESTful Web 服务</h1><p>现在越来越多的企业推荐使用 RESTful 风格来构建企业的应用接口，那么什么是 RESTful 呢？</p><h3 id="什么是-RESTful"><a href="#什么是-RESTful" class="headerlink" title="什么是 RESTful"></a>什么是 RESTful</h3><p>RESTful 是目前最流行的一种互联网软件架构。REST（Representational State Transfer，表述性状态转移）一词是由 Roy Thomas Fielding 在他 2000 年博士论文中提出的，定义了他对互联网软件的架构原则，如果一个架构符合 REST 原则，则称它为 RESTful 架构。</p><p>RESTful 架构一个核心概念是“资源”（Resource）。从 RESTful 的角度看，网络里的任何东西都是资源，它可以是一段文本、一张图片、一首歌曲、一种服务等，每个资源都对应一个特定的 URI（统一资源定位符），并用它进行标示，访问这个 URI 就可以获得这个资源。</p><p>资源可以有多种表现形式，也就是资源的“表述”（Representation），比如一张图片可以使用 JPEG 格式也可以使用 PNG 格式。URI 只是代表了资源的实体，并不能代表它的表现形式。</p><p>互联网中，客户端和服务端之间的互动传递的就只是资源的表述，我们上网的过程，就是调用资源的 URI，获取它不同表现形式的过程。这种互动只能使用无状态协议 HTTP，也就是说，服务端必须保存所有的状态，客户端可以使用 HTTP 的几个基本操作，包括 GET（获取）、POST（创建）、PUT（更新）与 DELETE（删除），使得服务端上的资源发生“状态转化”（State Transfer），也就是所谓的“表述性状态转移”。</p><h3 id="Spring-Boot-对-RESTful-的支持"><a href="#Spring-Boot-对-RESTful-的支持" class="headerlink" title="Spring Boot 对 RESTful 的支持"></a>Spring Boot 对 RESTful 的支持</h3><p>Spring Boot 全面支持开发 RESTful 程序，通过不同的注解来支持前端的请求，除了经常使用的注解外，Spring Boot 还提了一些组合注解。这些注解来帮助简化常用的 HTTP 方法的映射，并更好地表达被注解方法的语义。</p><ul><li>  @GetMapping，处理 Get 请求</li><li>  @PostMapping，处理 Post 请求</li><li>  @PutMapping，用于更新资源</li><li>  @DeleteMapping，处理删除请求</li><li>  @PatchMapping，用于更新部分资源</li></ul><p>其实这些组合注解就是我们使用的 @RequestMapping 的简写版本，下面是 Java 类中的使用示例：</p><pre><code>@GetMapping(value="/xxx")等价于@RequestMapping(value = "/xxx",method = RequestMethod.GET)@PostMapping(value="/xxx")等价于@RequestMapping(value = "/xxx",method = RequestMethod.POST)@PutMapping(value="/xxx")等价于@RequestMapping(value = "/xxx",method = RequestMethod.PUT)@DeleteMapping(value="/xxx")等价于@RequestMapping(value = "/xxx",method = RequestMethod.DELETE)@PatchMapping(value="/xxx")等价于@RequestMapping(value = "/xxx",method = RequestMethod.PATCH)</code></pre><p>通过以上可以看出 RESTful 在请求的类型中就指定了对资源的操控。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>按照 RESTful 的思想我们来设计一组对用户操作的 RESTful API：</p><table><thead><tr><th>请求</th><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>get</td><td>/messages</td><td>获取所有消息</td></tr><tr><td>post</td><td>/message</td><td>创建一个消息</td></tr><tr><td>put</td><td>/message</td><td>修改消息内容</td></tr><tr><td>patch</td><td>/message/text</td><td>修改消息的 text 字段</td></tr><tr><td>get</td><td>/message/id</td><td>根据 ID 获取消息</td></tr><tr><td>delete</td><td>/message/id</td><td>根据 ID 删除消息</td></tr></tbody></table><p>put 方法主要是用来更新整个资源的，而 patch 方法主要表示更新部分字段。</p><h4 id="开发实体列的操作"><a href="#开发实体列的操作" class="headerlink" title="开发实体列的操作"></a>开发实体列的操作</h4><p>首先定义一个 Message 对象：</p><pre><code>public class Message {    private Long id;    private String text;    private String summary;    // 省略 getter setter}</code></pre><p>我们使用 ConcurrentHashMap 来模拟存储 Message 对象的增删改查，AtomicLong 做为消息的自增组建来使用。ConcurrentHashMap 是 Java 中高性能并发的 Map 接口，AtomicLong 作用是对长整形进行原子操作，可以在高并场景下获取到唯一的 Long 值。</p><pre><code>@Service("messageRepository")public class InMemoryMessageRepository implements MessageRepository {    private static AtomicLong counter = new AtomicLong();    private final ConcurrentMap&lt;Long, Message&gt; messages = new ConcurrentHashMap&lt;&gt;();}</code></pre><p>查询所有用户，就是将 Map 中的信息全部返回。</p><pre><code>@Overridepublic List&lt;Message&gt; findAll() {    List&lt;Message&gt; messages = new ArrayList&lt;Message&gt;(this.messages.values());    return messages;}</code></pre><p>保持消息时，需要判断是否存在 ID，如果没有，可以使用 AtomicLong 获取一个。</p><pre><code>@Overridepublic Message save(Message message) {    Long id = message.getId();    if (id == null) {        id = counter.incrementAndGet();        message.setId(id);    }    this.messages.put(id, message);    return message;}</code></pre><p>更新时直接覆盖对应的 Key：</p><pre><code>@Overridepublic Message update(Message message) {    this.messages.put(message.getId(), message);    return message;}</code></pre><p>更新 text 字段：</p><pre><code>@Overridepublic Message updateText(Message message) {    Message msg=this.messages.get(message.getId());    msg.setText(message.getText());    this.messages.put(msg.getId(), msg);    return msg;}</code></pre><p>最后封装根据 ID 查找和删除消息。</p><pre><code>@Overridepublic Message findMessage(Long id) {    return this.messages.get(id);}@Overridepublic void deleteMessage(Long id) {    this.messages.remove(id);}</code></pre><h4 id="封装-RESTful-的处理"><a href="#封装-RESTful-的处理" class="headerlink" title="封装 RESTful 的处理"></a>封装 RESTful 的处理</h4><p>将上面封装好的 MessageRepository 注入到 Controller 中，调用对应的增删改查方法。</p><pre><code>@RestController@RequestMapping("/")public class MessageController {    @Autowired    private  MessageRepository messageRepository;    // 获取所有消息体    @GetMapping(value = "messages")    public List&lt;Message&gt; list() {        List&lt;Message&gt; messages = this.messageRepository.findAll();        return messages;    }    // 创建一个消息体    @PostMapping(value = "message")    public Message create(Message message) {        message = this.messageRepository.save(message);        return message;    }    // 使用 put 请求进行修改    @PutMapping(value = "message")    public Message modify(Message message) {        Message messageResult=this.messageRepository.update(message);        return messageResult;    }    // 更新消息的 text 字段    @PatchMapping(value="/message/text")    public Message patch(Message message) {        Message messageResult=this.messageRepository.updateText(message);        return messageResult;    }    @GetMapping(value = "message/{id}")    public Message get(@PathVariable Long id) {        Message message = this.messageRepository.findMessage(id);        return message;    }    @DeleteMapping(value = "message/{id}")    public void delete(@PathVariable("id") Long id) {        this.messageRepository.deleteMessage(id);    }}</code></pre><h4 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h4><p>我们使用 MockMvc 进行测试。MockMvc 实现了对 Http 请求的模拟，能够直接使用网络的形式，转换到 Controller 的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。</p><p>下面是 MockMvc 的主体架构：</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class MessageControllerTest {    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Before    public void setup() {        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();    }}</code></pre><ul><li>  @SpringBootTest 注解是 SpringBoot 自 1.4.0 版本开始引入的一个用于测试的注解</li><li>  @RunWith(SpringRunner.class) 代表运行一个 Spring 容器</li><li>  @Before 代表在测试启动时候需要提前加载的内容，这里是提前加载 MVC 环境</li></ul><p><strong>1. 测试创建消息（post 请求）</strong></p><p>我们先来测试创建一个消息体：</p><pre><code>@Testpublic void saveMessage() throws Exception {    final MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();    params.add("text", "text");    params.add("summary", "summary");    String mvcResult=  mockMvc.perform(MockMvcRequestBuilders.post("/message")            .params(params)).andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><ul><li>  MultiValueMap 用来存储需要发送的请求参数。</li><li>  MockMvcRequestBuilders.post 代表使用 post 请求。</li></ul><p>运行这个测试后返回结果如下：</p><pre><code>Result === {"id":10,"text":"text","summary":"summary","created":"2018-07-28T06:27:23.176+0000"}</code></pre><p>表明创建消息成功。</p><p><strong>2. 批量添加消息体（post 请求）</strong></p><p>为了方便后面测试，需要启动时在内存中存入一些消息来测试。</p><p>封装一个 saveMessages() 方法批量存储 9 条消息：</p><pre><code>private void  saveMessages()  {    for (int i=1;i&lt;10;i++){        final MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();        params.add("text", "text"+i);        params.add("summary", "summary"+i);        try {            MvcResult mvcResult=  mockMvc.perform(MockMvcRequestBuilders.post("/message")                    .params(params)).andReturn();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>并且将 saveMessages() 方法添加到 setup() 中，这样启动测试的时候内存中就已经保存了一些数据。</p><pre><code>@Beforepublic void setup() {    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();    saveMessages();}</code></pre><p><strong>3. 测试获取所有消息（get 请求)</strong></p><pre><code>@Testpublic void getAllMessages() throws Exception {    String mvcResult= mockMvc.perform(MockMvcRequestBuilders.get("/messages"))            .andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><p>运行后返回结果：</p><pre><code>Result === [{"id":1,"text":"text1","summary":"summary1","created":"2018-07-28T06:34:20.583+0000"},{"id":2,"text":"text2","summary":"summary2","created":"2018-07-28T06:34:20.675+0000"},{"id":3,"text":"text3","summary":"summary3","created":"2018-07-28T06:34:20.677+0000"},{"id":4,"text":"text4","summary":"summary4","created":"2018-07-28T06:34:20.678+0000"},{"id":5,"text":"text5","summary":"summary5","created":"2018-07-28T06:34:20.680+0000"},{"id":6,"text":"text6","summary":"summary6","created":"2018-07-28T06:34:20.682+0000"},{"id":7,"text":"text7","summary":"summary7","created":"2018-07-28T06:34:20.684+0000"},{"id":8,"text":"text8","summary":"summary8","created":"2018-07-28T06:34:20.685+0000"},{"id":9,"text":"text9","summary":"summary9","created":"2018-07-28T06:34:20.687+0000"}]</code></pre><p>可以看出初始化的数据已经保存到内存 Map 中，另一方面表明获取数据测试成功。</p><p><strong>4. 测试获取单个消息（get 请求)</strong></p><pre><code>@Testpublic void getMessage() throws Exception {    String mvcResult= mockMvc.perform(MockMvcRequestBuilders.get("/message/6"))            .andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><p>上面代码表明获取 ID 为 6 的消息。</p><p>运行后返回结果：</p><pre><code>Result === {"id":6,"text":"text6","summary":"summary6","created":"2018-07-28T06:37:26.014+0000"}</code></pre><p><strong>5. 测试修改（put 请求）</strong></p><pre><code>@Testpublic void modifyMessage() throws Exception {    final MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();    params.add("id", "6");    params.add("text", "text");    params.add("summary", "summary");    String mvcResult= mockMvc.perform(MockMvcRequestBuilders.put("/message").params(params))            .andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><p>上面代码更新 ID 为 6 的消息体。</p><p>运行后返回结果：</p><pre><code>Result === {"id":6,"text":"text","summary":"summary","created":"2018-07-28T06:38:32.277+0000"}</code></pre><p>我们发现 ID 为 6 的消息 text 字段值由 text6 变为 text，summary 字段值由 summary6 变为 summary，表示消息更新成功。</p><p><strong>6. 测试局部修改（patch 请求)</strong></p><pre><code>@Testpublic void patchMessage() throws Exception {    final MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();    params.add("id", "6");    params.add("text", "text");    String mvcResult= mockMvc.perform(MockMvcRequestBuilders.patch("/message/text").params(params))            .andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><p>同样是更新 ID 为 6 的消息体，但只是更新消息属性的一个字段。</p><p>运行后返回结果：</p><pre><code>Result === {"id":6,"text":"text","summary":"summary6","created":"2018-07-28T06:41:51.816+0000"}</code></pre><p>这次发现只有 text 字段值由 text6 变为 text，summary 字段值没有变化，表明局部更新成功。</p><p><strong>7. 测试删除（delete 请求）</strong></p><pre><code>@Testpublic void deleteMessage() throws Exception {    mockMvc.perform(MockMvcRequestBuilders.delete("/message/6"))            .andReturn();    String mvcResult= mockMvc.perform(MockMvcRequestBuilders.get("/messages"))            .andReturn().getResponse().getContentAsString();    System.out.println("Result === "+mvcResult);}</code></pre><p>测试删除 ID 为 6 的消息体，最后重新查询所有的消息。</p><p>运行后返回结果：</p><pre><code>Result === [{"id":1,"text":"text1","summary":"summary1","created":"2018-07-28T06:43:47.185+0000"},{"id":2,"text":"text2","summary":"summary2","created":"2018-07-28T06:43:47.459+0000"},{"id":3,"text":"text3","summary":"summary3","created":"2018-07-28T06:43:47.461+0000"},{"id":4,"text":"text4","summary":"summary4","created":"2018-07-28T06:43:47.463+0000"},{"id":5,"text":"text5","summary":"summary5","created":"2018-07-28T06:43:47.464+0000"},{"id":7,"text":"text7","summary":"summary7","created":"2018-07-28T06:43:47.468+0000"},{"id":8,"text":"text8","summary":"summary8","created":"2018-07-28T06:43:47.468+0000"},{"id":9,"text":"text9","summary":"summary9","created":"2018-07-28T06:43:47.470+0000"}]</code></pre><p>运行后发现 ID 为 6 的消息已经被删除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RESTful 是一种非常优雅的设计，相同 URL 请求方式不同后端处理逻辑不同，利用 RESTful 风格很容易设计出更优雅和直观的 API 交互接口。同时 Spring Boot 对 RESTful 的支持也做了大量的优化，方便在 Spring Boot 体系内使用 RESTful 架构。</p><blockquote><p><a href="https://gitee.com/robbinelee/springboot-learn-swagger-csdn">点击这里下载源码</a>。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mock介绍以及代码示例</title>
      <link href="/2020/01/01/mock-jie-shao-yi-ji-dai-ma-shi-li/"/>
      <url>/2020/01/01/mock-jie-shao-yi-ji-dai-ma-shi-li/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-Mock测试介绍"><a href="#1-Mock测试介绍" class="headerlink" title="1. Mock测试介绍"></a>1. Mock测试介绍</h2><ul><li><strong>定义</strong><br>  在单元测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟对象来创建以便测试的方法。</li><li><strong>为什么使用mock测试</strong><ul><li>  避免模块开发之间的耦合；</li><li>  轻量、简便、灵活；</li></ul></li></ul><h2 id="2-MockMVC介绍"><a href="#2-MockMVC介绍" class="headerlink" title="2. MockMVC介绍"></a>2. MockMVC介绍</h2><p>基于RESTful风格的SpringMVC单元测试，可以测试完整的SpringMVC流程，即从URL请求到控制处理器，带到视图渲染都可以测试。</p><h3 id="2-1-MockMvc"><a href="#2-1-MockMvc" class="headerlink" title="2.1 MockMvc"></a>2.1 MockMvc</h3><ul><li>  服务器端SpringMVC测试的主入口点。</li><li>  通过MockMVCBuilders建造者的静态方法去建造MockMVCBuilder，MockMvc由MockMVCBuilder构造。</li><li>  核心方法：<strong>perform</strong>(RequestBuilder rb)，执行一个RequestBuilder请，会自动执行SpringMVC的流程并映射到相应的控制器执行处理，该方法的返回值是一个ResultActions。</li></ul><h3 id="2-2-MockMVCBuilder"><a href="#2-2-MockMVCBuilder" class="headerlink" title="2.2 MockMVCBuilder"></a>2.2 MockMVCBuilder</h3><ul><li>  MockMVCBuilder是使用构造者模式来构造MockMvc的构造器。</li><li>  主要有两个实现：<strong>StandaloneMockMvcBuilder</strong>和<strong>DefaultMockMvcBuilder</strong>。</li><li>  可以直接使用<strong>静态工厂MockMvcBuilders创建</strong>即可，不需要直接使用上面两个实现类。</li></ul><h3 id="2-3-MockMVCBuilders"><a href="#2-3-MockMVCBuilders" class="headerlink" title="2.3 MockMVCBuilders"></a>2.3 MockMVCBuilders</h3><ul><li>  负责创建MockMVCBuilder对象。</li><li>有两种创建方式<ul><li>  standaloneSetup(Object… controllers): 通过参数指定一组控制器，这样就不需要从上下文获取了。</li><li>  <strong>webAppContextSetup</strong>(WebApplicationContext wac)：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc</li></ul></li></ul><h3 id="2-4-MockMvcRequestBuilders"><a href="#2-4-MockMvcRequestBuilders" class="headerlink" title="2.4 MockMvcRequestBuilders"></a>2.4 MockMvcRequestBuilders</h3><ul><li>  用来构建Request请求的。</li><li>  其主要有两个子类<strong>MockHttpServletRequestBuilder</strong>和<strong>MockMultipartHttpServletRequestBuilder</strong>（如文件上传使用），即用来Mock客户端请求需要的所有数据。</li></ul><h3 id="2-5-ResultActions"><a href="#2-5-ResultActions" class="headerlink" title="2.5 ResultActions"></a>2.5 ResultActions</h3><ul><li>  <strong>andExpect</strong>：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确。</li><li>  <strong>andDo</strong>：添加ResultHandler结果处理器，比如调试时打印结果到控制台。</li><li>  <strong>andReturn</strong>：最后返回相应的<strong>MvcResult</strong>；然后进行自定义验证/进行下一步的异步处理。</li><li><strong>MockMvcResultMatchers</strong><ul><li>  用来匹配执行完请求后的**结果验证。</li><li>  果匹配失败将抛出相应的异常。</li><li>  包含了很多验证API方法。</li></ul></li><li><strong>MockMvcResultHandlers</strong><ul><li>  结果处理器，表示要对结果做点什么事情。</li><li>  比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。</li></ul></li></ul><h3 id="2-6-MvcResult"><a href="#2-6-MvcResult" class="headerlink" title="2.6 MvcResult"></a>2.6 MvcResult</h3><p>单元测试执行结果，可以针对执行结果进行<strong>自定义验证逻辑</strong>。</p><h2 id="3-MockMVC使用"><a href="#3-MockMVC使用" class="headerlink" title="3.MockMVC使用"></a>3.MockMVC使用</h2><ul><li><p>添加依赖</p>  <!-- spring 单元测试组件包 --><pre><code>      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;          &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;!-- 单元测试Junit --&gt;      &lt;dependency&gt;          &lt;groupId&gt;junit&lt;/groupId&gt;          &lt;artifactId&gt;junit&lt;/artifactId&gt;          &lt;version&gt;4.12&lt;/version&gt;      &lt;/dependency&gt;      &lt;!-- Mock测试使用的json-path依赖 --&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt;          &lt;artifactId&gt;json-path&lt;/artifactId&gt;          &lt;version&gt;2.2.0&lt;/version&gt;      &lt;/dependency&gt;</code></pre></li></ul><ul><li>  对用户对象操作接口</li></ul><pre class="line-numbers language-none"><code class="language-none">    @RequestMapping("rest")    @RestController    public class RestfulController {                // springmvc通过路径模板变量{变量名}这种方式，对URL带有参数的情况进行支持        @RequestMapping("user/{id}/{name}/{sex}")        public User findUserById(@PathVariable Integer id,@PathVariable String name,@PathVariable String sex) {            User user = new User();            user.setId(id);            user.setUsername(name);            user.setSex(sex);                        return user;        }            }```   *   测试类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;//@WebAppConfiguration:可以在单元测试的时候，不用启动Servlet容器，就可以获取一个Web应用上下文//以前的思路：tomcat启动之后，创建Servlet对象、创建ServletContext对象---&gt;创建spring容器(WebApplicationContext)---&gt;spring容器存储到ServletContext对象中@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:springmvc.xml")@WebAppConfigurationpublic class TestMockMVC {    // 自动获取由@WebAppConfiguration产生的web应用上下文    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Before    public void setup() {        // MockMvcBuilders -- MockMvcBuilder -- &gt; MockMvc        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();    }    // 测试测试请求：http://localhost:8080/springmvc-demo/rest/user/1/lisi/女    @Test    public void test() throws Exception {        MvcResult result = mockMvc.perform(get("/rest/user/1/lisi/女"))                .andExpect(status().isOk())                .andExpect(jsonPath("$.id").value(1))//使用json path表达式                .andDo(print())                .andReturn();                Object handler = result.getHandler();        System.out.println(handler);    }    }</code></pre><pre class="line-numbers language-none"><code class="language-none">*   结果显示，说明成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>...initBinder......initBinder......initBinder...MockHttpServletRequest:      HTTP Method = GET      Request URI = /rest/user/1/lisi/%E5%A5%B3       Parameters = {}          Headers = {}             Body = &lt;no character encoding set&gt;    Session Attrs = {}Handler:             Type = com.kkb.springmvc.controller.RestfulController           Method = public com.kkb.springmvc.po.User com.kkb.springmvc.controller.RestfulController.findUserById(java.lang.Integer,java.lang.String,java.lang.String)Async:    Async started = false     Async result = nullResolved Exception:             Type = nullModelAndView:        View name = null             View = null            Model = nullFlashMap:       Attributes = nullMockHttpServletResponse:           Status = 200    Error message = null          Headers = {Content-Type=[application/json;charset=UTF-8]}     Content type = application/json;charset=UTF-8             Body = {"id":1,"username":"lisi","birthday":null,"sex":"å¥³","address":null,"uid":[],"itemList":[],"itemMap":{}}    Forwarded URL = null   Redirected URL = null          Cookies = []public com.kkb.springmvc.po.User com.kkb.springmvc.controller.RestfulController.findUserById(java.lang.Integer,java.lang.String,java.lang.String)</code></pre><pre><code>**关联文章**  [Spring Boot构建RESTful API与单元测试](http://blog.didispace.com/springbootrestfulapi/)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Spring MVC 开发Restful API</title>
      <link href="/2019/12/31/shi-yong-spring-mvc-kai-fa-restful-api/"/>
      <url>/2019/12/31/shi-yong-spring-mvc-kai-fa-restful-api/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Spring-MVC-开发Restful-API"><a href="#使用Spring-MVC-开发Restful-API" class="headerlink" title="使用Spring MVC 开发Restful API"></a>使用Spring MVC 开发Restful API</h1><p><img src="http://image.lichongbing.com/static/a62324410188d8a88c1a2a513da23fd3.gif" alt="timg.gif"></p><h2 id="编写针对RestfulAPI测试用例"><a href="#编写针对RestfulAPI测试用例" class="headerlink" title="编写针对RestfulAPI测试用例"></a>编写针对RestfulAPI测试用例</h2><p>imooc-security-demo项目结构</p><pre class="line-numbers language-none"><code class="language-none">└── src    ├── main    │&nbsp;&nbsp; ├── java    │&nbsp;&nbsp; │&nbsp;&nbsp; └── com    │&nbsp;&nbsp; │&nbsp;&nbsp;     └── imooc    │&nbsp;&nbsp; └── resources    │&nbsp;&nbsp;     ├── mock    │&nbsp;&nbsp;     │&nbsp;&nbsp; └── response    │&nbsp;&nbsp;     └── resources    │&nbsp;&nbsp;         └── error    └── test        └── java            └── com                └── imooc```                * 在pom.xml添加测试框架<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><dependencies><dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-test</artifactid></dependency></dependencies><pre class="line-numbers language-none"><code class="language-none">在/test/java/com/imooc/web/controller创建UserControllerTest.java````java@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest {    @Autowiredprivate WebApplicationContext wac;    //伪造mvc环境private MockMvc mockMvc;    @Before    public void setup() {mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();}    //用户查询测试用例   @Testpublic void whenQuerySuccess() throws Exception {mockMvc.perform(MockMvcRequestBuilders.get("/user")         .contentType(MediaType.APPLICATION_JSON_UTF8))                 .andExpect(MockMvcResultMatchers.status().isOk())                                 .andExpect(MockMvcResultMatchers.jsonPath("$.length()").value(3));}}````## 使用注解声明RestfulAPI在/main/java/com/imooc/web/controller创建UserController类* @RestController 标明此Controller提供RestAPI* @PageableDefault 指定分页参数默认值* @RequestMapping 映射http请求url到java方法````javaimport java.util.ArrayList;import java.util.List;@RestController public class UserController {@RequestMapping(value="/user",method=RequestMethod.GET)public List&lt;User&gt; query(){    List&lt;User&gt; users = new ArrayList&lt;&gt;();users.add(new User());users.add(new User());users.add(new User());return users;}}````/src/main/java/com/imooc/dto创建User类```javapublic class User{    private String usernamme;    private String password;    public String getUsername() {return username;}public void setUsername(String username) {this.username = username;}    public String getPassword() {return password;}public void setPassword(String password) {this.password = password;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="RestfullAPI中传递参数"><a href="#RestfullAPI中传递参数" class="headerlink" title="RestfullAPI中传递参数"></a>RestfullAPI中传递参数</h2><ul><li>@RequestParam 映射请求参数到java方法的参数<br>在/main/java/com/imooc/web/controller创建UserController类修改添加参数<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>继续在/test/java/com/imooc/web/controller创建UserControllerTest.java修改</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果涉及参数查询不指定时, 需要条件查询<br>在/src/main/java/com/imooc/dto创建UserQueryCondition类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserQueryCondition</span>  <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> ageTo<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> xxx<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> username<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAgeTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> ageTo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAgeTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> ageTo<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ageTo <span class="token operator">=</span> ageTo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getXxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> xxx<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setXxx</span><span class="token punctuation">(</span><span class="token class-name">String</span> xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">=</span> xxx<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续在/test/java/com/imooc/web/controller创建UserControllerTest.java修改</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"age"</span> <span class="token string">"18"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"ageTo"</span> <span class="token string">"60"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"xxx"</span> <span class="token string">"yyy"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/main/java/com/imooc/web/controller创建UserController类修改添加参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@PageableDefault 指定分页参数默认值</li></ul><p>在/main/java/com/imooc/web/controller创建UserController类修改添加参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续在/test/java/com/imooc/web/controller创建UserControllerTest.java修改，添加分页查询参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"age"</span> <span class="token string">"18"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"ageTo"</span> <span class="token string">"60"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"xxx"</span> <span class="token string">"yyy"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"size"</span> <span class="token string">"15"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"page"</span> <span class="token string">"3"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"sort"</span> <span class="token string">"age,desc"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/main/java/com/imooc/web/controller创建UserController类修改,分页信息后台打印查看</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@PageableDefault 指定分页参数默认值<br>如果前台没有指定</p><p>/test/java/com/imooc/web/controller创建UserControllerTest.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"age"</span> <span class="token string">"18"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"ageTo"</span> <span class="token string">"60"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"xxx"</span> <span class="token string">"yyy"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/main/java/com/imooc/web/controller创建UserController类修改,默认</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">17</span> sort <span class="token operator">=</span> <span class="token string">"username,asc"</span><span class="token punctuation">)</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>jsonPath</li></ul><h2 id="编写用户详情服务"><a href="#编写用户详情服务" class="headerlink" title="编写用户详情服务"></a>编写用户详情服务</h2><p>@PathVariable 映射url片段到java方法的参数<br>在url声明中使用正则表达式<br>@JsonView控制json输出内容</p><p>继续在/test/java/com/imooc/web/controller创建UserControllerTest.java继续添加新方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"age"</span> <span class="token string">"18"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"ageTo"</span> <span class="token string">"60"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"xxx"</span> <span class="token string">"yyy"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenGenInfoSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>          mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user/1"</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenGetInfoFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>     mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user/a"</span><span class="token punctuation">)</span><span class="token comment">//如果传入参数没有正则表达式，会出现错误。</span>                 <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is4xxClientError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/main/java/com/imooc/web/controller创建UserController类修改,默认</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">17</span> sort <span class="token operator">=</span> <span class="token string">"username,asc"</span><span class="token punctuation">)</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user/{id://d+}"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@JsonView的使用步骤<br>使用接口来声明多个视图<br>在值对象的get方法指定视图</p><p>/src/main/java/com/imooc/dto创建User类添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserSimpleView</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//使用接口来声明多个视图</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDetailView</span> <span class="token keyword">extends</span> <span class="token class-name">UserSimpleView</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//使用接口来声明多个视图</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> usernamme<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">UserSimpleView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在值对象的get方法指定视图</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> username<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">UserDetailView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在值对象的get方法指定视图</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> password<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/main/java/com/imooc/web/controller创建UserController类修改,默认</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserSimpleView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">17</span> sort <span class="token operator">=</span> <span class="token string">"username,asc"</span><span class="token punctuation">)</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user/{id://d+}"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserDetailView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">WebApplicationContext</span> wac<span class="token punctuation">;</span>    <span class="token comment">//伪造mvc环境</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mockMvc <span class="token operator">=</span> <span class="token class-name">MockMvcBuilders</span><span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//用户查询测试用例</span>   <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenQuerySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token class-name">String</span> result <span class="token operator">=</span> mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"username"</span> <span class="token string">"jojo"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"age"</span> <span class="token string">"18"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"ageTo"</span> <span class="token string">"60"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"xxx"</span> <span class="token string">"yyy"</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.length()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token punctuation">.</span><span class="token function">andReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContentAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenGenInfoSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>          <span class="token class-name">String</span> result <span class="token operator">=</span> mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user/1"</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">jsonPath</span><span class="token punctuation">(</span><span class="token string">"$.username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenGetInfoFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>     mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/user/a"</span><span class="token punctuation">)</span><span class="token comment">//如果传入参数没有正则表达式，会出现错误。</span>                 <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is4xxClientError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码重构</p><p>在/main/java/com/imooc/web/controller创建UserController类修改,默认</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserSimpleView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">17</span> sort <span class="token operator">=</span> <span class="token string">"username,asc"</span><span class="token punctuation">)</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id://d+}"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserDetailView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续重构</p><p>在/main/java/com/imooc/web/controller创建UserController类修改,默认</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span> <span class="token annotation punctuation">@RequestMapping</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserSimpleView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">UserQueryCondition</span> condition <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">17</span> sort <span class="token operator">=</span> <span class="token string">"username,asc"</span><span class="token punctuation">)</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ReflectionToStringBuilder</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token class-name">ToStringStyle</span><span class="token punctuation">.</span>MULTI_LINE_STYLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getPageNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pageable<span class="token punctuation">.</span><span class="token function">getSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> users<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{id://d+}"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@JsonView</span><span class="token punctuation">(</span><span class="token class-name">User<span class="token punctuation">.</span>UserDetailView</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//在contrller方法上指定视图</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>solr环境搭建与测试</title>
      <link href="/2019/12/26/solr-huan-jing-da-jian-yu-ce-shi/"/>
      <url>/2019/12/26/solr-huan-jing-da-jian-yu-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><blockquote><p>jdk1.8<br>solr-4.10.4</p></blockquote><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><ul><li>1、适合solr-4.10.4版本的ik分词器 IK Analyzer 2012FF_hf1.zip</li><li>2、准备三个文件IKAnalyzer.cfg.xml，stopword.dic,sougou.dic</li></ul><h2 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h2><ul><li>1、解压IK Analyzer 2012FF_hf1.zip，上传iIK Analyzer 2012FF_hf1.jar至solr中example下conllection1下的solr项目中的webapps/solr/WEB-INF/lib目录</li><li>2、将扩展词典(sougou.dic和stopword.dic)、配置文件(IKAnalyzer.cfg.xml)放至solr中example下conllection1下的solr项目中的webapps/solr/WEB-INF/classes目录</li><li>3、在需要增加分词器的core中增加配置，修改managed-schema(schema.xml)文件，增加fieldType:</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;fieldType name="text_ik" class="solr.TextField" &gt;       &lt;!-- 索引时的分词器 --&gt;      &lt;analyzer type="index" isMaxWorldLength="folse" class="org.wltea.analyzer.lucene.IKAnalyzer" /&gt;       &lt;analyzer type="query" isMaxWordLength="true" class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;        &lt;/fieldType&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4、为需要使用分词器的字段增加配置：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;field name="producttitle" type="text_ik" indexed="true" stored="true" omitNorms="true"/&gt;&lt;field name="productdescription" type="text_ik" indexed="true" stored="true"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>5、在example目录下运行</li></ul><pre class="line-numbers language-none"><code class="language-none">java -jar start.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过管控台的analysis功能选择‘text_ik’的fieldType进行测试，结果如下：</p><p><img src="http://image.lichongbing.com/static/7dbf064e9342d9f053f9605db8333307.png" alt="截屏2019-12-2617.39.33.png"></p><ul><li>6、搭建maven项目，编写测试<br>pom.xml 配置参考</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;            &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;            &lt;version&gt;4.10.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- slf4j --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.10&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个实体product，有三个字段</p><pre class="line-numbers language-none"><code class="language-none">import org.apache.solr.client.solrj.beans.Field;public class product {@Fieldprivate String id;@Fieldprivate String producttitle;@Fieldprivate String productdescription;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建SolrUtil，</p><pre class="line-numbers language-none"><code class="language-none">import org.apache.solr.client.solrj.SolrQuery;import org.apache.solr.client.solrj.SolrServerException;import org.apache.solr.client.solrj.impl.HttpSolrServer;import org.apache.solr.client.solrj.response.QueryResponse;import org.apache.solr.client.solrj.response.UpdateResponse;import org.apache.solr.common.SolrDocument;import org.apache.solr.common.SolrDocumentList;import org.apache.solr.common.SolrInputDocument;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.util.*;/** * solr工具类 * */public class SolrUtil {static final Logger logger = LoggerFactory.getLogger(SolrUtil.class);private static final String SOLR_URL = "http://192.168.0.194:8983/solr/collection1"; // 服务器地址private static HttpSolrServer server = null;static {try {server = new HttpSolrServer(SOLR_URL);server.setAllowCompression(true);server.setConnectionTimeout(10000);server.setDefaultMaxConnectionsPerHost(100);server.setMaxTotalConnections(100);} catch (Exception e) {logger.error("请检查tomcat服务器或端口是否开启!{}", e);e.printStackTrace();}}/** * 建立索引 * * @throws Exception */public static void addIndex(product product) {try {server.addBean(product);server.commit();} catch (IOException e) {e.printStackTrace();} catch (SolrServerException e) {e.printStackTrace();}}/** * 批量增加索引2 * * @throws Exception */public static void addIndex2(Map&lt;String, Object&gt; mapValue) throws Exception {//必须先添加idSolrInputDocument document = new SolrInputDocument();Object idvalue = mapValue.get("id");document.addField("id", idvalue);if (mapValue != null) {Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = mapValue.entrySet();for (Map.Entry&lt;String, Object&gt; entry : entrySet) {String field = entry.getKey();Object value = entry.getValue();if ("id".equals(field)) {continue;}Map&lt;String, Object&gt; operation = new HashMap&lt;String, Object&gt;();operation.put("set", value);document.addField(field, operation);}}UpdateResponse response = server.add(document);server.commit();}private static List&lt;String&gt; searchqyinfofromsolr(String searchname)throws SolrServerException, IOException {SolrQuery query = new SolrQuery();query.setQuery("producttitle:" + "*" + searchname + "* OR productdescription:" + "*" + searchname + "*");QueryResponse response = server.query(query);SolrDocumentList docs = response.getResults();long count = docs.size();List&lt;String&gt; getliststring = new ArrayList&lt;String&gt;();//遍历数据for (int i = 0; i &lt; count; i++) {SolrDocument sd = docs.get(i);String rowkeyString = (String) sd.getFieldValue("id");getliststring.add(rowkeyString);}return getliststring;}public static void main(String[] args) throws Exception {Map&lt;String, Object&gt; mapValue = new HashMap&lt;String,Object&gt;();mapValue.put("id","8");mapValue.put("producttitle","牛肉呵呵");mapValue.put("productdescription","羊肉的大哈哈");addIndex2(mapValue);List&lt;String&gt; list = searchqyinfofromsolr("肉");for (String temp : list) {System.out.println(temp);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://image.lichongbing.com/static/9e8c369bbd9354df1d8d3d9adb161b47.png" alt="截屏2019-12-2618.17.45.png"><br>搜索“肉”关键词后台检索出来编号id<br><img src="http://image.lichongbing.com/static/c7d098861e6fb1df2e03f44c7a5ee221.png" alt="截屏2019-12-2618.23.54.png"><br>至此搭建测试完毕。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>solr参考指南（使用Solr管理用户界面）</title>
      <link href="/2019/12/25/solr-can-kao-zhi-nan-shi-yong-solr-guan-li-yong-hu-jie-mian/"/>
      <url>/2019/12/25/solr-can-kao-zhi-nan-shi-yong-solr-guan-li-yong-hu-jie-mian/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Solr管理用户界面"><a href="#使用Solr管理用户界面" class="headerlink" title="使用Solr管理用户界面"></a>使用Solr管理用户界面</h1><p>本章节讨论 Solr 管理用户界面（“管理 UI”）。</p><p>Solr 的管理用户界面的概述解释了用户界面的基本特征，什么是初始管理 UI 页面，以及如何在接口上配置。另外，还有一些页面描述了管理界面的每个界面：</p><ul><li>  获取帮助：向您展示如何获取有关 UI 的更多信息。</li><li>  记录：显示由此 Solr 节点记录的最新消息，并提供了一种更改特定类的日志记录级别的方法。</li><li>  Cloud 屏幕：以 SolrCloud 模式运行时，Cloud 屏幕显示有关节点的信息。</li><li>  集合/核心管理员解释如何获取有关每个核心的管理信息。</li><li>  Java Properties：显示有关每个核心的 Java 信息。</li><li>  线程转储：让您可以查看有关每个线程的详细信息以及状态信息。</li><li>特定于集合的工具：是解释每个集合可用的其他屏幕的部分。<ul><li>  分析（Analysis）- 让您分析在特定字段中找到的数据。</li><li>  导入（Dataimport）- 显示有关数据导入处理程序的当前状态的信息。</li><li>  文档（Documents）- 提供了一个简单的表单，允许您直接从浏览器执行各种 Solr 索引命令。</li><li>  文件（Files）- 显示当前的核心配置文件，如 solrconfig.xml。</li><li>  查询（Query&nbsp;）- 让您提交关于核心的各种元素的结构化查询。</li><li>  流（Stream）- 允许您提交流表达式并查看结果和解析解释。</li><li>  架构浏览器（Schema Browser）- 在浏览器窗口中显示架构数据。</li></ul></li><li>特定于核心的工具：是说明每个指定核心可用的额外屏幕的部分。<ul><li>  Ping&nbsp;- 让你 ping 一个已命名的核心，并确定核心是否处于活动状态。</li><li>  插件/统计（Plugins/Stats）- 显示插件和其他已安装的组件的统计信息。</li><li>  复制（Replication）- 显示核心的当前复制状态，并允许您启用/禁用复制。</li><li>  段信息（Segments Info）- 提供底层 Lucene 索引段的可视化。</li></ul></li></ul><h1 id="Solr管理界面概述"><a href="#Solr管理界面概述" class="headerlink" title="Solr管理界面概述"></a>Solr管理界面概述</h1><p>Solr 具有一个 Web 界面，它使 Solr 管理员和程序员可以轻松查看 Solr 配置的详细信息、运行查询和分析文档字段，以便微调（&nbsp;fine-tune）Solr 配置并访问联机文档和其他帮助。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171108/1510129363520877.png" alt="Solr管理界面"></p><p>访问 URL&nbsp;<a href="http://hostname:8983/solr/">http://hostname:8983/solr/</a> 将显示 Solr 主仪表板，它分为两部分。</p><p>屏幕的左侧是 Solr 徽标下的菜单，它通过 UI 的屏幕提供导航。第一组链接用于系统级别的信息和配置，并提供对&nbsp;日志记录、集合/核心管理和 Java 属性等的访问。在这个信息的末尾至少有一个下拉列表为这个实例配置了 Solr 核心。在 SolrCloud 节点上，附加的下拉列表显示了此群集中的所有集合。单击集合或核心名称将显示指定集合或核心的二级信息菜单，如模式浏览器、配置文件、插件和统计信息以及对索引数据执行查询的功能。</p><p>屏幕的中心显示所选选项的详细信息。这可能包括选项的子导航或所请求的数据的文本或图形表示。有关更多详细信息，请参阅本指南中有关每个屏幕的部分。</p><p>在封面之下，Solr 管理用户界面重新使用相同的 HTTP APIs，它可供所有客户访问与 Solr 相关的数据来驱动一个外部接口。</p><pre><code>Tip：上面给出的 Solr 管理用户界面的路径是：http://hostname:port/solr，它重定向到当前版本中的路径：http://hostname:port/solr/#/。还支持方便的重定向，因此只需访问管理界面：http://hostname:port/ 也将重定向到：http://hostname:port/solr/#/。</code></pre><h1 id="从Solr管理界面获取帮助"><a href="#从Solr管理界面获取帮助" class="headerlink" title="从Solr管理界面获取帮助"></a>从Solr管理界面获取帮助</h1><p>在 Solr 的用户管理界面（Admin UI）中每个屏幕的底部是都一组链接，您可以通过使用这些链接来获取有关配置和使用 Solr 获得更多的帮助。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510198861759066.png" alt="Solr管理界面帮助图标"></p><p>Solr 用户管理界面的帮助图标包含以下链接：</p><table><thead><tr><th>链接</th><th>描述</th></tr></thead><tbody><tr><td>文档</td><td>该链接能够导航到在&nbsp;<a href="https://lucene.apache.org/solr/">https://lucene.apache.org/solr/</a>&nbsp;上托管的 Apache Solr 文档。</td></tr><tr><td>问题跟踪器</td><td>该链接能够导航到 Apache Solr 项目的 JIRA 问题跟踪服务器。该服务器位于：<a href="https://issues.apache.org/jira/browse/SOLR">https://issues.apache.org/jira/browse/SOLR</a>。</td></tr><tr><td>IRC 频道</td><td>该链接能够导航到 Solr 的&nbsp;<a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a>&nbsp;实时聊天室：<a href="http://webchat.freenode.net/?channels=#solr%E3%80%82">http://webchat.freenode.net/?channels=#solr。</a></td></tr><tr><td>社区论坛</td><td>该链接能够导航到 Apache Wiki 页面，该页面提供了有关如何参与 Solr 用户社区邮件列表的更多信息：<a href="https://wiki.apache.org/solr/UsingMailingLists%E3%80%82">https://wiki.apache.org/solr/UsingMailingLists。</a></td></tr><tr><td>Solr 查询语法</td><td>该链接能够导航到本“参考指南”中的查询语法和分析部分。</td></tr></tbody></table><p>这些链接不能在不编辑 server/solr/solr-webapp 目录中（包含在管理界面）的 index.html 的情况下进行修改。</p><h1 id="Solr日志记录"><a href="#Solr日志记录" class="headerlink" title="Solr日志记录"></a>Solr日志记录</h1><p>在日志记录页面显示此 Solr 节点记录的最近消息。</p><p>当您单击 “日志记录” 的链接时，将显示一个类似于下面的页面：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510199647643943.png" alt="Solr日志记录页面"></p><p>在上述的 Solr 日志记录界面中，包含了由客户端发送的错误文档导致的错误示例。</p><p>虽然本示例仅显示一个核心的记录消息，但如果您在单个实例中有多个核心，则它们将分别列出每个核心的级别。</p><h2 id="Solr-选择记录级别"><a href="#Solr-选择记录级别" class="headerlink" title="Solr 选择记录级别"></a>Solr 选择记录级别<a href="http://lucene.apache.org/solr/guide/7_0/logging.html#selecting-a-logging-level"></a></h2><p>当您选择左侧的 “级别” 链接时，您会看到您的实例的类路径和类名的层次结构。以黄色突出显示的行表示该类具有日志记录功能。点击突出显示的行，将出现一个菜单，允许您更改该类的日志级别。粗体中的字符表示该类不会受根级别更改的影响。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510199852203024.png" alt="Solr日志记录级别选择"></p><p>有关各种日志记录级别的说明，请参阅配置日志记录。</p><h1 id="Cloud界面"><a href="#Cloud界面" class="headerlink" title="Cloud界面"></a>Cloud界面</h1><p>在 SolrCloud 模式下运行时，“Cloud” 选项将会出现在 Logging 和 Collections / Core Admin之间的管理界面。</p><p>此 “Cloud” 界面提供了有关集群中每个集合和节点的状态信息，以及对存储在 ZooKeeper 中的低级别数据的访问。</p><pre><code>Tip：Cloud 界面只有在使用 SolrCloud 时才是可见的： “Cloud” 菜单选项仅在以 SolrCloud 模式运行的 Solr 实例上可用。Solr 的单节点或主/从复制实例不会显示此选项</code></pre><p>点击左侧导航栏中的 Cloud 选项，会出现一个小的子菜单，其中有 “Tree”、“Graph”、“Graph（Radial）” 和 “Dump” 选项。默认视图（“Graph”）显示每个集合的图形、组成这些集合的分片以及每个分片的每个副本的地址。</p><p>此示例显示使用 bin/solr -e cloud -noprompt 示例命令创建的非常简单的双节点群集。除了2个碎片、2个副本 “gettingstarted” 集合之外，还有一个额外的 “films” 集合，由单个碎片/副本组成：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510207216932368.png" alt="Cloud界面"></p><p>“Graph（Radial）” 选项为每个节点提供了不同的可视视图。使用相同的示例集群，径向图形视图如下所示：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510207242386832.png" alt="Cloud界面"></p><p>“Tree” 选项显示了 ZooKeeper 中数据的目录结构，包括关于 live_nodes 和 overseer 状态的集群信息，以及 state.json、当前分片前导集和所使用的配置文件等的集合特定信息。在这个例子中，我们看到为 “films” 集合定义的 state.json 文件：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510207268447263.png" alt="Cloud界面"></p><p>最后的选项是 “Dump”，它返回一个包含所有节点、它们的内容和子节点（递归）的 JSON 文档。这可以用来导出 Solr 保存在 ZooKeeper 中的所有数据的快照，并且可以帮助调试 SolrCloud 问题。</p><h1 id="Java属性界面"><a href="#Java属性界面" class="headerlink" title="Java属性界面"></a>Java属性界面</h1><p>“Java 属性”屏幕可以轻松访问最高性能的 Solr 系统中最重要的组件之一。使用 Java 属性屏幕，您可以看到运行 Solr 的 JVM 的所有属性，包括类路径、文件编码、JVM内存设置、操作系统等等。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510209150240927.png" alt="Java属性界面"></p><h1 id="Solr线程转储"><a href="#Solr线程转储" class="headerlink" title="Solr线程转储"></a>Solr线程转储</h1><p>Solr 的线程转储界面允许您检查服务器上当前活动的线程。</p><p>它将列出每个线程，并在适用的情况下访问堆栈跟踪（stacktraces）。在该线程界面中，左边的图标表示线程的状态：例如，绿色圆圈中带有绿色复选标记的线程处于 “RUNNABLE（可运行）” 状态。在线程名称的右侧，向下箭头表示您可以展开以查看该线程的堆栈跟踪。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510209648816880.png" alt="Solr线程列表"></p><p>当您将光标移到线程名称上时，一个框将浮动在该线程的状态名称上。线程状态可以是：</p><p>状态</p><p>含义</p><p>NEW</p><p>尚未开始的线程</p><p>RUNNABLE</p><p>在 Java 虚拟机中执行的线程</p><p>BLOCKED</p><p>被阻塞的线程正在等待显示器锁定</p><p>WAITING</p><p>无限期等待另一个线程执行特定操作的线程</p><p>TIMED_WAITING</p><p>正在等待另一个线程执行一个由指定的等待时间完成的操作的线程</p><p>TERMINATED</p><p>已退出的线程</p><p>当你点击一个可以扩展的线程时，你会看到堆栈跟踪，如下面的示例所示：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510210006390799.png" alt="Solr检查线程"></p><p>您还可以选中 “显示所有 Stacktraces（Show all Stacktraces）” 按钮以自动启用所有线程的扩展。</p><h1 id="Solr特定于集合的工具"><a href="#Solr特定于集合的工具" class="headerlink" title="Solr特定于集合的工具"></a>Solr特定于集合的工具</h1><p>在 Solr 的左侧导航栏中，您将看到一个名为“集合选择器”的下拉菜单，可用于访问集合特定的管理界面。</p><p>只有使用 SolrCloud 时才可见：“集合选择器”（Collection Selector）下拉菜单仅适用于以 SolrCloud 模式运行的 Solr 实例。Solr 的单节点或主/从复制实例将不会显示此菜单，而是在&nbsp;Core Selector（核心选择器）下拉菜单中提供本节中介绍的 Collection 专用 UI 页面。</p><p>单击“集合选择器”下拉菜单将显示 Solr 集群中的集合列表，其中包含可用于按名称查找特定集合的搜索框。当您从下拉列表中选择一个集合时，该页面的主要显示将显示关于该集合的一些基本元数据，而在左侧导航栏中将显示一个二级菜单项，其中包含指向其他集合特定管理屏幕的链接。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510210833916471.png" alt="Solr集合界面"></p><p>下面列出了特定于集合的 UI 界面，并链接到该指南的部分以了解更多信息：</p><ul><li>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-tc482fwu.html">分析界面</a> - 让您分析在特定字段中发现的数据。</li><li>  Dataimport&nbsp;- 向您显示有关数据导入处理程序当前状态的信息。</li><li>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-mco12fwz.html">文档界面</a> - 提供了一个简单的表单，允许您直接从浏览器执行各种 Solr 索引命令。</li><li>  文件&nbsp;- 显示当前的核心配置文件，如 solrconfig.xml。</li><li>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-kcas2fx9.html">查询界面</a> - 让您提交关于核心的各种元素的结构化查询。</li><li>  流&nbsp;- 允许您提交流表达式并查看结果和解析解释。</li><li>  模式浏览器&nbsp;- 在浏览器窗口中显示模式数据。<h1 id="Solr分析界面"><a href="#Solr分析界面" class="headerlink" title="Solr分析界面"></a>Solr分析界面</h1>通过 Solr 的“分析”界面，您可以根据模式中的字段、字段类型和动态字段配置来检查数据的处理方式。您可以分析在索引期间或在查询处理过程中如何处理内容，以及如何单独或同时查看结果。理想情况下，您需要一致地处理内容，并且此屏幕允许您验证字段类型或字段分析链中的设置。</li></ul><p>在屏幕顶部的一个或两个框中输入内容，然后选择用于分析的字段或字段类型定义。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510211496986072.png" alt="analysis_normal"></p><p>如果单击 “详细输出” 复选框，则您会看到更多信息，其中包括有关输入转换的更多详细信息（例如：转换为小写字母，带额外字符等），其中包括每个阶段的原始字节、类型和详细的位置信息。显示的信息将根据字段或字段类型的设置而变化。该过程的每个步骤都显示在一个单独的部分中，包含了应用在步骤中的标记器或过滤器的缩写。悬停或单击缩写，您将看到标记器或过滤器的名称和路径。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510211793153083.png" alt="analysis_verbose"></p><p>在上面的示例截图中，将几个转换应用于输入“Running is a sport”。“is” 和 “a” 这两个词已经被删除，“running” 这个词已更改为其基本形式 “run”。这是因为我们在这个场景中使用了字段类型 text_en，它被配置为删除停止单词（通常不提供大量上下文的小单词）和 “stem” 条件（如果可能的话）以找到更多可能的匹配（这是特别的有助于复数形式的单词）。如果单击“分析字段名称/字段类型（Analyze Fieldname/Field Type）”下拉菜单旁边的问号，将会打开 “模式浏览器” 窗口，显示指定字段的设置。</p><p>“理解分析器（&nbsp;Understanding Analyzers）”，“标记器（Tokenizers）” 和 “过滤器（Filters）”章节详细描述了每个选项的内容以及它如何转换您的数据以及“运行您的分析程序（&nbsp;Running Your Analyzer&nbsp;）”部分有特定的示例来使用分析界面。</p><h1 id="Solr文档界面"><a href="#Solr文档界面" class="headerlink" title="Solr文档界面"></a>Solr文档界面</h1><p>文档界面提供了一个简单的表单，允许您直接从浏览器以各种格式执行各种 Solr 索引命令。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510212466883330.png" alt="Solr文档界面"></p><p>Solr 文档界面允许您：</p><ul><li>  以 JSON、CSV 或 XML 格式复制文档并将其提交给索引；</li><li>  上传文件（使用 JSON、CSV 或 XML 格式）</li><li>  通过选择字段和字段值来构建文档</li></ul><p>还有一些其他的方法来加载数据，您可以参考下列章节：</p><ul><li><p>  使用索引处理程序上传数据</p></li><li><p>  使用 Apache Tika 上传 Solr Cell 数据</p></li></ul><p>第一步是定义 RequestHandler 以使用（aka，qt）。默认情况下 /update 会被定义。例如，要使用 Solr Cell，请将请求处理程序更改为 /update/extract。</p><p>然后选择“文档类型”来定义要加载的文档的类型。其余参数将根据所选的文件类型而改变。</p><h2 id="JSON-文档"><a href="#JSON-文档" class="headerlink" title="JSON 文档"></a>JSON 文档<a href="http://lucene.apache.org/solr/guide/7_0/documents-screen.html#json-documents"></a></h2><p>使用 JSON 文档类型时，其功能与在命令行上使用 requestHandler 类似。不是将文档放在 curl 命令中，而是将其输入到 “文档” 输入框中。文档结构仍应采用适当的 JSON 格式。</p><p>然后，您可以选择何时将文档添加到索引（Commit Within）中，以及是否应该用具有相同 ID 的传入文档覆盖现有文档（如果不是 true，则传入文档将被丢弃）。</p><p>这个选项只会添加或覆盖文件到索引中，对于其他更新任务，请参阅 Solr 命令选项。</p><h2 id="CSV-文档"><a href="#CSV-文档" class="headerlink" title="CSV 文档"></a>CSV 文档</h2><p>使用 CSV 文档类型时，其功能与在命令行上使用 requestHandler 类似。不是将文档放在 curl 命令中，而是将其输入到 “文档” 输入框中。文档结构仍然应该是正确的 CSV 格式：带有列分隔符和一行文档。</p><p>然后，您可以选择何时将文档添加到索引（Commit Within）中，以及是否应该用具有相同 ID 的传入文档覆盖现有文档（如果不是 true，则传入文档将被丢弃）。</p><h2 id="文档生成器"><a href="#文档生成器" class="headerlink" title="文档生成器"></a>文档生成器<a href="http://lucene.apache.org/solr/guide/7_0/documents-screen.html#document-builder"></a></h2><p>文档生成器提供了一个类似于向导的界面，用于输入文档的字段。</p><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>文件上传选项允许选择一个准备好的文件并将其上传。如果仅将 /update 选项用于请求处理程序，则您将被限制为 XML、CSV 和 JSON。</p><p>但是，要使用 ExtractingRequestHandler（又名 Solr Cell），您可以将 Request-Handler 修改为 /update/extract。您必须在您的 solrconfig.xml 文件中定义您所需的默认值。您还应该添加 &amp;literal.id，是其显示在“提取需求处理程序参数（Extracting Req. Handler Params）”字段中，以便选择的文件具有唯一的 ID。</p><p>然后，您可以选择何时将文档添加到索引（Commit Within）中，以及是否应该用具有相同 ID 的传入文档覆盖现有文档（如果不是 true，则传入文档将被丢弃）。</p><h2 id="Solr-命令"><a href="#Solr-命令" class="headerlink" title="Solr 命令"></a>Solr 命令<a href="http://lucene.apache.org/solr/guide/7_0/documents-screen.html#solr-command"></a></h2><p>Solr 命令选项允许您使用 XML 或 JSON 对文档执行特定的操作，例如定义要添加或删除的文档，只更新文档的某些字段，或提交和优化索引上的命令。</p><p>这些文档的结构应该像 /update 在命令行中使用一样。</p><h2 id="XML-文档"><a href="#XML-文档" class="headerlink" title="XML 文档"></a>XML 文档<a href="http://lucene.apache.org/solr/guide/7_0/documents-screen.html#xml-documents"></a></h2><p>使用 XML 文档类型时，其功能与在命令行上使用 requestHandler 类似。不是将文档放在 curl 命令中，而是将其输入到 “文档” 输入框中。文档结构仍应采用适当的 Solr XML 格式，每个文档由 <doc> 标签分隔，并且每个字段被定义。</doc></p><p>然后，您可以选择何时将文档添加到索引（Commit Within）中，以及是否应该用具有相同 ID 的传入文档覆盖现有文档（如果不是 true，则传入文档将被丢弃）。</p><p>这个选项只会添加或覆盖文件到索引；对于其他更新任务，请参阅 Solr 命令选项。</p><h1 id="Solr查询界面"><a href="#Solr查询界面" class="headerlink" title="Solr查询界面"></a>Solr查询界面</h1><p>您可以使用查询界面将搜索查询提交给 Solr 集合并分析结果。</p><p>在下面截图中的例子中，查询已经被提交，并且界面显示了作为 JSON 形式发送到浏览器的查询结果。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510214747366399.png" alt="Solr查询的JSON结果"></p><p>在这个例子中，genre:Fantasy 的查询被发送到 “films” 集合。表单中的所有其他选项都使用了默认值，下表中对此进行了简要介绍，本指南的后面部分将对此进行详细介绍。</p><p>该响应显示在窗体的右侧。对 Solr 的请求只是简单的 HTTP 请求，而提交的查询在结果的上方以浅色显示；如果您点击它，它将打开一个新的浏览器窗口，只有这个请求和响应（没有 Solr 管理界面的其余部分）。其余的响应以 JSON 格式显示，这是默认的输出格式。</p><p>响应至少有两个部分，但可能还有其他几个部分，具体取决于所选的选项。它的两个部分始终是 responseHeader 和 response。responseHeader 包括搜索状态（status），处理时间（QTime）和参数（params 即用于处理查询）。</p><p>response（响应）与查询匹配的文档，在 doc 小节中。字段返回取决于查询的参数（以及所使用的请求处理程序的默认值）。结果的数量也包括在本节中。</p><p>此屏幕允许您尝试使用不同的查询选项，并检查文档的索引方式。表单上可用的查询参数是大多数用户想要获得的一些基本选项，但是还有几十个可用的参数可以简单地添加到基本请求中（如果在浏览器中打开的话）。以下参数可用：</p><p>Request-handler（qt）：指定请求的查询处理程序。如果未指定查询处理程序，则 Solr 会使用标准查询处理程序处理响应。</p><p>q：查询事件。请参阅搜索此参数的说明。</p><p>FQ：筛选器查询。有关此参数的更多信息，请参阅常见查询参数。</p><p>sort：根据响应的分数或其他指定的特性，按升序或降序对查询进行响应排序。</p><p>start，rows：<code>start</code>是从哪个文档返回的查询结果的偏移量。默认值是 0，这意味着查询应返回从第一个匹配的文档开始的结果。该字段接受与搜索中描述的开始查询参数相同的语法。<code>rows</code>是要返回的行数。</p><p>FL：定义要为每个文档返回的字段。您可以通过用逗号或空格分隔列出您想要返回的存储字段、函数和 doc 转换器。</p><p>wt：指定用于格式化查询响应的响应书写器。如果未指定，则默认为 JSON。</p><p>indent：单击此按钮以请求响应编写器使用缩进使响应更具可读性。</p><p>debugQuery：点击这个按钮来增加带有调试信息的查询响应，包括返回的每个文档的“解释信息”。这个调试信息旨在让管理员或程序员理解。</p><p>dismax：单击此按钮启用 Dismax 查询解析器。有关更多信息，请参阅 DisMax Query Parser。</p><p>edismax：单击此按钮可启用扩展查询解析器。有关更多信息，请参阅扩展 DisMax 查询解析器。</p><p>HL：点击此按钮可以在查询响应中启用突出显示。请参阅突出显示了解更多信息。</p><p>facet：启用 facet，将搜索结果的排列方式设置为基于索引项的类别。有关详细信息，请参阅 facet。</p><p>spatial：点击以启用在空间或地理空间搜索中使用的位置数据。请参阅空间搜索以获取更多信息。</p><p>spellcheck：点击此按钮启用拼写检查程序，它根据其他类似的术语提供了内联查询建议。请参阅拼写检查以获取更多信息。</p><h1 id="Solr管理界面：架构浏览器"><a href="#Solr管理界面：架构浏览器" class="headerlink" title="Solr管理界面：架构浏览器"></a>Solr管理界面：架构浏览器</h1><p>使用 Solr 架构浏览器界面，您可以在浏览器窗口中查看架构数据。</p><p>如果您从分析界面访问了此窗口，则它将打开到特定字段、动态字段规则或字段类型。如果未选择任何选项，请使用下拉菜单选择字段或字段类型。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171110/1510292678810840.png" alt="Solr架构浏览器界面"></p><p>架构浏览器界面提供了有关 Schema 中每个特定字段和字段类型的大量有用信息，并提供了使用 Schema API（如果已启用）添加字段或字段类型的快速 UI&nbsp;。在上面的例子中，我们选择了这个 cat 字段。在主视图窗口的左侧，我们看到字段名称，它被复制到_text_（由于copyField规则），并使用 strings 字段类型。单击这些字段或字段类型名称之一，您可以看到相应的定义。</p><p>在主视图的右侧部分，我们看到 cat 字段定义的具体属性- 通过字段类型显式或隐式地定义，以及填充此字段的文档数量。然后我们看到用于索引和查询处理的分析器。点击其中任何一个的左侧的图标，您将看到所使用的标记化器和/或过滤器的定义。这些过程的输出是在<a href="https://www.w3cschool.cn/solr_doc/solr_doc-tc482fwu.html">分析界面</a>上测试特定字段的内容处理方式时所看到的信息。</p><p>在分析器信息下是一个按钮，您可以使用它来加载术语信息。单击该按钮将显示该字段的示例分片中的前 N 个项，以及显示具有各种频率的项的数量的直方图。点击一个术语，你将被带到<a href="https://www.w3cschool.cn/solr_doc/solr_doc-kcas2fx9.html">查询界面</a>查看该字段中该术语的查询结果。如果要始终查看某个字段的术语信息，请选择“&nbsp;自动加载”，并且在字段有术语时将始终显示。直方图显示了字段中具有给定频率的项的数量。</p><h1 id="Solr界面管理：流界面"><a href="#Solr界面管理：流界面" class="headerlink" title="Solr界面管理：流界面"></a>Solr界面管理：流界面</h1><p>Solr 流界面允许您输入流式表达式并查看结果。它与查询屏幕非常相似，不同的是输入框位于顶部，所有选项必须在表达式中声明。</p><p>该界面会将所有内容插入到流式表达式本身，因此您不需要输入带有主机名、端口、集合等的完整 URI。只需在<code>expr=</code>&nbsp;part 之后输入表达式，URL 就会根据需要动态构建。</p><p>在输入框下，执行按钮将运行表达式。“with explanation” 选项将显示已执行的流式表达的各个部分。在此之下，将显示流式结果。也可以在浏览器中查看输出的 URL。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171111/1510381514593380.png" alt="Solr管理界面"></p><h1 id="Solr核心专用工具"><a href="#Solr核心专用工具" class="headerlink" title="Solr核心专用工具"></a>Solr核心专用工具</h1><p>Solr 特定于核心的工具是一组 UI 界面，允许您查看核心级别的信息。</p><p>在左侧的导航栏中，您将看到一个名为“核心选择器（Core Selector）”的下拉菜单。单击该菜单将显示此 Solr 节点上托管的 Solr 核心列表，其中包含可用于按名称查找特定核心的搜索框。</p><p>当您从下拉列表中选择一个核心时，页面的主要显示将显示关于核心的一些基本元数据，而在左侧导航栏中将出现一个二级菜单，其中包含指向其他核心特定管理屏幕的链接。</p><p>您还可以定义一个名为 admin-extra.html 的配置文件，其中包含您希望在此主界面的 “Admin Extra” 部分中显示的链接或其他信息。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510216957612427.png" alt="Solr核心界面概览"></p><p>下面列出了特定于核心的 UI 界面，并提供了指向本指南部分的链接以了解更多内容：</p><ul><li><p>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-l6u92fxe.html">Ping</a>&nbsp;- 让您 ping 一个已命名的核心，并确定核心是否处于活动状态。</p></li><li><p>  插件/统计（Plugins/Stats）&nbsp;- 显示插件和其他已安装组件的统计信息。</p></li><li><p>  复制（Replication）&nbsp;- 显示核心的当前复制状态，并允许您启用/禁用复制。</p></li><li><p>  段信息（Segments Info）&nbsp;- 提供底层 Lucene 索引段的可视化。</p></li></ul><p>如果您正在运行 Solr 的单个节点实例，则通常在每个集合基础上显示的其他 UI 界面也将被列出：</p><ul><li><p>  分析（Analysis）&nbsp;- 让您分析在特定字段中找到的数据。</p></li><li><p>  导入（Dataimport）&nbsp;- 显示有关数据导入处理程序的当前状态的信息。</p></li><li><p>  文档（Documents）&nbsp;- 提供了一个简单的表单，允许您直接从浏览器执行各种 Solr 索引命令。</p></li><li><p>  文件（Files）&nbsp;- 显示当前的核心配置文件，如：solrconfig.xml。</p></li><li><p>  查询（Query）&nbsp;- 让您提交关于核心的各种元素的结构化查询。</p></li><li><p>  流（Stream）&nbsp;- 允许您提交流表达式并查看结果和解析解释。</p></li><li><p>  模式浏览器（Schema&nbsp;Browser）&nbsp;- 在浏览器窗口中显示架构数据。</p><h1 id="使用Ping请求"><a href="#使用Ping请求" class="headerlink" title="使用Ping请求"></a>使用Ping请求</h1><p>在核心名称下选择 Ping 会发出一个 ping 请求来检查核心是否启动并响应请求。</p></li></ul><p><img src="https://atts.w3cschool.cn/attachments/image/20171109/1510217589638867.png" alt="Solr核心下拉菜单中的Ping选项"></p><p>由 Ping 执行的搜索是使用请求参数 API 进行配置的。请参阅 Implicit RequestHandlers，以了解用于 /admin/ping 端点的参数集。</p><p>Ping 选项不打开页面，但是在点击集合名称时显示的核心概览页面上可以看到请求的状态。请求的时间长度显示在 Ping 选项旁边，以毫秒为单位。</p><h2 id="API-示例"><a href="#API-示例" class="headerlink" title="API 示例"></a>API 示例<a href="http://lucene.apache.org/solr/guide/7_0/ping.html#api-examples"></a></h2><p>虽然在 UI 界面上可以很容易地看到 ping 响应时间，但是当由远程监视工具执行时，底层 ping 命令会更加有用：</p><p>输入如下：</p><pre><code>http://localhost:8983/solr/&lt;core-name&gt;/admin/ping</code></pre><p>这个命令将 ping 一个响应的核心名称。</p><p>输入如下：</p><pre><code>http://localhost:8983/solr/&lt;collection-name&gt;/admin/ping?distrib=true</code></pre><p>此命令将为响应 ping 给定集合名称的所有副本。</p><p>示例输出：</p><pre><code>&lt;response&gt;   &lt;lst name="responseHeader"&gt;      &lt;int name="status"&gt;0&lt;/int&gt;      &lt;int name="QTime"&gt;13&lt;/int&gt;      &lt;lst name="params"&gt;         &lt;str name="q"&gt;{!lucene}*:*&lt;/str&gt;         &lt;str name="distrib"&gt;false&lt;/str&gt;         &lt;str name="df"&gt;_text_&lt;/str&gt;         &lt;str name="rows"&gt;10&lt;/str&gt;         &lt;str name="echoParams"&gt;all&lt;/str&gt;      &lt;/lst&gt;   &lt;/lst&gt;   &lt;str name="status"&gt;OK&lt;/str&gt;&lt;/response&gt;</code></pre><p>这两个 API 调用都有相同的输出。status=OK 表示节点正在响应。</p><p>SolrJ 示例：</p><pre><code>SolrPing ping = new SolrPing();ping.getParams().add("distrib", "true"); //To make it a distributed request against a collectionrsp = ping.process(solrClient, collectionName);int status = rsp.getStatus();</code></pre><h1 id="Solr管理界面：插件和统计"><a href="#Solr管理界面：插件和统计" class="headerlink" title="Solr管理界面：插件和统计"></a>Solr管理界面：插件和统计</h1><p>Solr 插件界面显示有关每个 Solr 内核中运行的各种插件的状态和性能的信息和统计信息。您可以找到有关 Solr 高速缓存的性能，Solr 搜索者的状态以及请求处理程序和搜索组件配置的信息。</p><p>在右侧选择一个感兴趣的区域，然后通过单击窗口中央部分出现的名称来深入了解更多细节。在这个例子中，我们选择了从核心区域查看搜索数据：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171110/1510293579311950.png" alt="Solr管理界面"></p><p>该显示是在页面加载时拍摄的快照。您可以通过选择 “观察更改” 或 “刷新值” 来获取更新的状态。观察这些更改将突出显示已更改的区域，而刷新值将使用更新的信息重新加载页面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>solr参考指南（入门）</title>
      <link href="/2019/12/25/solr-can-kao-zhi-nan-ru-men/"/>
      <url>/2019/12/25/solr-can-kao-zhi-nan-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="关于本指南"><a href="#关于本指南" class="headerlink" title="关于本指南"></a>关于本指南</h2><p>本指南介绍了 Apache Solr 的所有重要特性和功能。</p><p>您可以从&nbsp;<a href="http://lucene.apache.org/solr/">http://lucene.apache.org/solr/</a>&nbsp;免费下载 Solr。</p><p>本指南旨在让您更了解 Solr。该指南的结构是满足广泛学习用户的需求，从新的开发人员开始到经验丰富的开发人员扩展他们的应用程序或故障排除。它将在应用程序生命周期的任何时候使用，只要您需要有关 Solr 的任何信息。</p><p>本教程中所提供的材料假设您熟悉一些基本的搜索概念，并且您可以阅读 XML，您不需要是一名专业的 Java 程序员，尽管 Java 的知识在直接使用 lucene 或在开发 lucene/Solr 安装的自定义扩展时很有用。</p><h2 id="主机和端口示例"><a href="#主机和端口示例" class="headerlink" title="主机和端口示例"></a>主机和端口示例<a href="http://lucene.apache.org/solr/guide/7_0/about-this-guide.html#hosts-and-port-examples"></a></h2><p>运行 Solr 时的默认端口为 8983。本指南中的示例、URL 和屏幕截图可能会显示在不同的端口，因为 Solr 使用的端口号是可配置的。</p><p>如果您尚未自定义 Solr 的安装，请确保在执行以下示例时使用端口 8983，或配置您自己的安装以使用示例中显示的端口号。有关配置端口号的信息，请您参阅 “管理Solr” 一节。</p><p>类似地，URL 示例始终使用本地主机&nbsp;localhost；如果您要从远程访问 solr 的服务器所在的位置进行存取，请将 localhost 替换为 solr 正在运行的适当域或 IP。</p><p>例如，我们可以提供一个示例查询，如：</p><pre><code>http://localhost:8983/solr/gettingstarted/select?q=brown+cow</code></pre><p>您可能需要在本地更改此 URL 中的几个项目。首先，如果您的服务器运行在 “<a href="http://www.example.com”/">www.example.com”</a> 上，您将用适当的域替换 “localhost”。如果您没有使用端口8983，那么您也可以替换它。最后，您将希望将“gettingstarted”(集合或核心名称)替换为在实现中使用的适当名称。URL 将会变成：</p><pre><code>http://www.example.com/solr/mycollection/select?q=brown+cow</code></pre><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径<a href="http://lucene.apache.org/solr/guide/7_0/about-this-guide.html#paths"></a></h2><p>路径信息是相对于 solr.home 给出的，它是 solr 的主要安装位置，solr 的集合及其 conf 和 data 目录都存储在这里。</p><p>当运行本教程中提到的各种示例（即，bin/solr -e techproducts），solr.home 将是为您自动创建的 example/ 创建的子目录。</p><h1 id="Solr入门"><a href="#Solr入门" class="headerlink" title="Solr入门"></a>Solr入门</h1><p>Solr 使程序员能够轻松地开发具有高级功能的复杂、高性能的搜索应用程序。它是一个独立的企业级搜索应用服务器，它对外提供 API 接口。用户可以通过 HTTP 请求或者使用 Http Get 提出查找请求。</p><p>本部分将介绍基本的 Solr 体系结构和功能，以帮助您快速启动和运行 Solr。它将涵盖以下主题：</p><ul><li><p>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-xcdq2fly.html">快速概述</a>：关于 Solr 工作方式的高级概述。</p></li><li><p>  <a href="https://www.w3cschool.cn/solr_doc/solr_doc-ltzn2fm4.html">安装 Solr</a>：Solr 安装过程的演练。</p></li><li><p>  Solr 配置文件：安装布局和主要配置文件概述。</p></li><li><p>  Solr 升级说明：有关 Solr 发行版中所做更改的信息。</p></li><li><p>  采用 Solr 进行生产：帮助您将 Solr 安装为服务并将应用程序应用于生产的详细步骤。</p></li><li><p>  升级 Solr 集群：用于升级生产 SolrCloud 集群的信息。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">Tip：Solr 包括一个快速入门教程，如果您刚刚开始使用 Solr，这将对您有所帮助。您可以在本指南中的 Solr 快速教程中找到它。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Solr快速概述"><a href="#Solr快速概述" class="headerlink" title="Solr快速概述"></a>Solr快速概述</h1><p>Solr 是一个基于 Apache Lucene 之上的搜索服务器，它是一个开源的、基于 Java 的信息检索库。它旨在驱动功能强大的文档检索应用程序 - 无论您需要根据用户的查询将数据服务到何处，Solr 都可以为您服务。</p><p>下面是一个如何将 Solr 集成到应用程序中的示例：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171103/1509691910631328.png" alt="Solr与应用程序的集成"></p><p>在上述情况下，Solr 与其他服务器应用程序并行运行。例如，在线商店应用程序将提供用户界面、购物车以及为最终用户购买的方式；而库存管理应用程序将允许商店员工编辑产品信息。产品元数据将保存在某种数据库以及 Solr 中。</p><p>Solr 可以通过以下步骤轻松地添加在在线商店搜索的功能：</p><ol><li><p> 定义一个模式。该模式告诉 Solr 关于它将被索引的文档的内容。在在线商店的示例中，模式将定义产品名称、描述、价格、制造商等定义的字段。Solr 的模式是强大而灵活的，可以让您根据自己的应用程序定制 Solr 的行为。有关详细信息，请参阅文档、字段和模式设计。</p></li><li><p> 您的用户将搜索的 Feed&nbsp;Solr 文档。</p></li><li><p> 在您的应用程序中公开搜索功能。</p></li></ol><p>因为 Solr 是基于开放标准的，所以它是高度可扩展的。Solr 查询是简单的 HTTP 请求 URL，响应是一个结构化文档：主要是 JSON，但也可以是 XML、CSV 或其他格式。这意味着各种各样的客户端将能够使用 Solr，从其他 Web 应用程序到浏览器客户端、丰富的客户端应用程序和移动设备。任何能够使用 HTTP 的平台都可以与 Solr 对话。有关客户端 API 的详细信息，请参阅客户端 API。</p><p>Solr 提供了对多个字段和多面搜索结果的复杂查询的最简单关键字搜索支持。搜索具有更多关于搜索和查询的详细信息。</p><p>如果 Solr 的功能还不够令人印象深刻，那么它处理非常高容量应用程序的能力就应该发挥出来。</p><p>一个相对常见的情况是，您有太多数据或者有许多查询，以至于单个 Solr 服务器无法处理您的整个工作负载。在这种情况下，您可以使用 SolrCloud 扩展应用程序的功能，以便在多个服务器之间更好地分发数据和处理请求。可以根据您需要的可扩展性的类型，混合和匹配多个选项。</p><p>例如：“Sharding” 是一种缩放技术，其中集合被拆分成多个称为“碎片（shards）”的逻辑片段，以便将集合中的文档数量扩展到超过单个服务器上的物理数量。收集的查询将分发到集合中的每个碎片，并通过合并结果进行响应。另一种可用的方法是增加集合的“复制因子”，这使您可以通过将请求扩展到多台计算机，来添加具有集合的额外副本的服务器，以处理更高的并发查询负载。切分和复制不是相互排斥的，&nbsp;它共同使 Solr 成为一个非常强大和可伸缩的平台。</p><p>最重要的是，这个关于大容量应用程序的讨论不仅是假设性的：一些使用 Solr 的著名互联网网站是：Macy’s、EBay 和 Zappo。</p><p>有关更多示例，请查看：<a href="https://wiki.apache.org/solr/PublicServers%E3%80%82">https://wiki.apache.org/solr/PublicServers。</a></p><h1 id="Solr系统要求"><a href="#Solr系统要求" class="headerlink" title="Solr系统要求"></a>Solr系统要求</h1><p>您可以在任何系统中安装 Solr，但是这些系统中必须有适用的 Java 运行时环境（JRE），具体介绍如下文所述。</p><p>目前，这包括 Linux，MacOS / OS X 和 Microsoft Windows。</p><h2 id="Solr-安装要求"><a href="#Solr-安装要求" class="headerlink" title="Solr 安装要求"></a>Solr 安装要求<a href="http://lucene.apache.org/solr/guide/7_0/solr-system-requirements.html#installation-requirements"></a></h2><h3 id="Java-要求"><a href="#Java-要求" class="headerlink" title="Java 要求"></a>Java 要求<a href="http://lucene.apache.org/solr/guide/7_0/solr-system-requirements.html#java-requirements"></a></h3><p>您将需要 1.8 或更高版本的 Java 运行时环境（JRE）。在命令行中，检查您的 Java 版本，如下所示：</p><pre><code>$ java -versionjava version "1.8.0_60"Java(TM) SE Runtime Environment (build 1.8.0_60-b27)Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)</code></pre><p>确切的输出将会有所不同，但您需要确保符合最低版本要求。我们还建议您从供应商那里选择一种可以使用的版本。Oracle 或 OpenJDK 是经过最多测试的 JRE，建议您可以使用它们。我们还建议您尽可能使用最新的官方版本。</p><p>某些版本的 Java VM 有可能影响您的实现的错误。为确保，请查看 Lucene JavaBugs 页面。</p><p>如果您没有所需的版本，或者未找到 java 命令，请从 Oracle 的 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> 下载并安装最新版本。</p><h3 id="支持的操作系统"><a href="#支持的操作系统" class="headerlink" title="支持的操作系统"></a>支持的操作系统<a href="http://lucene.apache.org/solr/guide/7_0/solr-system-requirements.html#supported-operating-systems"></a></h3><p>Solr 在 Linux、MacOS 和 Windows 的几个版本上进行了测试，您可以使用它们。</p><h1 id="安装Solr"><a href="#安装Solr" class="headerlink" title="安装Solr"></a>安装Solr</h1><p>您如果要在 Unix 兼容或 Windows 服务器上安装 Solr，通常只需简单地提取（或解压缩）下载包。</p><p>请您务必在启动 Solr 之前查看<a href="https://www.w3cschool.cn/solr_doc/solr_doc-qpc52fm3.html">Solr系统要求</a>一节。</p><h2 id="可用-Solr-软件包"><a href="#可用-Solr-软件包" class="headerlink" title="可用 Solr 软件包"></a>可用 Solr 软件包<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#available-solr-packages"></a></h2><p>Solr 可从 Solr 网站获取。您可以在此下载最新版本的 Solr：<a href="https://lucene.apache.org/solr/mirrors-solr-latest-redir.html">https://lucene.apache.org/solr/mirrors-solr-latest-redir.html</a>。</p><p>Solr 有三个独立的软件包：</p><ul><li>  solr-7.0.0.tgz：适用于 Linux / Unix / OSX 系统</li><li>  solr-7.0.0.zip：适用于 Microsoft Windows 系统</li><li>  solr-7.0.0-src.tgz：Solr 源代码包。如果您想在 Solr 上开发而不使用官方的 Git 存储库，这将非常有用。</li></ul><h2 id="准备安装-Solr"><a href="#准备安装-Solr" class="headerlink" title="准备安装 Solr"></a>准备安装 Solr<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#preparing-for-installation"></a></h2><p>当您开始使用 Solr 时，您需要做的就是将 Solr 发行档案解压到您选择的目录中。这将足以作为一个最初的开发环境，但在设置真正的开发和生产环境之前，请注意不要太过关注 “toy” 安装。</p><p>当您已经完成了对 Solr 的初始评估后，您需要注意计划您的实施。您可能需要在另一台服务器上重新安装 Solr 或制作集群化的 SolrCloud 环境。</p><p>当您准备好为生产环境安装&nbsp;Solr 时，请参阅 “使用 Solr 到生产” 页面上提供的说明。</p><blockquote><p>Tip：我需要什么大小的服务器？<br>如何确定 Solr 安装的大小是一个复杂的问题, 它依赖于许多因素, 包括文档的数量和结构、您打算存储的字段数量、用户数等。</p><p>强烈建议您花点时间考虑一下影响您的 Solr 实现的硬件大小的因素。一个非常好的博客文章, 讨论该考虑的问题的一个博客文章是：在抽象中调整硬件: <a href="https://lucidworks.com/2012/07/23/sizing-hardware-in-the-abstract-why-we-dont-have-a-definitive-answer/">为什么我们没有一个明确的答案</a>。</p></blockquote><h2 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#package-installation"></a></h2><p>为了保持现在的简单的方式，请将 Solr 分发存档解压缩到您的本地主目录，例如在 Linux 上，请执行以下操作：</p><pre><code>cd ~/tar zxf solr-7.0.0.tgz</code></pre><p>一旦解压缩，您现在就可以使用下面的 “启动 Solr” 部分提供的说明运行 Solr 了。</p><h2 id="目录布局"><a href="#目录布局" class="headerlink" title="目录布局"></a>目录布局</h2><p>安装 Solr 之后，您将会看到以下的目录和文件：</p><ul><li><p>bin</p><p>  此目录中包含几个重要的脚本，这些脚本将使使用 Solr 更容易。</p><ul><li><p>solr 和 solr.cmd</p><p>  这是Solr 的控制脚本，也称为<code>bin/solr</code>（对于 * nix）或者<code>bin/solr.cmd</code>（对于 Windows）。这个脚本是启动和停止 Solr 的首选工具。您也可以在运行 SolrCloud 模式时创建集合或内核、配置身份验证以及配置文件。</p></li><li><p>post</p><p>  Post Tool，它提供了用于发布内容到 Solr 的一个简单的命令行界面。</p></li><li><p>solr.in.sh 和 solr.in.cmd</p><p>  这些分别是为 * nix 和 Windows 系统提供的属性文件。在这里配置了 Java、Jetty 和 Solr 的系统级属性。许多这些设置可以在使用<code>bin/solr</code>或者<code>bin/solr.cmd</code>时被覆盖，但这允许您在一个地方设置所有的属性。</p></li><li><p>install_solr_services.sh</p><p>  该脚本用于 * nix 系统以安装 Solr 作为服务。在&nbsp;“将Solr用于生产&nbsp;” 一节中有更详细的描述。</p></li></ul></li><li><p>contrib</p><p>  Solr 的<code>contrib</code>目录包含 Solr 专用功能的附加插件。</p></li><li><p>dist</p><p>  该<code>dist</code>目录包含主要的 Solr .jar 文件。</p></li><li><p>docs</p><p>  该<code>docs</code>目录包括一个链接到在线 Javadocs 的 Solr。</p></li><li><p>example</p><p>  该<code>example</code>目录包括演示各种 Solr 功能的几种类型的示例。有关此目录中的内容的详细信息，请参阅下面的 Solr 示例。</p></li><li><p>licenses</p><p>  该<code>licenses</code>目录包括 Solr 使用的第三方库的所有许可证。</p></li><li><p>server</p><p>  此目录是 Solr 应用程序的核心所在。此目录中的 README 提供了详细的概述，但以下是一些特点：</p><ul><li><p>  Solr 的 Admin UI（<code>server/solr-webapp</code>）</p></li><li><p>  Jetty 库（<code>server/lib</code>）</p></li><li><p>  日志文件（<code>server/logs</code>）和日志配置（<code>server/resources</code>）。有关如何自定义 Solr 的默认日志记录的详细信息，请参阅配置日志记录一节。</p></li><li><p>  示例配置（<code>server/solr/configsets</code>）</p></li></ul></li></ul><h2 id="Solr-示例"><a href="#Solr-示例" class="headerlink" title="Solr 示例"></a>Solr 示例</h2><p>Solr 包括许多在开始时使用的示例文档和配置。如果您运行了 Solr 教程，您已经与这些文件中的某些文件进行了互动。</p><p>以下是 Solr 包含的示例：</p><ul><li><p>exampledocs</p><p>  这是一系列简单的 CSV、XML 和 JSON 文件，可以在首次使用 Solr 时使用<code>bin/post</code>。有关和这些文件一起使用<code>bin/post</code>的更多信息，请参阅 Post 工具。</p></li><li><p>example-DIH</p><p>  此目录包含一些 DataImport Handler（DIH）示例，可帮助您开始在数据库、电子邮件服务器甚至 Atom 提要中导入结构化内容。每个示例将索引不同的数据集；有关这些示例的更多详细信息，请参阅 README。</p></li><li><p>files</p><p>  该<code>files</code>目录为您提供了一个基本的搜索 UI，可以用于文档（例如 Word 或 PDF），您可能已经存储在本地。有关如何使用此示例的详细信息，请参阅README。</p></li><li><p>films</p><p>  该<code>films</code>目录包含一组关于电影的强大数据，包括三种格式：CSV、XML 和 JSON。有关如何使用此数据集的详细信息，请参阅 README。</p></li></ul><h2 id="启动-Solr"><a href="#启动-Solr" class="headerlink" title="启动 Solr"></a>启动 Solr<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#starting-solr"></a></h2><p>Solr 包括一个名为 bin/solr（对于Linux / MacOS系统）或者 bin\solr.cmd（对于 Windows 系统）的命令行界面工具。此工具允许您启动和停止 Solr、创建核心和集合、配置身份验证和检查系统的状态。</p><p>要使用它来启动 Solr，您只需输入：</p><pre><code>bin/solr start</code></pre><p>如果您正在运行 Windows，则可以通过运行 bin \ solr 来启动 Solr。</p><pre><code>bin\solr.cmd start</code></pre><p>这将在后台启动 Solr，监听端口 8983。</p><p>当您在后台启动 Solr 时，脚本将等待确认 Solr 在正确启动后再返回到命令行提示符。</p><pre><code>Tip：Solr CLI 的所有选项都在 "Solr 控制脚本参考" 部分中介绍。</code></pre><h3 id="使用特定捆绑示例启动-Solr"><a href="#使用特定捆绑示例启动-Solr" class="headerlink" title="使用特定捆绑示例启动 Solr"></a>使用特定捆绑示例启动 Solr<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#start-solr-with-a-specific-bundled-example"></a></h3><p>Solr 还提供了一些有用的例子来帮助您了解主要功能。您可以使用该 -e 标志启动这些示例。例如，要启动&nbsp;“techproducts”&nbsp;示例，您可以执行以下操作：</p><pre><code>bin/solr -e techproducts</code></pre><p>目前，您可以运行的可用示例是：techproducts、dih、schemaless 和 cloud。有关每个示例的详细信息，请参阅运行示例配置一节。</p><pre><code>Note：SolrCloud 入门：运行 cloud 示例以 SolrCloud 模式启动 Solr。有关在 cloud 模式下启动 Solr 的更多信息，请参阅“SolrCloud入门”部分。</code></pre><h3 id="检查-Solr-是否正在运行"><a href="#检查-Solr-是否正在运行" class="headerlink" title="检查 Solr 是否正在运行"></a>检查 Solr 是否正在运行</h3><p>如果您不确定 Solr 是否在本地运行，则可以使用 status 命令：</p><pre><code>bin/solr status</code></pre><p>这将搜索在您的计算机上运行的 Solr 实例，然后收集有关它们的基本信息，如版本和内存使用情况。</p><p>Solr 正在运行。如果您需要有说服力的证明，请使用 Web 浏览器查看管理控制台：<a href="http://localhost:8983/solr/">http://localhost:8983/solr/</a></p><p><img src="https://atts.w3cschool.cn/attachments/image/20171103/1509697683443398.png" alt="Solr管理界面"></p><p>如果 Solr 未运行，您的浏览器将提示无法连接到服务器。请检查您的端口号，然后进行重试。</p><h3 id="创建核心"><a href="#创建核心" class="headerlink" title="创建核心"></a>创建核心<a href="http://lucene.apache.org/solr/guide/7_0/installing-solr.html#create-a-core"></a></h3><p>如果您没有使用示例配置启动 Solr，则需要创建一个核心才能进行索引和搜索。您可以运行以下操作：</p><pre><code>bin/solr create -c &lt;name&gt;</code></pre><p>这将创建一个使用数据驱动模式的核心，当您将文档添加到索引时，该模式会尝试猜测正确的字段类型。</p><p>要查看创建新核心的所有可用选项，请执行以下操作：</p><pre><code>bin/solr create -help</code></pre><h1 id="Solr配置文件"><a href="#Solr配置文件" class="headerlink" title="Solr配置文件"></a>Solr配置文件</h1><p>在 Solr 中有几个配置文件，您将在执行过程中与之交互。</p><p>这些文件中的很多都是 XML 格式的，尽管与配置设置交互的 API 在需要时往往接受 JSON 以进行编程访问。</p><h2 id="Solr-Home"><a href="#Solr-Home" class="headerlink" title="Solr Home"></a>Solr Home<a href="http://lucene.apache.org/solr/guide/7_0/solr-configuration-files.html#solr-home"></a></h2><p>在运行 Solr 时，您需要访问主目录。</p><p>当您第一次安装 Solr 时，您的主目录是：server/solr。但是，一些示例可能会更改此位置（例如，如果您运行：bin/solr start -e cloud，您的主目录将会是：example/cloud）。</p><p>Solr 主目录包含重要的配置信息，并且是 Solr 将存储其索引的地方。当您在独立模式下与在 SolrCloud 模式下运行 Solr&nbsp;时，主目录的布局看起来会有所不同。</p><p>以下示例显示了 Solr 主目录中的关键部分：</p><h3 id="示例-独立模式"><a href="#示例-独立模式" class="headerlink" title="示例-独立模式"></a>示例-独立模式</h3><pre><code>&lt;solr-home-directory&gt;/   solr.xml   core_name1/      core.properties      conf/         solrconfig.xml         managed-schema      data/   core_name2/      core.properties      conf/         solrconfig.xml         managed-schema      data/</code></pre><h3 id="示例-SolrCloud-模式"><a href="#示例-SolrCloud-模式" class="headerlink" title="示例-SolrCloud 模式"></a>示例-SolrCloud 模式</h3><pre><code>&lt;solr-home-directory&gt;/   solr.xml   core_name1/      core.properties      data/   core_name2/      core.properties      data/</code></pre><p>您可能会看到其他文件，但您需要了解的主要部分将在下一节中讨论。</p><h2 id="Solr-配置文件"><a href="#Solr-配置文件" class="headerlink" title="Solr 配置文件"></a>Solr 配置文件</h2><p>在 Solr 的主页中，你会发现这些文件：</p><ul><li>  solr.xml：为您的 Solr 服务器实例指定配置选项。有关 solr.xml&nbsp;的更多信息，请参阅：Solr Cores 和 solr.xml。</li><li>每个 Solr 核心：<ul><li>  core.properties：为每个核心定义特定的属性，例如其名称、核心所属的集合、模式的位置以及其他参数。有关 core.properties 的更多详细信息，请参阅定义 core.properties 一节。</li><li>  solrconfig.xml：控制高级行为。例如，您可以为数据目录指定一个备用位置。有关 solrconfig.xml 的更多信息，请参阅 配置 solrconfig.xml。</li><li>  managed-schema（或用 schema.xml 替代）描述您将要求 Solr 索引的文档。模式将文档定义为字段集合。您可以同时定义字段类型和字段本身。字段类型定义功能强大，包含有关 Solr 如何处理传入字段值和查询值的信息。有关 Solr 架构的更多信息，请参阅文档、字段和模式设计以及模式 API。</li><li>  data/：包含低级索引文件的目录。</li></ul></li></ul><p>请注意，SolrCloud 示例不包括每个 Solr Core&nbsp;的 conf&nbsp;目录（所以没有 solrconfig.xml 或 Schema 文件）。这是因为通常在 conf 目录中找到的配置文件存储在ZooKeeper 中，所以它们可以在群集中传播。</p><p>如果您正在使用 SolrCloud 与嵌入式 ZooKeeper 的情况下，您还可以看到 zoo.cfg 和 zoo.data，它们是 ZooKeeper 的配置和数据文件。但是，如果您正在运行自己的 ZooKeeper 集成，则您在启动 ZooKeeper 配置文件时，将会提供您自己的 ZooKeeper 配置文件，而 Solr 中的副本将不会被使用。有关 SolrCloud 的更多信息，请参阅 SolrCloud 部分。</p><h1 id="Solr版本升级说明"><a href="#Solr版本升级说明" class="headerlink" title="Solr版本升级说明"></a>Solr版本升级说明</h1><p>以下的说明描述了在升级之前您应该了解的&nbsp;Solr 在最近版本中所做的更改。</p><p>这些说明旨在强调可能影响最大数量的实现的最大变化。它不是任何版本中 Solr 的所有更改的完整列表。</p><p>在计划您的 Solr 升级时，请考虑您对系统进行的自定义设置，并查看在您的 Solr 软件包中找到的 &nbsp;CHANGES.txt 文件。该文件包含可能影响您现有实现的所有更改和更新。</p><p>升级 Solr 集群的详细步骤可以在“升级 Solr 集群&nbsp;”部分找到。</p><h2 id="从任何-6-x-版本升级"><a href="#从任何-6-x-版本升级" class="headerlink" title="从任何 6.x 版本升级"></a>从任何 6.x 版本升级</h2><p>从 Solr 6.x 升级到 Solr 7 介绍了在升级之前应注意的几个主要更改。请在开始升级之前对 Solr 7 中的部分主要更改进行彻底的检查。</p><h2 id="从较旧版本的-Solr-升级"><a href="#从较旧版本的-Solr-升级" class="headerlink" title="从较旧版本的 Solr 升级"></a>从较旧版本的 Solr 升级</h2><p>强烈建议从较旧版本升级的用户参考&nbsp;CHANGES.txt，了解自升级版本以来的所有更改的详细信息。</p><p>Solr 5.x 和 Solr 6.0 之间的重大变化摘要可以在从 Solr 5 到 Solr 6 章节的主要变化中找到。</p><h1 id="Solr7的主要变化"><a href="#Solr7的主要变化" class="headerlink" title="Solr7的主要变化"></a>Solr7的主要变化</h1><p>Solr 7 是 Solr 的一个主要的新版本，它引入了新的功能和其他一些可能影响您现有安装的其他更改。</p><h2 id="开始升级"><a href="#开始升级" class="headerlink" title="开始升级"></a>开始升级</h2><p>在开始迁移您的配置和索引之前，需要考虑 Solr 7 中的主要更改。此页面旨在突出显示最大的变化 - 您可能需要了解的新功能，还包括默认行为和已删除的已否决功能的更改。</p><p>然而，Solr 7 中有许多变化，因此，对 Solr 升级说明以及 Solr 实例中的 <a href="https://lucene.apache.org/solr/7_0_0//changes/Changes.html">CHANGES.txt</a> 文件进行彻底的审查将有助于您计划向 Solr 7 迁移。本节将重点介绍 Solr 7中的一些你应该知道的重大变化。</p><p>您还应该考虑在尚未升级到的任何版本中对 Solr 所做的所有更改。例如，如果您当前正在使用 Solr 6.2，则除了 7.0 的更改之外，还应该查看所有后续 6.x 版本中所做的更改。</p><p>将数据重新编入索引被认为是最佳做法，如果可能的话，您应该尝试这样做。但是，如果重新索引不可行，请记住，您只能一次升级一个主要版本。因此，Solr 6.x 索引将与 Solr 7 兼容，但 Solr 5.x 索引不会。</p><p>如果您现在不重新编制索引，请记住，您将需要重新索引数据或升级索引，然后才能在将来发布 Solr 8 时转移到 Solr 8。有关如何升级索引的更多详细信息，请参阅IndexUpgrader 工具一节。</p><p>有关如何升级 SolrCloud 群集的详细信息，另请参阅升级 Solr 群集一节。</p><h2 id="新增功能和功能增强"><a href="#新增功能和功能增强" class="headerlink" title="新增功能和功能增强"></a>新增功能和功能增强</h2><h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><p>直到 Solr 7 ，SolrCloud 模型的复制副本允许任何复制副本在领导者丢失时成为领导者。这对大多数用户来说非常有效，在集群出现问题的情况下提供可靠的故障切换。但是，由于所有副本必须在任何时候都同步，因此在大型群集中需要付出代价。</p><p>为了提供更多的灵活性，已经添加了两种新类型的副本，名为 TLOG＆PULL。这些新类型提供了一些选项，以便仅通过从前导项复制索引段与引线同步的副本。TLOG 类型还有一个额外的好处，就是维护一个事务日志（它的名字为 “tlog”），如果需要的话，它可以恢复并成为领导者；PULL 类型不维护事务日志，因此不能成为领导者。</p><p>作为这种改变的一部分，传统的副本现在被命名为 NRT。如果您没有明确定义一些 TLOG 或 PULL 副本，则 Solr 默认创建 NRT 副本。如果这个模型适合您的工作，您不需要改变任何东西。</p><p>有关新副本模式的更多详细信息，以及如何在群集中定义副本类型，请参见副本类型一节。</p><h3 id="自动缩放"><a href="#自动缩放" class="headerlink" title="自动缩放"></a>自动缩放</h3><p>Solr 自动缩放是 Solr 中的一个新功能套件，用于管理 SolrCloud 群集更加简单和自动化。</p><p>Solr 自动缩放的核心是为用户提供一个规则语法来定义如何在集群中分发节点和碎片的首选项和策略，目的是在集群中保持平衡。从 Solr 7 开始，Solr 将在确定将创建或移动各种 Collections API 命令的新碎片和副本放置到何处时，将考虑任何策略或首选项规则。</p><p>有关 Solr 7.0 中可用选项的详细信息，请参见 SolrCloud 自动缩放部分。预计在该领域的后续 7.x 版本中将会发布更多功能。</p><h3 id="其他功能和增强"><a href="#其他功能和增强" class="headerlink" title="其他功能和增强"></a>其他功能和增强</h3><ul><li>  Analytics 组件已被重构。该组件的文档正在进行中；在可用之前，请参阅 SOLR-11144 了解更多详情。</li><li>  在早期的 6.x 版本中发布了其他几个新功能，您可能会错过这些功能：学习排名（Learning&nbsp;to&nbsp;Rank）。统一的高亮（Unified&nbsp;Highlighter）。度量 API（Metrics&nbsp;API）。另请参阅下面的 “JMX 支持” 和 “MBean”一节中有关弃用的信息。有效负载查询（Payload&nbsp;queries）。流媒体评估器（Streaming&nbsp;Evaluators）。 / v2 API。 图流表达式（Graph&nbsp;streaming&nbsp;expressions）。</li></ul><h2 id="配置和默认更改"><a href="#配置和默认更改" class="headerlink" title="配置和默认更改"></a>配置和默认更改</h2><h3 id="新的默认配置集"><a href="#新的默认配置集" class="headerlink" title="新的默认配置集"></a>新的默认配置集</h3><p>对与 Solr 有关的配置进行了若干修改；不仅他们的内容，还有 Solr 在这些方面的行为：</p><ul><li>  data_driven_configset 与 basic_configset 已被删除，取而代之的是 _defaultconfigset。sample_techproducts_configset 还保留，专门与example/exampledocs 目录中的 Solr 附带的示例文档一起使用。</li><li>  当创建一个新的集合时，如果您不指定一个 configSet，_default 将被使用。如果你使用 SolrCloud，_defaultconfigSet 会自动上传到 ZooKeeper。如果使用独立模式，instanceDir 将自动创建，使用 _defaultconfigSet 作为基础。</li></ul><h3 id="无模式的改进"><a href="#无模式的改进" class="headerlink" title="无模式的改进"></a>无模式的改进</h3><p>为了改进无模式的功能，当检测到传入字段中的数据应该具有基于文本的字段类型时，Solr 现在的行为会有所不同。</p><ul><li>  默认情况下，传入的字段将被索引为 text_general（可以更改）。该字段的名称将与文档中定义的字段名称相同。</li><li>  复制字段规则将被插入到您的模式中，以将新的 text_general 字段复制到具有名称的新字段 <name>_str。这个字段的类型将是一个 strings 字段（允许多个值）。文本字段的前 256 个字符将被插入到新的字符串字段中。</name></li></ul><p>如果您希望删除复制字段规则，或者更改插入到字符串字段的字符数或所使用的字段类型，则可以自定义此行为。有关详细信息，请参阅 “无模式”部分。</p><pre><code>Tip：由于复制字段规则可以降低索引的速度并增加索引大小, 所以建议您在需要时只使用复制字段。如果您不需要对字段进行排序或分面，则应该删除自动生成的复制字段规则。</code></pre><p>可以使用 update.autoCreateFields 属性禁用自动字段创建。要做到这一点，您可以通过如下命令使用 Config API 例如：</p><pre><code>curl http://host:8983/solr/mycollection/config -d '{"set-user-property": {"update.autoCreateFields":"false"}}'</code></pre><h3 id="对默认行为的更改"><a href="#对默认行为的更改" class="headerlink" title="对默认行为的更改"></a>对默认行为的更改</h3><ul><li><p>  JSON 现在是默认的响应格式。如果您依赖于 XML 响应，您现在必须在请求中定义：wt=xml。另外，行缩进是默认启用的（indent=on）。</p></li><li><p>  sow 参数（“Split on Whitespace”的缩写）现在默认为 false，允许支持多字同义词。该参数与 eDismax 和 standard/“lucene” 查询解析器一起使用。如果此参数没有明确指定为：true，查询文本将不会在空白上拆分。</p></li><li><p>legacyCloud 参数现在默认为 false。如果副本的项不存在 state.json，则该副本将不会被注册。这可能会影响到复制副本的用户，并自动将其注册为分片的一部分。通过使用以下命令在群集属性中设置属性&nbsp;legacyCloud=true，可以退回到旧的行为：</p><pre><code>  ./server/scripts/cloud-scripts/zkcli.sh -zkhost 127.0.0.1:2181 -cmd clusterprop -name legacyCloud -val true</code></pre></li><li><p>  如果 solrconfig 中的 luceneMatchVersion 是 7.0.0 或以上版本，则 eDismax 查询分析器参数 lowercaseOperators 现在默认为 false。luceneMatchVersion 低于7.0.0 的行为是不变的（因此，为 true）。这意味着客户端必须以大写的方式发送布尔运算符（如 AND、OR 和 NOT）才能被识别，或者您必须明确地设置该参数为 true。</p></li><li><p>  如果 luceneMatchVersion 是7.0.0 或以上，则 solrconfig 中的 handleSelect 参数现在默认为 false。这会导致 Solr 忽略 qt 参数，如果它存在于请求中。如果您的请求处理程序没有前导 ‘/‘，则可以设置 handleSelect=”true” 或考虑迁移您的配置。该 qt 参数仍用作指定要使用的请求处理程序（尾部 URL 路径）的 SolrJ特殊参数。</p></li><li><p>lucenePlusSort 查询解析器（又名 “旧 Lucene 查询解析器”）已被弃用，不再隐式定义。如果你想继续使用这个解析器直到 Solr 8（当它将被删除），你必须将它注册到您的 solrconfig. xml 中，如：</p><pre><code>  &lt;queryParser name="lucenePlusSort" class="solr.OldLuceneQParserPlugin"/&gt;</code></pre></li><li><p>  TemplateUpdateRequestProcessorFactory 名称从 Template更改为 template，AtomicUpdateProcessorFactory 的名称从 Atomic 改为atomic，此外，TemplateUpdateRequestProcessorFactory 现在使用 {} 而不是 $ {} 作为模板。</p></li></ul><h2 id="弃用和删除的功能"><a href="#弃用和删除的功能" class="headerlink" title="弃用和删除的功能"></a>弃用和删除的功能</h2><h3 id="点字段是默认的数值类型"><a href="#点字段是默认的数值类型" class="headerlink" title="点字段是默认的数值类型"></a>点字段是默认的数值类型</h3><p>Solr 全面实现了 * PointField 类型，取代了基于 Trie * 的数字字段。现在所有的 Trie * 字段都被认为是不赞成使用的，并将在 Solr 8 中删除。</p><p>如果您在您的模式使用 Trie * 字段，则您应该考虑尽快迁移到 PointFields。更改为新的 PointField 类型将要求您重新索引数据。</p><h3 id="空间领域"><a href="#空间领域" class="headerlink" title="空间领域"></a>空间领域</h3><p>以下与空间相关的字段已被弃用：</p><ul><li>  LatLonType</li><li>  GeoHashField</li><li>  SpatialVectorFieldType</li><li>  SpatialTermQueryPrefixTreeFieldType</li></ul><p>改为选择下列字段类型之一：</p><ul><li>  LatLonPointSpatialField</li><li>  SpatialRecursivePrefixTreeField</li><li>  RptWithGeometrySpatialField</li></ul><p>有关更多信息，请参阅空间搜索部分。</p><h3 id="JMX-支持和-MBeans"><a href="#JMX-支持和-MBeans" class="headerlink" title="JMX 支持和 MBeans"></a>JMX 支持和 MBeans</h3><ul><li><p>  solrconfig.xml 中的 <jmx> 元素已被删除，&nbsp;以支持在 solr 中定义的&nbsp;<metrics> <reporter>&nbsp;元素。如果缺少 SolrJmxReporter，并且在找到本地 MBean 服务器时自动添加默认的实例，则会提供有限的向后兼容性。本地 MBean 服务器可以通过 solr.in.sh 中的 ENABLE_REMOTE_JMX_OPTS&nbsp;或者经由系统的性能（例如：Dcom.sun.management.jmxremote）被激活。此默认实例将所有注册表中的所有 Solr 度量标准导出为分层 MBean。还可以通过指定SolrJmxReporter 配置来禁用该行为，该配置使用的布尔型 init 参数设置为 false。对于更加 fine-grained 的控制，用户应明确指定至少一个 SolrJmxReporter配置。另请参阅 <metrics> <reporter> 元素部分，其中介绍了如何设置 Metrics Reporter&nbsp;solr.xml。请注意，后向兼容性支持可能会在 Solr 8 中删除。</reporter></metrics></reporter></metrics></jmx></p></li><li><p>  MBean 名称和属性现在遵循度量中使用的分层名称。这也反映在：/admin/mbeans和/admin/plugins 输出中，并且可以在 UI Plugins 选项卡中观察到，因为现在所有这些 API 都从度量 API 获取其数据。旧的（大部分是平坦的）JMX 视图已被删除。</p></li></ul><h3 id="SolrJ"><a href="#SolrJ" class="headerlink" title="SolrJ"></a>SolrJ</h3><p>SolrJ 进行了以下更改。</p><ul><li>  HttpClientInterceptorPlugin：现在是 HttpClientBuilderPlugin，必须与一个 SolrHttpClientBuilder 一起工作，而不是一个 HttpClientConfigurer。</li><li>  HttpClientUtil：现在允许通过 SolrHttpClientBuilder&nbsp;配置 HttpClient 实例，而不是通过一个 HttpClientConfigurer。使用 env 变量SOLR_AUTHENTICATION_CLIENT_CONFIGURER 不再有效，请使用 SOLR_AUTHENTICATION_CLIENT_BUILDER。</li><li>  SolrClient：实现现在使用自己的内部配置套接字超时、连接超时并允许重定向，而不是在生成 HttpClient 实例时设置为默认值。在 SolrClient 实例上使用适当的设置器。</li><li>  HttpSolrClient#setAllowCompression&nbsp;已被移除，必须将压缩作为构造函数参数启用。</li><li>  HttpSolrClient#setDefaultMaxConnectionsPerHost 和 HttpSolrClient#setMaxTotalConnections 已被删除。现在这些默认值非常高，只能在创建HttpClient 实例时通过参数进行更改。</li></ul><h3 id="其他的弃用和删除"><a href="#其他的弃用和删除" class="headerlink" title="其他的弃用和删除"></a>其他的弃用和删除</h3><ul><li>  模式中的 defaultOperator 参数不再被支持，改用 q.op 参数。这个选项已经被弃用了几个版本。有关更多信息，请参见标准查询解析器参数部分。</li><li>  模式中的 defaultSearchField 参数不再被支持，改用 df 参数。这个选项已经被弃用了几个版本。有关更多信息，请参见标准查询解析器参数部分。</li><li>  mergePolicy、mergeFactor 和 maxMergeDocs 参数已被删除并不再支持。你应该定义一个 mergePolicyFactory。有关更多信息，请参见mergePolicyFactory 部分。</li><li>  PostingsSolrHighlighter 已被弃用。建议您改为使用 UnifiedHighlighter。有关更多信息，请参阅 Unified Highlighter 部分。</li><li>  索引时间提升已经从 Lucene 中删除，并且不再可以从 Solr 获得。如果提供了任何提升，它们将被索引链忽略。作为替代，索引时间评分因子应该在单独的字段中编入索引，并使用函数查询与查询评分相结合。有关更多信息，请参阅函数查询一节。</li><li>  StandardRequestHandler 已被弃用，改为使用 SearchHandler。</li><li>  为了提高集合 API 参数的一致性，MOVEREPLICA 命令和源的参数名称为 fromNode，REPLACENODE 命令中的 target&nbsp;已被弃用，取而代之的是 sourceNode和 targetNode。旧名称将继续为后向兼容工作，但他们将在 Solr 8&nbsp;中被删除。</li><li>  未使用的 valType 选项已从 ExternalFileField 中删除，如果在模式中有这个选项，则可以安全地删除它。</li></ul><h2 id="早期的-6-x-版本的主要变化"><a href="#早期的-6-x-版本的主要变化" class="headerlink" title="早期的 6.x 版本的主要变化"></a>早期的 6.x 版本的主要变化</h2><p>以下对早期 Solr 6.x 版本中的更改的摘要突出显示了在本指南的早期版本中列出的 Solr 6.0 和 6.6 之间发布的重大更改。如上述各节所述，在 Solr 7 中提到弃用可能会被取消。</p><p>请再次注意，这并不是可能影响您的安装的所有更改的完整列表，因此如果从早于 6.6 的任何版本升级，强烈建议您查看 CHANGES.txt。</p><ul><li>  Solr 的贡献：map-reduce、morphlines-core 和 morphlines-cell 已被删除。</li><li>  JSON Facet API 现在使用超级日志记录进行 numBuckets 基数计算，并在将存储区过滤之前计算 mincount 大于1的基数。</li><li>  如果您使用历史日期，特别是 1582 年或之前的日期，则应该重新编制索引，以便更好地处理日期。</li><li>  如果您使用 method=stream&nbsp;的 JSON Facet API（json.facet），您现在必须设置 sort=’index asc’ 以获取流式传输行为；否则不会流出。提醒：method 是一个提示，不会改变其他参数的默认值。</li><li>  如果您使用 JSON Facet API（json.facet）来面向数字字段，并且如果您使用 mincount=0 或者如果您设置了前缀，那么现在将出现错误，因为这些选项与数字分面不兼容。</li><li>  Solr 在 INFO 级别的日志记录详细程度已大大降低，您可能需要更新日志配置以使用 DEBUG 级别来查看以前在 INFO 级别上查看的所有日志记录消息。</li><li>  我们不再支持 solr.log 和 solr_gc.log 文件在日期戳的副本。如果您依赖于&nbsp;“日志” 文件夹中的&nbsp;solr_log_<date> 或 solr_gc_log_<date>，将不再是这种情况。有关如何在 Solr 6.3 中进行日志轮换的详细信息，请参阅配置日志记录一节。</date></date></li><li>  MiniSolrCloudCluster 中的 create / deleteCollection 方法已被弃用。用户应该使用 CollectionAdminRequest API。此外，MiniSolrCloudCluster#uploadConfigDir(File, String)已被弃用，以支持 #uploadConfigSet(Path, String)。</li><li>  现在，默认情况下，bin/solr.in.sh（Windows 上为 bin/solr.in.cmd）已完全注释。以前，情况并非如此，它具有掩盖现有环境变量的作用。</li><li>  _version_ 字段不再被编入索引，现在 indexed=false 默认定义，因为该字段已启用 DocValues。</li><li>  /export 处理程序已被更改，因此它不再返回原始文档中不存在的数值字段的零 (0)。这种改变的一个后果是，你必须知道，如果原始文档中没有任何元组，那么一些元组将没有值。</li><li>org.apache.solr.util.stats 中与度量相关的类已被删除，转而支持 Dropwizard 度量库。任何使用这些类的自定义插件都应该更改为使用度量库中的等效类。作为其中的一部分，对监督状态 API 的输出进行了以下更改：<ul><li>  “totalTime” 指标已被删除，因为它不再受支持。</li><li>  监督状态 API 中的度量标准：“75thPctlRequestTime”、“95thPctlRequestTime”、“99thPctlRequestTime” 和 “999thPctlRequestTime” 已被重命名为：“75thPcRequestTime”、“95thPcRequestTime” 等，以与 Solr 的其他部分输出的统计信息保持一致。</li><li>  “avgRequestsPerMinute”、“5minRateRequestsPerMinute” 和 “15minRateRequestsPerMinute” 的度量标准被相应的每秒速率 viz 替代，“avgRequestsPerSecond”、“5minRateRequestsPerSecond” 和 “15minRateRequestsPerSecond” 与 Solr其他部分输出的统计信息保持一致。</li></ul></li><li>  新增了 UnifiedHighlighter。建议您通过设置 hl.method=unified 和报告反馈来尝试 UnifiedHighlighter。这将很有效率并且更快。hl.useFastVectorHighlighter现在被认为是代替 hl.method=fastVector。</li><li>  maxWarmingSearchers 参数现在默认为1，而更重要的是，如果超出此限制而不是引发异常 ，现在就会阻止它的提交。因此，在重叠提交中不再存在风险。尽管如此，用户应该继续避免过多的提交。建议用户从其 solrconfig. xml 文件中删除任何预先存在的 maxWarmingSearchers 条目。</li><li>  复杂的短语查询分析器现在支持领先的通配符。注意其可能的沉重程度，鼓励用户在索引时间分析中使用 ReversedWildcardFilter。</li><li>  JMX 度量标准 “avgTimePerRequest”（以及每个处理程序的度量 API 中的相应度量）过去是基于总累计时间和请求数的简单 non-decaying 平均值。Codahale度量标准的实现对这个值应用了指数衰减，这个值在最后5分钟内严重偏离了平均值。</li><li>  并行 SQL 现在使用 Apache Calcite 作为其 SQL 框架。作为此更改的一部分，默认聚合模式已更改为 facet 而不是 map_reduce。对 SQL 聚合响应和一些 SQL语法更改也进行了更改。有关完整的细节，请参阅并行 SQL 接口文档。</li></ul><h1 id="从Solr5到Solr6的主要变化"><a href="#从Solr5到Solr6的主要变化" class="headerlink" title="从Solr5到Solr6的主要变化"></a>从Solr5到Solr6的主要变化</h1><p>在开始迁移您的配置和索引之前，Solr6 中有一些重大的改变需要考虑。</p><p>有很多的更改，因此，对 Solr 升级注释部分以及 Solr 实例中的 CHANGES.txt 文件进行彻底的检查将有助于您计划向 Solr6 的迁移。本节将重点介绍您应该注意的一些主要更改。</p><h2 id="Solr6-中新特性的亮点"><a href="#Solr6-中新特性的亮点" class="headerlink" title="Solr6 中新特性的亮点"></a>Solr6 中新特性的亮点</h2><h3 id="Streaming-表达式"><a href="#Streaming-表达式" class="headerlink" title="Streaming&nbsp;表达式"></a>Streaming&nbsp;表达式</h3><p>在 Solr5 中引入的 Streaming 表达式允许查询 Solr 并将结果作为数据流进行排序和聚合。</p><p>Solr6 中添加了几种新的表达式类型：</p><ul><li>  使用类似 MapReduce 的并行表达式来加快 high-cardinality 字段的吞吐量。</li><li>  守护程序表达式以支持持续推送或拉取流。</li><li>  高级并行关系代数，如分布式连接、交集、联合和补充。</li><li>  发布/订阅消息。</li><li>  用于从其他系统中提取数据并与 Solr 索引中的文档联接的 JDBC 连接。</li></ul><h3 id="并行-SQL-接口"><a href="#并行-SQL-接口" class="headerlink" title="并行 SQL 接口"></a>并行 SQL 接口</h3><p>构建在 Streaming 表达式的基础上，Solr6 中的新增功能是一个并行 SQL 接口，可以将 SQL 查询发送到 Solr。SQL 语句被即时编译为 Streaming 表达式，提供可用于 Streaming 表达式请求的全部聚合。包含一个 JDBC 驱动程序，它允许使用 SQL 客户端和数据库可视化工具查询您的 Solr 索引并将数据导入到其他系统。</p><h3 id="跨数据中心复制"><a href="#跨数据中心复制" class="headerlink" title="跨数据中心复制"></a>跨数据中心复制</h3><p>跨数据中心复制现在可以跨数据中心进行复制。使用主动 - 被动模型，SolrCloud 集群可以被复制到另一个数据中心，并用一个新的 API 进行监控。</p><h3 id="QueryParser-图"><a href="#QueryParser-图" class="headerlink" title="QueryParser 图"></a>QueryParser 图</h3><p>一个新的图形查询解析器可以使用 Solr 文档建模的定向（循环）图的遍历查询成为可能。</p><h3 id="DocValues"><a href="#DocValues" class="headerlink" title="DocValues"></a>DocValues</h3><p>在 Solr 示例配置集中的大多数非文本字段类型现在默认为使用 DocValues。</p><h2 id="需要使用-Java8"><a href="#需要使用-Java8" class="headerlink" title="需要使用 Java8"></a>需要使用 Java8</h2><p>Solr6（和 SolrJ 客户端库）的 Java 最低支持版本现在是 Java8。</p><h2 id="索引格式更改"><a href="#索引格式更改" class="headerlink" title="索引格式更改"></a>索引格式更改</h2><p>Solr6 不支持读取 Lucene / Solr 4.x 和更早版本的索引。如果您的索引中仍然有旧的 4x 格式的段，请务必运行 Solr 5.5 附带的 Lucene IndexUpgrader。另外：使用 Solr 5.5 充分优化您的索引，以确保它只包含一个最新的索引段。</p><h2 id="托管模式现在是默认的"><a href="#托管模式现在是默认的" class="headerlink" title="托管模式现在是默认的"></a>托管模式现在是默认的</h2><p>当 solrconfig.xml 没有明确定义 <schemafactory> 的时候，Solr 的默认行为现在依赖于 solrconfig.xml 定义的 luceneMatchVersion。当 luceneMatchVersion &lt; 6.0 时，ClassicIndexSchemaFactory 将继续用于后向兼容，否则将使用 ManagedIndexSchemaFactory 的实例。</schemafactory></p><p>这种变化最显著的影响是：</p><ul><li>  现有的 solrconfig.xml 文件被修改为使用 luceneMatchVersion &gt;= 6.0，但没有明确配置 ClassicIndexSchemaFactory，将其 schema.xml 文件自动升级到managed-schema 文件。</li><li>  现在将默认启用通过 Schema API 进行的模式修改。</li></ul><h2 id="默认的相似性改变"><a href="#默认的相似性改变" class="headerlink" title="默认的相似性改变"></a>默认的相似性改变</h2><p>当 Schema 没有明确地定义全局 <similarity> 时，Solr 的默认行为将依赖于&nbsp;solrconfig. xml 中指定的 luceneMatchVersion。当 luceneMatchVersion &lt; 6.0 时，将使用 ClassicSimilarityFactory 的实例，否则将使用&nbsp;SchemaSimilarityFactory 的实例。最值得注意的是，这种改变意味着用户可以利用每个字段类型的相似性声明，并且需要明确声明 SchemaSimilarityFactory 的全局用法。</similarity></p><p>无论是明确声明还是作为隐式全局默认值使用，当字段类型不声明明确 <similarity> 时，SchemaSimilarityFactory 的隐式行为也被更改为依赖于 luceneMatchVersion。当 luceneMatchVersion &lt; 6.0 时，将使用 ClassicSimilarity 的实例，否则将使用&nbsp;BM25Similarity 的实例。可以在 SchemaSimilarityFactory 声明中指定 defaultSimFromFieldType init 选项来更改此行为。请查看 SchemaSimilarityFactoryjavadocs 了解更多详情</similarity></p><h2 id="副本和碎片删除命令更改"><a href="#副本和碎片删除命令更改" class="headerlink" title="副本和碎片删除命令更改"></a>副本和碎片删除命令更改</h2><p>DELETESHARD 和 DELETEREPLICA 现在默认为删除任何复制副本的实例目录、数据目录和索引目录。如果希望在使用这些命令时保留磁盘上的所有数据，请查看Collection API 文档以获取有关新请求参数的详细信息。</p><h2 id="facet-date-参数已删除"><a href="#facet-date-参数已删除" class="headerlink" title="facet.date.* 参数已删除"></a>facet.date.* 参数已删除</h2><p>在 Solr3.x 中被弃用的 facet.date 参数（和相关 facet.date.* 参数）已被完全删除。如果您尚未切换到使用等效的 facet.range 功能，则必须在升级之前立即执行此操作。</p><h1 id="将Solr应用到生产"><a href="#将Solr应用到生产" class="headerlink" title="将Solr应用到生产"></a>将Solr应用到生产</h1><p>本节提供有关如何设置 Solr 以在 * nix 平台（如 Ubuntu）的生产中运行的指南。具体来说，我们将介绍在 Linux 主机上运行单个 Solr 实例的过程，然后提供有关如何支持在同一主机上运行的多个 Solr 节点的提示。</p><h2 id="服务安装脚本"><a href="#服务安装脚本" class="headerlink" title="服务安装脚本"></a>服务安装脚本<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#service-installation-script"></a></h2><p>Solr 包含一个服务安装脚本（bin/install_solr_service.sh），它可以帮助您在 Linux 上将 Solr 作为服务安装。目前，该脚本仅支持 CentOS、Debian、Red Hat、SUSE 和 Ubuntu Linux 发行版。在运行脚本之前，您需要确定一些关于您的设置的参数。具体而言，您需要决定 Solr 的安装位置以及哪些系统用户应该是 Solr 文件和进程的所有者。</p><h3 id="规划目录结构"><a href="#规划目录结构" class="headerlink" title="规划目录结构"></a>规划目录结构<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#planning-your-directory-structure"></a></h3><p>我们建议从 Solr 发行包中包含的文件中分离出实时的 Solr 文件，如日志和索引文件，因为这样可以更容易地升级 Solr，系统管理员认为这是一种很好的做法。</p><h4 id="Solr-安装目录"><a href="#Solr-安装目录" class="headerlink" title="Solr 安装目录"></a>Solr 安装目录<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#solr-installation-directory"></a></h4><p>默认情况下，服务安装脚本将提取分发档案到：/opt。当您运行安装脚本时，可以使用 -i 选项更改此位置。该脚本还会创建一个指向 Solr 的版本化目录的符号链接。例如，如果您为&nbsp;Solr 7.0.0 运行安装脚本，则将使用以下目录结构：</p><pre><code>/opt/solr-7.0.0/opt/solr -&gt; /opt/solr-7.0.0</code></pre><p>使用符号链接可以使任何脚本不依赖于特定的 Solr 版本。如果您需要升级到更高版本的 Solr，则可以更新符号链接以指向升级版本的 Solr。我们将使用 /opt/solr 在本页的其余部分中引用 Solr 安装目录。</p><h4 id="可写文件的独立目录"><a href="#可写文件的独立目录" class="headerlink" title="可写文件的独立目录"></a>可写文件的独立目录<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#separate-directory-for-writable-files"></a></h4><p>您还应该将可写的 Solr 文件分隔到不同的目录中；默认情况下，安装脚本使用：/var/solr，但您可以使用 -d 选项覆盖此位置。采用这种方法，在&nbsp;/opt/solr 中的文件将保持不变，并且所有在 Solr 运行时更改的文件都将处于 /var/solr 下面。</p><h3 id="创建-Solr-用户"><a href="#创建-Solr-用户" class="headerlink" title="创建 Solr 用户"></a>创建 Solr 用户</h3><p>出于安全考虑，建议不要以 root 身份运行 Solr，并且&nbsp;“控制脚本启动” 命令将拒绝这样做。因此，您应该确定将拥有所有 Solr 文件和正在运行的 Solr 进程的系统用户的用户名。默认情况下，安装脚本将创建 solr 用户，但您可以使用 -u 选项覆盖此设置。如果您的组织对创建新的用户帐户有特定的要求，那么您应该在运行脚本之前创建用户。安装脚本将使 Solr 用户成为 /opt/solr和/var/solr 目录的所有者。</p><p>现在，您可以运行安装脚本了。</p><h3 id="运行-Solr-安装脚本"><a href="#运行-Solr-安装脚本" class="headerlink" title="运行 Solr 安装脚本"></a>运行 Solr 安装脚本<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#run-the-solr-installation-script"></a></h3><p>要运行该脚本，您需要下载最新的 Solr 分发归档文件，然后执行以下操作：</p><pre><code>tar xzf solr-7.0.0.tgz solr-7.0.0/bin/install_solr_service.sh --strip-components=2</code></pre><p>前面的命令 install_solr_service.sh 将档案中的脚本提取到当前目录中。如果在 Red Hat 上安装，请确保在运行 Solr 安装脚本之前安装了 lsof（sudo yum install lsof）。安装脚本必须以 root 身份运行：</p><pre><code>sudo bash ./install_solr_service.sh solr-7.0.0.tgz</code></pre><p>默认情况下，该脚本将分发归档文件提取到 /opt，配置 Solr 将文件写入 /var/solr，并以 solr 用户身份运行 Solr&nbsp;。因此，下面的命令产生与上一个命令相同的结果：</p><pre><code>sudo bash ./install_solr_service.sh solr-7.0.0.tgz -i /opt -d /var/solr -u solr -s solr -p 8983</code></pre><p>您可以使用传递给安装脚本的选项自定义服务名称、安装目录、端口和所有者。要查看可用选项，请执行以下操作：</p><pre><code>sudo bash ./install_solr_service.sh -help</code></pre><p>脚本完成后，Solr 将作为服务安装并在服务器的后台运行（在端口 8983 上）。为了验证，您可以这样做：</p><pre><code>sudo service solr status</code></pre><p>如果您不想立即启动服务，请传递 -n 选项。然后，您可以稍后手动启动服务，例如在完成配置设置之后。</p><p>我们将介绍一些您可以进行的其他配置设置，以便稍后微调您的 Solr 设置。在继续之前，让我们仔细看一下安装脚本执行的步骤。这样可以帮助您更好地了解并阅读本指南中的其他页面，帮助您了解有关 Solr 安装的重要细节：例如当一个页面提到 Solr 主页时，您就会知道系统中的具体位置。</p><h4 id="Solr-主目录"><a href="#Solr-主目录" class="headerlink" title="Solr 主目录"></a>Solr 主目录</h4><p>Solr 主目录（不要与 Solr 安装目录混淆）是 Solr 使用索引文件管理核心目录的地方。默认情况下，安装脚本使用：/var/solr/data。如果在安装脚本中使用 -d 选项，则这将更改为给定 -d 选项的位置中的 data 子目录。请花些时间检查系统上的 Solr 主目录的内容。如果您没有在 ZooKeeper 中存储 solr.xml，则主目录必须包含一个 solr.xml 文件。当 Solr 启动时，Solr 控制脚本将使用<code>-Dsolr.solr.home=…​</code>系统属性传递主目录的位置。</p><h4 id="环境重写包含文件"><a href="#环境重写包含文件" class="headerlink" title="环境重写包含文件"></a>环境重写包含文件<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#environment-overrides-include-file"></a></h4><p>服务安装脚本将创建一个特定于环境的包含文件，该文件将重写 bin/solr 脚本所使用的默认值。使用包含文件的主要优点是它提供了一个单一的位置，在这个位置上定义了所有特定于环境的重写。请花点时间检查 /etc/default/solr.in.sh 文件的内容，这是安装脚本设置的默认路径。如果您在安装脚本中使用 -s 选项更改服务的名称，则文件名的第一部分将会不同。对于名为 solr-demo 的服务，该文件将被命名为 /etc/default/solr-demo.in.sh。有很多设置可以用这个文件重写。但是，这个脚本至少需要定义 SOLR_PID_DIR 和 SOLR_HOME 变量，比如：</p><pre><code>SOLR_PID_DIR=/var/solrSOLR_HOME=/var/solr/data</code></pre><p>该 SOLR_PID_DIR 变量设置控制脚本将写入包含 Solr 服务器进程 ID 的文件的目录。</p><h4 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#log-settings"></a></h4><p>Solr 使用 Apache Log4J 进行日志记录。安装脚本复制 /opt/solr/server/resources/log4j.properties 到 /var/solr/log4j.properties。请花一点时间通过在 /etc/default/solr.in.sh 中检查以下设置以验证 Solr 包含文件是否配置为将日志发送到正确的位置：</p><pre><code>LOG4J_PROPS=/var/solr/log4j.propertiesSOLR_LOGS_DIR=/var/solr/logs</code></pre><p>有关 Log4J 配置的详细信息，请参阅: 配置日志记录。</p><h4 id="init-d-脚本"><a href="#init-d-脚本" class="headerlink" title="init.d 脚本"></a>init.d 脚本<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#init-d-script"></a></h4><p>在 Linux 上运行 Solr 等服务时，通常需要设置 init.d 脚本，以便系统管理员可以使用服务工具来控制 Solr，例如：service solr start。安装脚本创建一个非常基本的init.d 脚本来帮助您入门。请花点时间检查 /etc/init.d/solr 文件，这是安装脚本设置的默认脚本名称。如果在安装脚本中使用 -s 选项更改服务的名称，则文件名将会不同。请注意，根据传递给安装脚本的参数为您的环境设置了以下变量：</p><pre><code>SOLR_INSTALL_DIR=/opt/solrSOLR_ENV=/etc/default/solr.in.shRUNAS=solr</code></pre><p>SOLR_INSTALL_DIR 和 SOLR_ENV 变量应该是不言而喻的。该 RUNAS 变量设置 Solr 进程的所有者，例如 solr；如果不设置此值，脚本将以 root 身份运行 Solr&nbsp;，这是不建议用于生产的。您可以以 root 身份使用 /etc/init.d/solr 脚本来启动 Solr，执行以下操作：</p><pre><code>service solr start</code></pre><p>该 /etc/init.d/solr 脚本还支持停止、重新启动和状态命令。请记住，Solr 附带的初始化脚本非常基本，旨在向您展示如何将 Solr 设置为服务。但是，使用更高级的工具（如 supervisord 或 upstart）来控制 Solr 作为 Linux 上的服务也很常见。在展示如何将 Solr 与 supervisord 等工具整合在一起超出本指南的范围时，init.d/solr脚本应该提供足够的指导来帮助您入门。而且，安装脚本将 Solr 服务设置为在主机初始化时自动启动。</p><h3 id="进度检查"><a href="#进度检查" class="headerlink" title="进度检查"></a>进度检查<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#progress-check"></a></h3><p>在下一节中，我们将介绍一些其他的环境设置，以帮助您微调您的生产设置。但是，在我们继续之前，让我们回顾一下迄今为止取得的成就。具体来说，你应该能够使用 /etc/init.d/solr 控制 Solr。请验证以下命令是否与您的安装程序一起使用：</p><pre><code>sudo service solr restartsudo service solr status</code></pre><p>status 命令应该提供一些关于正在运行的 Solr 节点的基本信息，如：</p><pre><code>Solr process PID running on port 8983{  "version":"5.0.0 - ubuntu - 2014-12-17 19:36:58",  "startTime":"2014-12-19T19:25:46.853Z",  "uptime":"0 days, 0 hours, 0 minutes, 8 seconds",  "memory":"85.4 MB (%17.4) of 490.7 MB"}</code></pre><p>如果该 status 命令不成功，请在 /var/solr/logs/solr.log 中查找错误消息。</p><h2 id="微调您的生产设置"><a href="#微调您的生产设置" class="headerlink" title="微调您的生产设置"></a>微调您的生产设置<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#fine-tune-your-production-setup"></a></h2><h3 id="内存和-GC-设置"><a href="#内存和-GC-设置" class="headerlink" title="内存和 GC 设置"></a>内存和 GC 设置</h3><p>默认情况下，bin/solr 脚本将最大 Java 堆大小设置为 512M（-Xmx512m），这对于 Solr 入门是很好的。对于生产，您将希望根据您的搜索应用程序的内存需求增加最大堆大小；对于生产服务器，10 到 20 千兆字节的值并不少见。当您需要更改 Solr 服务器的内存设置时，请使用 SOLR_JAVA_MEM 包含文件中的变量，例如：</p><pre><code>SOLR_JAVA_MEM="-Xms10g -Xmx10g"</code></pre><p>此外，Solr 控制脚本还附带一组预先配置的 Java 垃圾收集设置，这些设置对于许多不同的工作负载都显示出与 Solr 的良好配合。但是，这些设置可能不适用于您对Solr 的具体使用。因此，您可能需要更改 GC 设置，这也应该使用 /etc/default/solr.in.sh 包含文件中的 GC_TUNE 变量来完成。有关调整内存和垃圾收集设置的更多信息，请参阅：JVM 设置。</p><h4 id="内存关闭挂钩"><a href="#内存关闭挂钩" class="headerlink" title="内存关闭挂钩"></a>内存关闭挂钩<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#out-of-memory-shutdown-hook"></a></h4><p>bin/solr 脚本注册的 bin/oom_solr.sh 脚本将被 JVM 调用，如果出现一个 OutOfMemoryError。该 oom_solr.sh 脚本将向 kill -9Solr 进程发出一个经验OutOfMemoryError。在 SolrCloud 模式下运行时建议使用此行为，以便立即通知 ZooKeeper 某个节点遇到不可恢复的错误。请花点时间检查 /opt/solr/bin/oom_solr.sh 脚本的内容，以便熟悉脚本如果由 JVM 调用时将执行的操作。</p><h3 id="使用-SolrCloud-进行生产"><a href="#使用-SolrCloud-进行生产" class="headerlink" title="使用 SolrCloud 进行生产"></a>使用 SolrCloud 进行生产<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#going-to-production-with-solrcloud"></a></h3><p>要以 SolrCloud 模式运行 Solr，您需要在包含文件中设置 ZK_HOST 变量，以指向您的 ZooKeeper 集合。在生产环境中不支持运行嵌入式 ZooKeeper。例如，如果您在默认客户端端口 2181（zk1，zk2 和 zk3）上的以下三台主机上托管 ZooKeeper 集成，则可以设置：</p><pre><code>ZK_HOST=zk1,zk2,zk3</code></pre><p>当 ZK_HOST 变量被设置时，Solr 将以“cloud”模式启动。</p><h4 id="ZooKeeper-chroot"><a href="#ZooKeeper-chroot" class="headerlink" title="ZooKeeper chroot"></a>ZooKeeper chroot</h4><p>如果您使用的是其他系统共享的 ZooKeeper 实例，建议使用 ZooKeeper 的 chroot 支持来隔离 SolrCloud znode 树。例如，要确保 SolrCloud 创建的所有 znode都存储在 /solr 下面，您可以在 ZK_HOST 连接字符串的末尾放置 /solr，例如：</p><pre><code>ZK_HOST=zk1,zk2,zk3/solr</code></pre><p>首次使用 chroot 之前，您需要使用 Solr 控制脚本在 ZooKeeper 中创建根路径（znode）。我们可以使用 mkroot命令：</p><pre><code>bin/solr zk mkroot /solr -z &lt;ZK_node&gt;:&lt;ZK_PORT&gt; Tip：你还想用现有的 solr_home 引导 ZooKeeper，你可以改为使用 zkcli.sh 或zkcli.bat bootstrap命令，如果它不存在，也会创建 chroot 路径。有关更多信息，请参阅命令行实用程序。</code></pre><h3 id="Solr-主机名"><a href="#Solr-主机名" class="headerlink" title="Solr 主机名"></a>Solr 主机名<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#solr-hostname"></a></h3><p>使用 SOLR_HOST 包含文件中的变量来设置 Solr 服务器的主机名。</p><pre><code>SOLR_HOST=solr1.example.com</code></pre><p>建议设置 Solr 服务器的主机名，尤其是在 SolrCloud 模式下运行时，因为这决定了在向 ZooKeeper 注册时节点的地址。</p><h3 id="重写-solrconfig-xml-中的设置"><a href="#重写-solrconfig-xml-中的设置" class="headerlink" title="重写 solrconfig.xml 中的设置"></a>重写 solrconfig.xml 中的设置</h3><p>Solr 允许使用 -Dproperty=value 语法在启动时传递的 Java 系统属性重写配置属性。例如，在 solrconfig.xml 中，默认的 “自动软提交” 设置被设置为：</p><pre><code>&lt;autoSoftCommit&gt;  &lt;maxTime&gt;${solr.autoSoftCommit.maxTime:-1}&lt;/maxTime&gt;&lt;/autoSoftCommit&gt;</code></pre><p>一般来说，无论何时在使用 ${solr.PROPERTY:DEFAULT_VALUE} 语法的 Solr 配置文件中看到一个属性，都可以使用 Java 系统属性重写它。例如，要将 soft-commits 的 maxTime 设置为10秒，则可以使用以下命令启动 Solr&nbsp;-Dsolr.autoSoftCommit.maxTime=10000，例如：</p><pre><code>bin/solr start -Dsolr.autoSoftCommit.maxTime=10000</code></pre><p>该 bin/solr 脚本只是在启动时将以 -D 开头的选项传递给 JVM。为了在生产环境中运行，我们建议在 include 文件中定义 SOLR_OPTS&nbsp;的变量中设置这些属性。按照我们的&nbsp;soft-commit&nbsp;例子，在 /etc/default/solr.in.sh 中，你可以这样做：</p><pre><code>SOLR_OPTS="$SOLR_OPTS -Dsolr.autoSoftCommit.maxTime=10000"</code></pre><h2 id="每个主机运行多个Solr节点"><a href="#每个主机运行多个Solr节点" class="headerlink" title="每个主机运行多个Solr节点"></a>每个主机运行多个Solr节点<a href="http://lucene.apache.org/solr/guide/7_0/taking-solr-to-production.html#running-multiple-solr-nodes-per-host"></a></h2><p>该 bin/solr 脚本能够在一台机器上运行多个实例，但对于典型的安装，这不是推荐的设置。每个额外的实例都需要额外的 CPU 和内存资源。单个实例可以很容易地处理多个索引。</p><pre><code>Tip：何时忽略该建议？对于每个建议，都有例外。对于上面的建议，该异常在讨论极限可伸缩性时主要适用。在一台主机上运行多个 Solr 节点的最佳原因是减少了对非常大的堆的需求。当 Java 堆变得非常大时，即使启动脚本默认提供了 GC 调整，也可能导致非常长的垃圾回收暂停。堆被认为是“非常大”的确切点将取决于如何使用 Solr。这意味着没有可作为阈值的硬数字，但是如果你的堆达到了16到32千兆字节的邻域，那么可能是考虑拆分节点的时候了。理想情况下，这将意味着更多的机器，但预算的限制可能会使这一切不可能。一旦堆达到32GB，还有另外一个问题。在32GB以下，Java 能够使用压缩的指针，但是在那之上，需要更大的指针，它使用更多的内存并且减慢了 JVM 的速度。由于潜在的垃圾收集问题以及在32GB时发生的特定问题，如果单个实例需要64GB的堆，那么如果机器设置了两个节点，每个节点的堆大小为31GB，则性能可能会大大提高。</code></pre><p>如果您的用例需要多个实例，则至少您需要为要运行的每个节点分配独特的 Solr 主目录；理想情况下，每个主页都应位于不同的物理磁盘上，以便多个 Solr 节点在访问磁盘上的文件时不必相互竞争。拥有不同的 Solr 主目录意味着每个节点都需要一个不同的包含文件。而且，如果使用<code>/etc/init.d/solr</code>脚本来控制 Solr 作为服务，那么每个节点都需要单独的脚本。最简单的方法是使用服务安装脚本在同一主机上添加多个服务，例如：</p><pre><code>sudo bash ./install_solr_service.sh solr-7.0.0.tgz -s solr2 -p 8984</code></pre><p>上面显示的命令将 solr2 在端口 8984 上添加一个名为 running&nbsp;的服务，使用 /var/solr2 可写（即“live”）文件；第二台服务器将仍然由 solr 用户拥有并运行，并将使用&nbsp;/opt 其中的 Solr 分发文件。安装 solr2 服务之后，通过执行以下操作验证它是否正常工作：</p><pre><code>sudo service solr2 restartsudo service solr2 status</code></pre><h1 id="升级Solr集群"><a href="#升级Solr集群" class="headerlink" title="升级Solr集群"></a>升级Solr集群</h1><p>本页介绍如何升级使用服务安装脚本安装的现有 Solr 集群。</p><pre><code>Tip：该页面上列出的步骤假定您使用默认的服务名称 solr。如果您使用备用服务名称或 Solr 安装目录，则下面提到的一些路径和命令将必须相应地进行修改。</code></pre><h2 id="规划升级"><a href="#规划升级" class="headerlink" title="规划升级"></a>规划升级</h2><p>以下是在开始升级过程之前需要准备的事项清单：</p><ol><li> 检查 <a href="https://www.w3cschool.cn/solr_doc/solr_doc-us1r2fp5.html">Solr 版本升级说明</a>以确定 Solr 新版本中是否有任何行为改变会影响您的安装。</li><li> 如果不使用复制（即 replicationFactor 小于1的集合），则应对每个集合进行备份。如果您的所有集合都使用复制，则在技术上不需要进行备份，因为您将逐个升级和验证每个节点。</li><li> 确定哪个 Solr 节点当前在 SolrCloud 中托管 Overseer leader 进程，因为您应该最后升级该节点。要确定监督，使用监督状态 API，请参阅：集合 API。</li><li> 如果可能，计划在系统维护时段内执行升级。您将会对集群（每个节点，一个接一个）执行滚动重新启动，但是我们仍然建议在系统使用率最小的时候进行升级。</li><li> 验证集群当前是否正常并且所有副本都处于活动状态，因为您不应该在降级的群集上执行升级。</li><li> 根据新的 Solr JAR 文件重新生成并测试所有自定义的服务器端组件。</li><li>确定 Solr 控制脚本使用的以下变量的值：<ul><li>  ZK_HOST：您当前的 SolrCloud 节点用于连接到 ZooKeeper 的 ZooKeeper 连接字符串；该值对于集群中的所有节点将是相同的。</li><li>  SOLR_HOST：每个 Solr 节点在加入 SolrCloud 集群时用于注册 ZooKeeper 的主机名；此值将用于在启动新的 Solr 进程时设置主机&nbsp;Java系统属性。</li><li>  SOLR_PORT：每个 Solr 节点正在监听的端口，如 8983。</li><li>  SOLR_HOME：每个 Solr 节点的 Solr 主目录的绝对路径；这个目录必须包含一个 solr.xml 文件。该值将使用 solr.solr.home 系统属性传递给新的 Solr 进程。如果您是从 Solr 5.x 或更高版本的安装中进行升级，则这些值通常可以在任何 /var/solr/solr.in.sh 或 /etc/default/solr.in.sh 中发现。</li></ul></li></ol><p>您现在应该准备升级您的集群。在进行生产之前，请在测试或暂存集群中验证此过程。</p><h2 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程<a href="http://lucene.apache.org/solr/guide/7_0/upgrading-a-solr-cluster.html#upgrade-process"></a></h2><p>我们建议的方法是逐个升级每个 Solr 节点。换句话说，您需要停止节点，将其升级到新版本的 Solr，并在移动到下一个节点之前重新启动它。这意味着在很短的时间内，将在您的集群中运行“旧 Solr”和“新 Solr”节点。我们还假设您将把新的 Solr 节点指向您现有的 Solr 主目录，在这个目录下为节点上的每个集合管理 Lucene 索引文件。这意味着你将不需要移动任何索引文件来执行升级。</p><h3 id="步骤1：停止-Solr"><a href="#步骤1：停止-Solr" class="headerlink" title="步骤1：停止 Solr"></a>步骤1：停止 Solr<a href="http://lucene.apache.org/solr/guide/7_0/upgrading-a-solr-cluster.html#step-1-stop-solr"></a></h3><p>从停止要升级的 Solr 节点开始。在停止节点之后，如果使用复制（即，具有 replicationFactor 小于1的集合），则验证在关闭节点上托管的所有领导者是否已经成功迁移到其他副本；您可以通过访问 Solr 管理界面中的云面板来完成此操作。如果不使用复制，那么在关闭的节点上承载的碎片的任何集合将暂时脱机。</p><h3 id="步骤2：将-Solr-作为服务安装"><a href="#步骤2：将-Solr-作为服务安装" class="headerlink" title="步骤2：将 Solr 作为服务安装"></a>步骤2：将 Solr 作为服务安装</h3><p>请按照说明将 Solr 作为服务安装在 Linux 上，记录在 Taking&nbsp;Solr&nbsp;to&nbsp;Production。使用该 -n 参数可避免安装程序脚本自动启动 Solr。您需要更新 /etc/default/solr.in.sh，它包含在下一步中完成升级过程的文件。</p><pre><code>Tip：如果您有一个/var/solr/solr.in.sh用于现有 Solr 安装的文件，则运行该install_solr_service.sh脚本会将该文件移动到新的位置：/etc/default/solr.in.sh。     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</code></pre><h3 id="步骤3：设置环境变量覆盖"><a href="#步骤3：设置环境变量覆盖" class="headerlink" title="步骤3：设置环境变量覆盖"></a>步骤3：设置环境变量覆盖</h3><p>用文本编辑器打开 /etc/default/solr.in.sh，并验证以下变量设置是否正确，或根据需要将它们添加到包含文件的底部：</p><pre><code>ZK_HOST=SOLR_HOST=SOLR_PORT=SOLR_HOME=</code></pre><p>确保您计划拥有 Solr 进程的用户是该 SOLR_HOME 目录的所有者。举例来说，如果您计划将 Solr 作为&nbsp;“Solr” 用户并且 SOLR_HOME 作为 /var/solr/data，那么您需要：</p><pre><code>sudo chown -R solr: /var/solr/data</code></pre><h3 id="步骤4：启动-Solr"><a href="#步骤4：启动-Solr" class="headerlink" title="步骤4：启动 Solr"></a>步骤4：启动 Solr<a href="http://lucene.apache.org/solr/guide/7_0/upgrading-a-solr-cluster.html#step-4-start-solr"></a></h3><p>您现在准备通过执行以下操作来启动升级后的 Solr 节点：sudo service solr start。升级后的实例将加入现有集群，因为你使用的 SOLR_HOME、SOLR_PORT 以及SOLR_HOST 是由旧的 Solr 节点使用的设置；因此，新的服务器将看起来像旧节点到正在运行的集群。确保查看 /var/solr/logs/solr.log 在启动过程中记录的错误。</p><h3 id="步骤5：运行-Healthcheck"><a href="#步骤5：运行-Healthcheck" class="headerlink" title="步骤5：运行 Healthcheck"></a>步骤5：运行 Healthcheck<a href="http://lucene.apache.org/solr/guide/7_0/upgrading-a-solr-cluster.html#step-5-run-healthcheck"></a></h3><p>在继续升级群集中的下一个节点之前，应该对已升级的节点上承载的所有集合运行 Solr&nbsp;healthcheck 命令。例如，如果新升级的节点承载 MyDocuments 集合的副本，则可以运行以下命令（将 ZK_HOST 替换为 ZooKeeper 连接字符串）：</p><pre><code>/opt/solr/bin/solr healthcheck -c MyDocuments -z ZK_HOST</code></pre><p>查找有关该集合的任何副本的任何报告问题。</p><p>最后，对集群中的所有节点重复步骤1-5。</p><h1 id="IndexUpgrader工具"><a href="#IndexUpgrader工具" class="headerlink" title="IndexUpgrader工具"></a>IndexUpgrader工具</h1><p>Lucene 发行版包含一个 IndexUpgrader 工具，它可以将以前 Lucene 版本的索引升级到当前的文件格式。</p><p>该工具可以从命令行使用，也可以在 Java 中实例化和执行。</p><p>在 Solr 发行版中，Lucene 文件位于 ./server/solr-webapp/webapp/WEB-INF/lib。运行该工具时，需要在类路径中包含 lucene-core-<version>.jar 和 lucene-backwards-codecs-<version>.jar。</version></version></p><pre><code>java -cp lucene-core-6.0.0.jar:lucene-backward-codecs-6.0.0.jar org.apache.lucene.index.IndexUpgrader [-delete-prior-commits] [-verbose] /path/to/index</code></pre><p>这个工具只保留索引中的最后一个 commit。由于这个原因，如果传入的索引有多个提交，工具默认拒绝运行。指定 -delete-prior-commits 以重写此操作，允许该工具删除除了最后一个提交之外的所有操作。</p><p>升级大型索引可能需要很长时间。作为一个经验法则，升级过程大约是每分钟1GB。</p><pre><code>注意：如果索引在执行之前部分升级（例如添加了文档），则该工具可能会对文档重新排序。如果您的应用程序依赖于文档 ID 的单调性(这意味着文档将被添加到索引中的顺序被保留)，那么请改为使用完整的 forceMerge。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Zuul：API网关服务</title>
      <link href="/2019/12/25/spring-cloud-zuul-api-wang-guan-fu-wu/"/>
      <url>/2019/12/25/spring-cloud-zuul-api-wang-guan-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Zuul：API网关服务"><a href="#Spring-Cloud-Zuul：API网关服务" class="headerlink" title="Spring Cloud Zuul：API网关服务"></a>Spring Cloud Zuul：API网关服务</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spring Cloud Zuul 是Spring Cloud Netflix 子项目的核心组件之一，可以作为微服务架构中的API网关使用，支持动态路由与过滤功能，本文将对其用法进行详细介绍。</p><h2 id="Zuul简介"><a href="#Zuul简介" class="headerlink" title="Zuul简介"></a>Zuul简介</h2><p>API网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。API网关的定义类似于设计模式中的门面模式，它相当于整个微服务架构中的门面，所有客户端的访问都通过它来进行路由及过滤。它实现了请求路由、负载均衡、校验过滤、服务容错、服务聚合等功能。</p><h2 id="创建一个zuul-proxy模块"><a href="#创建一个zuul-proxy模块" class="headerlink" title="创建一个zuul-proxy模块"></a>创建一个zuul-proxy模块</h2><blockquote><p>这里我们创建一个zuul-proxy模块来演示zuul的常用功能。</p></blockquote><h3 id="在pom-xml中添加相关依赖"><a href="#在pom-xml中添加相关依赖" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml中进行配置"><a href="#在application-yml中进行配置" class="headerlink" title="在application.yml中进行配置"></a>在application.yml中进行配置</h3><pre class="line-numbers language-none"><code class="language-none">server:  port: 8801spring:  application:    name: zuul-proxyeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在启动类上添加-EnableZuulProxy注解来启用Zuul的API网关功能"><a href="#在启动类上添加-EnableZuulProxy注解来启用Zuul的API网关功能" class="headerlink" title="在启动类上添加@EnableZuulProxy注解来启用Zuul的API网关功能"></a>在启动类上添加@EnableZuulProxy注解来启用Zuul的API网关功能</h3><pre class="line-numbers language-none"><code class="language-none">@EnableZuulProxy@EnableDiscoveryClient@SpringBootApplicationpublic class ZuulProxyApplication {    public static void main(String[] args) {        SpringApplication.run(ZuulProxyApplication.class, args);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="启动相关服务"><a href="#启动相关服务" class="headerlink" title="启动相关服务"></a>启动相关服务</h3><p>这里我们通过启动eureka-server，两个user-service，feign-service和zuul-proxy来演示Zuul的常用功能，启动后注册中心显示如下。</p><p><img src="http://image.lichongbing.com/static/bf9cd375a67b23c03f17046d7ec50735.png" alt="16db5cb54337d537.png"></p><h3 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h3><ul><li><p>  我们可以通过修改application.yml中的配置来配置路由规则，这里我们将匹配<code>/userService/**</code>的请求路由到user-service服务上去，匹配<code>/feignService/**</code>的请求路由到feign-service上去。</p><pre class="line-numbers language-none"><code class="language-none">zuul:  routes: #给服务配置路由    user-service:      path: /userService/**    feign-service:      path: /feignService/**复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>  访问<a href="http://localhost:8801/userService/user/1">http://localhost:8801/userService/user/1</a>可以发现请求路由到了user-service上了；</p></li><li><p>  访问<a href="http://localhost:8801/feignService/user/1">http://localhost:8801/feignService/user/1</a>可以发现请求路由到了feign-service上了。</p></li></ul><h3 id="默认路由规则"><a href="#默认路由规则" class="headerlink" title="默认路由规则"></a>默认路由规则</h3><ul><li><p>  Zuul和Eureka结合使用，可以实现路由的自动配置，自动配置的路由以服务名称为匹配路径，相当于如下配置：</p><pre class="line-numbers language-none"><code class="language-none">zuul:  routes: #给服务配置路由    user-service:      path: /user-service/**    feign-service:      path: /feign-service/**复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>  访问<a href="http://localhost:8801/user-service/user/1">http://localhost:8801/user-service/user/1</a>同样可以路由到了user-service上了；</p></li><li><p>  访问<a href="http://localhost:8801/feign-service/user/1">http://localhost:8801/feign-service/user/1</a>同样可以路由到了feign-service上了。</p></li><li><p>  如果不想使用默认的路由规则，可以添加以下配置来忽略默认路由配置：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">zuul:  ignored-services: user-service,feign-service #关闭默认路由配置复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="负载均衡功能"><a href="#负载均衡功能" class="headerlink" title="负载均衡功能"></a>负载均衡功能</h3><p>多次调用<a href="http://localhost:8801/user-service/user/1">http://localhost:8801/user-service/user/1</a>进行测试，可以发现运行在8201和8202的user-service服务交替打印如下信息。</p><pre class="line-numbers language-none"><code class="language-none">2019-10-05 10:31:58.738  INFO 11520 --- [nio-8202-exec-5] c.macro.cloud.controller.UserController  : 根据id获取用户信息，用户名称为：macro 2019-10-05 10:32:00.356  INFO 11520 --- [nio-8202-exec-6] c.macro.cloud.controller.UserController  : 根据id获取用户信息，用户名称为：macro 复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置访问前缀"><a href="#配置访问前缀" class="headerlink" title="配置访问前缀"></a>配置访问前缀</h3><p>我们可以通过以下配置来给网关路径添加前缀，此处添加了/proxy前缀，这样我们需要访问<a href="http://localhost:8801/proxy/user-service/user/1">http://localhost:8801/proxy/user-service/user/1</a>才能访问到user-service中的接口。</p><pre class="line-numbers language-none"><code class="language-none">zuul:  prefix: /proxy #给网关路由添加前缀复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Header过滤及重定向添加Host"><a href="#Header过滤及重定向添加Host" class="headerlink" title="Header过滤及重定向添加Host"></a>Header过滤及重定向添加Host</h3><ul><li>  Zuul在请求路由时，默认会过滤掉一些敏感的头信息，以下配置可以防止路由时的Cookie及Authorization的丢失：<pre class="line-numbers language-none"><code class="language-none">zuul:  sensitive-headers: Cookie,Set-Cookie,Authorization #配置过滤敏感的请求头信息，设置为空就不会过滤复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>  Zuul在请求路由时，不会设置最初的host头信息，以下配置可以解决：</li></ul><pre class="line-numbers language-none"><code class="language-none">zuul:  add-host-header: true #设置为true重定向是会添加host请求头复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查看路由信息"><a href="#查看路由信息" class="headerlink" title="查看路由信息"></a>查看路由信息</h3><blockquote><p>我们可以通过SpringBoot Actuator来查看Zuul中的路由信息。</p></blockquote><ul><li>  在pom.xml中添加相关依赖：<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  修改application.yaml配置文件，开启查看路由的端点：<pre class="line-numbers language-none"><code class="language-none">management:  endpoints:    web:      exposure:        include: 'routes'复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  通过访问<a href="http://localhost:8801/actuator/routes">http://localhost:8801/actuator/routes</a>查看简单路由信息：</li></ul><p><img src="http://image.lichongbing.com/static/49c5cde92d28c70c290b5cdf3d53c827.png" alt="16db5cb5452f5a0c.png"></p><ul><li>  通过访问<a href="http://localhost:8801/actuator/routes">http://localhost:8801/actuator/routes/details</a>查看详细路由信息：</li></ul><p><img src="http://image.lichongbing.com/static/76c0ee6d414cd6bbbc0ba85440446733.png" alt="16db5cb546e5c339.png"></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><blockquote><p>路由与过滤是Zuul的两大核心功能，路由功能负责将外部请求转发到具体的服务实例上去，是实现统一访问入口的基础，过滤功能负责对请求过程进行额外的处理，是请求校验过滤及服务聚合的基础。</p></blockquote><h3 id="过滤器类型"><a href="#过滤器类型" class="headerlink" title="过滤器类型"></a>过滤器类型</h3><blockquote><p>Zuul中有以下几种典型的过滤器类型。</p></blockquote><ul><li>  pre：在请求被路由到目标服务前执行，比如权限校验、打印日志等功能；</li><li>  routing：在请求被路由到目标服务时执行，这是使用Apache HttpClient或Netflix Ribbon构建和发送原始HTTP请求的地方；</li><li>  post：在请求被路由到目标服务后执行，比如给目标服务的响应添加头信息，收集统计数据等功能；</li><li>  error：请求在其他阶段发生错误时执行。</li></ul><h3 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h3><blockquote><p>下图描述了一个HTTP请求到达API网关后，如何在各种不同类型的过滤器中流转的过程。</p></blockquote><p><img src="http://image.lichongbing.com/static/18f752b4ff7dc28d19a01e37d3216a9d.png" alt="16db5cb546faed9a.png"></p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><blockquote><p>接下来我们自定义一个过滤器来演示下过滤器的作用。</p></blockquote><h4 id="添加PreLogFilter类继承ZuulFilter"><a href="#添加PreLogFilter类继承ZuulFilter" class="headerlink" title="添加PreLogFilter类继承ZuulFilter"></a>添加PreLogFilter类继承ZuulFilter</h4><blockquote><p>这是一个前置过滤器，用于在请求路由到目标服务前打印请求日志。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/9/9. */@Componentpublic class PreLogFilter extends ZuulFilter {    private Logger LOGGER = LoggerFactory.getLogger(this.getClass());    /**     * 过滤器类型，有pre、routing、post、error四种。     */    @Override    public String filterType() {        return "pre";    }    /**     * 过滤器执行顺序，数值越小优先级越高。     */    @Override    public int filterOrder() {        return 1;    }    /**     * 是否进行过滤，返回true会执行过滤。     */    @Override    public boolean shouldFilter() {        return true;    }    /**     * 自定义的过滤器逻辑，当shouldFilter()返回true时会执行。     */    @Override    public Object run() throws ZuulException {        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        String host = request.getRemoteHost();        String method = request.getMethod();        String uri = request.getRequestURI();        LOGGER.info("Remote host:{},method:{},uri:{}", host, method, uri);        return null;    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器功能演示"><a href="#过滤器功能演示" class="headerlink" title="过滤器功能演示"></a>过滤器功能演示</h4><p>添加过滤器后，我们访问<a href="http://localhost:8801/user-service/user/1">http://localhost:8801/user-service/user/1</a>测试下，会打印如下日志。</p><pre><code>2019-10-05 15:13:10.232  INFO 11040 --- [nio-8801-exec-7] com.macro.cloud.filter.PreLogFilter      : Remote host:0:0:0:0:0:0:0:1,method:GET,uri:/user-service/user/1复制代码</code></pre><h3 id="核心过滤器"><a href="#核心过滤器" class="headerlink" title="核心过滤器"></a>核心过滤器</h3><table><thead><tr><th>过滤器名称</th><th>过滤类型</th><th>优先级</th><th>过滤器的作用</th></tr></thead><tbody><tr><td>ServletDetectionFilter</td><td>pre</td><td>-3</td><td>检测当前请求是通过DispatcherServlet处理运行的还是ZuulServlet运行处理的。</td></tr><tr><td>Servlet30WrapperFilter</td><td>pre</td><td>-2</td><td>对原始的HttpServletRequest进行包装。</td></tr><tr><td>FormBodyWrapperFilter</td><td>pre</td><td>-1</td><td>将Content-Type为application/x-www-form-urlencoded或multipart/form-data的请求包装成FormBodyRequestWrapper对象。</td></tr><tr><td>DebugFilter</td><td>route</td><td>1</td><td>根据zuul.debug.request的配置来决定是否打印debug日志。</td></tr><tr><td>PreDecorationFilter</td><td>route</td><td>5</td><td>对当前请求进行预处理以便执行后续操作。</td></tr><tr><td>RibbonRoutingFilter</td><td>route</td><td>10</td><td>通过Ribbon和Hystrix来向服务实例发起请求，并将请求结果进行返回。</td></tr><tr><td>SimpleHostRoutingFilter</td><td>route</td><td>100</td><td>只对请求上下文中有routeHost参数的进行处理，直接使用HttpClient向routeHost对应的物理地址进行转发。</td></tr><tr><td>SendForwardFilter</td><td>route</td><td>500</td><td>只对请求上下文中有forward.to参数的进行处理，进行本地跳转。</td></tr><tr><td>SendErrorFilter</td><td>post</td><td>0</td><td>当其他过滤器内部发生异常时的会由它来进行处理，产生错误响应。</td></tr><tr><td>SendResponseFilter</td><td>post</td><td>1000</td><td>利用请求上下文的响应信息来组织请求成功的响应内容。</td></tr></tbody></table><h3 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h3><ul><li>  我们可以对过滤器进行禁用的配置，配置格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">    zuul:      filterClassName:        filter:          disable: true     复制代码*   以下是禁用PreLogFilter的示例配置：    zuul:      PreLogFilter:        pre:          disable: true     复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ribbon和Hystrix的支持"><a href="#Ribbon和Hystrix的支持" class="headerlink" title="Ribbon和Hystrix的支持"></a>Ribbon和Hystrix的支持</h2><blockquote><p>由于Zuul自动集成了Ribbon和Hystrix，所以Zuul天生就有负载均衡和服务容错能力，我们可以通过Ribbon和Hystrix的配置来配置Zuul中的相应功能。</p></blockquote><ul><li>  可以使用Hystrix的配置来设置路由转发时HystrixCommand的执行超时时间：</li></ul><pre class="line-numbers language-none"><code class="language-none">hystrix:  command: #用于控制HystrixCommand的行为    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  可以使用Ribbon的配置来设置路由转发时请求连接及处理的超时时间：</li></ul><pre class="line-numbers language-none"><code class="language-none">ribbon: #全局配置  ConnectTimeout: 1000 #服务请求连接超时时间（毫秒）  ReadTimeout: 3000 #服务请求处理超时时间（毫秒）复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><pre class="line-numbers language-none"><code class="language-none">zuul:  routes: #给服务配置路由    user-service:      path: /userService/**    feign-service:      path: /feignService/**  ignored-services: user-service,feign-service #关闭默认路由配置  prefix: /proxy #给网关路由添加前缀  sensitive-headers: Cookie,Set-Cookie,Authorization #配置过滤敏感的请求头信息，设置为空就不会过滤  add-host-header: true #设置为true重定向是会添加host请求头  retryable: true # 关闭重试机制  PreLogFilter:    pre:      disable: false #控制是否启用过滤器复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用到的模块"><a href="#使用到的模块" class="headerlink" title="使用到的模块"></a>使用到的模块</h2><pre class="line-numbers language-none"><code class="language-none">springcloud-learning├── eureka-server -- eureka注册中心├── user-service -- 提供User对象CRUD接口的服务├── feign-service -- feign服务调用测试服务└── zuul-proxy -- zuul作为网关的测试服务复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/macrozheng/springcloud-learning">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构下的自动化部署，使用Jenkins来实现！</title>
      <link href="/2019/12/25/wei-fu-wu-jia-gou-xia-de-zi-dong-hua-bu-shu-shi-yong-jenkins-lai-shi-xian/"/>
      <url>/2019/12/25/wei-fu-wu-jia-gou-xia-de-zi-dong-hua-bu-shu-shi-yong-jenkins-lai-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务架构下的自动化部署，使用Jenkins来实现！"><a href="#微服务架构下的自动化部署，使用Jenkins来实现！" class="headerlink" title="微服务架构下的自动化部署，使用Jenkins来实现！"></a>微服务架构下的自动化部署，使用Jenkins来实现！</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在微服务架构中，随着服务越来越多，服务的打包部署就会成为一个相当麻烦的事情。比如说我的<code>mall-swarm</code>项目目前就有8个服务需要部署，有没有什么办法让我们部署一次之后，只要点击执行就可以自动部署呢？当然有！下面我们使用Jenkins来完成一个微服务架构中的自动化部署工作。</p><h2 id="Jenkins的基本使用"><a href="#Jenkins的基本使用" class="headerlink" title="Jenkins的基本使用"></a>Jenkins的基本使用</h2><p>关于Jenkins的基本使用可以参考：<a href="https://juejin.im/post/5df780d3e51d4557ff140b30">使用Jenkins一键打包部署SpringBoot应用，就是这么6！</a></p><h2 id="执行脚本准备"><a href="#执行脚本准备" class="headerlink" title="执行脚本准备"></a>执行脚本准备</h2><blockquote><p>首先我们先把需要远程执行的脚本准备好。</p></blockquote><ul><li>  脚本文件都存放在了<code>mall-swarm</code>项目的<code>/document/sh</code>目录下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/18/16f1920aeb3ec6e1?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  上传脚本前在IDEA中修改所有脚本文件的换行符格式为<code>LF</code>，否则脚本会无法执行；</li></ul><p><img src="http://image.lichongbing.com/static/f2de5ac48e7adea3b900f50524874145.png" alt="16f1920aebef6288.png"></p><ul><li>  将所有脚本文件上传到指定目录，这里我们上传到<code>/mydata/sh</code>目录下；</li></ul><p><img src="http://image.lichongbing.com/static/231e00faa4dfe5b041eafdeace4fa60c.png" alt="16f1920aebc9e5b3.png"></p><ul><li><p>将所有脚本文件都修改为可执行文件:</p><p>  chmod +x ./mall-*<br>  复制代码</p></li></ul><h2 id="Jenkins中创建任务"><a href="#Jenkins中创建任务" class="headerlink" title="Jenkins中创建任务"></a>Jenkins中创建任务</h2><blockquote><p>接下来我们将通过在Jenkins中创建任务来实现自动化部署。由于我们的<code>mall-swarm</code>是个多模块的项目，部署上面和曾经的单模块项目还是有所区别的。</p></blockquote><h3 id="mall-admin"><a href="#mall-admin" class="headerlink" title="mall-admin"></a>mall-admin</h3><blockquote><p>由于各个模块的执行任务的创建都大同小异，下面将详细讲解mall-admin模块任务的创建，其他模块将简略讲解。</p></blockquote><ul><li>  首先我们选择<code>构建一个自由风格的软件项目</code>，然后输入任务名称为mall-admin，配置其Git仓库地址，这里我直接使用了Gitee上面的地址：</li></ul><p><img src="http://image.lichongbing.com/static/a5bc98e6add43ecebdd2baa3e9aa78cc.png" alt="16f1920aed760b06.png"></p><ul><li><p>之后我们创建一个构建，构建<code>mall-swarm</code>项目中的依赖模块，否则当构建可运行的服务模块时会因为无法找到这些模块而构建失败；</p><h1 id="只install-mall-common-mall-mbg-mall-security三个模块"><a href="#只install-mall-common-mall-mbg-mall-security三个模块" class="headerlink" title="只install mall-common,mall-mbg,mall-security三个模块"></a>只install mall-common,mall-mbg,mall-security三个模块</h1><p>  clean install -pl mall-common,mall-mbg,mall-security -am<br>  复制代码</p></li><li><p>  依赖项目构建示意图：</p></li></ul><p><img src="http://image.lichongbing.com/static/055d0d39e6063f2a74a7bb77872d88b8.png" alt="16f1920aef4baa6f.png"></p><ul><li>  再创建一个构建，单独构建并打包mall-admin模块：</li></ul><p><img src="http://image.lichongbing.com/static/4b66840df67325feadb99ad3b022ed91.png" alt="16f1920b1bf0c098.png"></p><ul><li>  添加一个构建来通过SSH去执行远程任务，用于执行mall-admin的运行脚本：</li></ul><p><img src="http://image.lichongbing.com/static/de69be88a79942d6faec6e3b7a3b7d97.png" alt="16f1920b1d790341.png"></p><ul><li>  点击保存，完成mall-admin的执行任务创建。</li></ul><h3 id="mall-registry"><a href="#mall-registry" class="headerlink" title="mall-registry"></a>mall-registry</h3><blockquote><p>mall-registry和其他模块与mall-admin创建任务方式基本一致，只需修改构建模块时的<code>pom.xml</code>文件位置和<code>执行脚本</code>位置即可。</p></blockquote><ul><li>  我们可以直接从mall-admin模块的任务复制一个过来创建：</li></ul><p><img src="http://image.lichongbing.com/static/33f24c846c97be9d6b6e4941d0e9198f.png" alt="16f1920b1ef75e56.png"></p><ul><li>  修改第二个构建中的pom.xml文件位置，改为：<code>${WORKSPACE}/mall-registry/pom.xml</code></li></ul><p><img src="http://image.lichongbing.com/static/8b6d683f4cdf1eb0cbbd9859c2ffa456.png" alt="16f1920b1f3c4339.png"></p><ul><li>  修改第三个构建中的SSH执行脚本文件位置，改为：<code>/mydata/sh/mall-registry.sh</code></li></ul><p><img src="http://image.lichongbing.com/static/b0f4872ca64105f3d1eea2045b484252.png" alt="16f1920b207c1679.png"></p><ul><li>  点击保存，完成mall-registry的执行任务创建。</li></ul><h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><p>其他模块的执行任务创建，参考mall-admin和mall-registry的创建即可。</p><h3 id="任务创建完成"><a href="#任务创建完成" class="headerlink" title="任务创建完成"></a>任务创建完成</h3><p><img src="http://image.lichongbing.com/static/e11d87d6c49ebcbc250d75406427f32d.png" alt="16f1920b4f0eb041.png"></p><h2 id="模块启动顺序问题"><a href="#模块启动顺序问题" class="headerlink" title="模块启动顺序问题"></a>模块启动顺序问题</h2><blockquote><p>关于各个模块的启动顺序问题，<code>mall-registry</code>模块必须第一个启动，<code>mall-config</code>模块必须第二个启动，其他模块没有启动顺序限制。</p></blockquote><p>推荐启动顺序：</p><ul><li>  mall-registry</li><li>  mall-config</li><li>  mall-monitor</li><li>  mall-gateway</li><li>  mall-admin</li><li>  mall-portal</li><li>  mall-search</li><li>  mall-demo</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过在Jenkins中创建任务，完成了微服务架构中服务的打包部署工作，这样当我们每次修改完代码后，只需点击启动任务，就可以实现一键打包部署，省去了频繁打包部署的麻烦。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/macrozheng/mall-swarm">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Jenkins一键打包部署SpringBoot应用，就是这么6！</title>
      <link href="/2019/12/25/shi-yong-jenkins-yi-jian-da-bao-bu-shu-springboot-ying-yong-jiu-shi-zhe-me-6/"/>
      <url>/2019/12/25/shi-yong-jenkins-yi-jian-da-bao-bu-shu-springboot-ying-yong-jiu-shi-zhe-me-6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Jenkins一键打包部署SpringBoot应用，就是这么6！"><a href="#使用Jenkins一键打包部署SpringBoot应用，就是这么6！" class="headerlink" title="使用Jenkins一键打包部署SpringBoot应用，就是这么6！"></a>使用Jenkins一键打包部署SpringBoot应用，就是这么6！</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>任何简单操作的背后，都有一套相当复杂的机制。本文将以SpringBoot应用的在Docker环境下的打包部署为例，详细讲解如何使用Jenkins一键打包部署SpringBoot应用。</p><h2 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h2><p>Jenkins是开源CI&amp;CD软件领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要。我们可以用Jenkins来构建和部署我们的项目，比如说从我们的代码仓库获取代码，然后将我们的代码打包成可执行的文件，之后通过远程的ssh工具执行脚本来运行我们的项目。</p><h2 id="Jenkins的安装及配置"><a href="#Jenkins的安装及配置" class="headerlink" title="Jenkins的安装及配置"></a>Jenkins的安装及配置</h2><h3 id="Docker环境下的安装"><a href="#Docker环境下的安装" class="headerlink" title="Docker环境下的安装"></a>Docker环境下的安装</h3><ul><li><p>  下载Jenkins的Docker镜像：</p><pre class="line-numbers language-none"><code class="language-none">docker pull jenkins/jenkins:lts复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>  在Docker容器中运行Jenkins：</p><pre class="line-numbers language-none"><code class="language-none">docker run -p 8080:8080 -p 50000:5000 --name jenkins \-u root \-v /mydata/jenkins_home:/var/jenkins_home \-d jenkins/jenkins:lts复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Jenkins的配置"><a href="#Jenkins的配置" class="headerlink" title="Jenkins的配置"></a>Jenkins的配置</h3></li><li><p>  运行成功后访问该地址登录Jenkins，第一次登录需要输入管理员密码：<a href="http://192.168.6.132:8080/">http://192.168.6.132:8080/</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b1cbb1eb?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  使用管理员密码进行登录，可以使用以下命令从容器启动日志中获取管理密码：<pre class="line-numbers language-none"><code class="language-none">docker logs jenkins复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>  从日志中获取管理员密码：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b3cca69f?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  选择安装插件方式，这里我们直接安装推荐的插件：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b4262d5d?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  进入插件安装界面，联网等待插件安装：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b557d7dc?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  安装完成后，创建管理员账号：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b7cbc2e9?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  进行实例配置，配置Jenkins的URL：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2b85b35da?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  点击系统管理-&gt;插件管理，进行一些自定义的插件安装：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2e7033b04?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li><p>确保以下插件被正确安装：</p><ul><li>  根据角色管理权限的插件：Role-based Authorization Strategy</li><li>  远程使用ssh的插件：SSH plugin</li></ul></li><li><p>  通过系统管理-&gt;全局工具配置来进行全局工具的配置，比如maven的配置：</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2e381590c?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  新增maven的安装配置：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2ed6f1b3f?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  在系统管理-&gt;系统配置中添加全局ssh的配置，这样Jenkins使用ssh就可以执行远程的linux脚本了：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2edb0380b?imageView2/0/w/1280/h/960/ignore-error/1"></p><h3 id="角色权限管理"><a href="#角色权限管理" class="headerlink" title="角色权限管理"></a>角色权限管理</h3><blockquote><p>我们可以使用Jenkins的角色管理插件来管理Jenkins的用户，比如我们可以给管理员赋予所有权限，运维人员赋予执行任务的相关权限，其他人员只赋予查看权限。</p></blockquote><ul><li>  在系统管理-&gt;全局安全配置中启用基于角色的权限管理：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2f21ddaab?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  进入系统管理-&gt;Manage and Assign Roles界面：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf2f2e22b4e?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  添加角色与权限的关系：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf313099c5a?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  给用户分配角色：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf3150ba3f3?imageView2/0/w/1280/h/960/ignore-error/1"></p><h2 id="打包部署SpringBoot应用"><a href="#打包部署SpringBoot应用" class="headerlink" title="打包部署SpringBoot应用"></a>打包部署SpringBoot应用</h2><blockquote><p>这里我们使用<code>mall-learning</code>项目中的<code>mall-tiny-jenkins</code>模块代码来演示下如何使Jenkins一键打包部署SpringBoot应用。</p></blockquote><h3 id="将代码上传到Git仓库"><a href="#将代码上传到Git仓库" class="headerlink" title="将代码上传到Git仓库"></a>将代码上传到Git仓库</h3><ul><li><p>  首先我们需要安装Gitlab（当然你也可以使用Github或者Gitee），然后将<code>mall-tiny-jenkins</code>中的代码上传到Gitlab中去，Gitlab的使用请参考：<a href="https://mp.weixin.qq.com/s/6GyYlR9lpVcjgYmHMYLi0w">10分钟搭建自己的Git仓库</a></p></li><li><p>  <code>mall-tiny-jenkins</code>项目源码地址：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-jenkins">github.com/macrozheng/…</a></p></li><li><p>  上传完成后Gitlab中的展示效果如下：</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf31365cff4?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  有一点需要<code>注意</code>，要将pom.xml中的dockerHost地址改成你自己的Docker镜像仓库地址：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf3156f3de6?imageView2/0/w/1280/h/960/ignore-error/1"></p><h3 id="执行脚本准备"><a href="#执行脚本准备" class="headerlink" title="执行脚本准备"></a>执行脚本准备</h3><ul><li><p>将<code>mall-tiny-jenkins.sh</code>脚本文件上传到<code>/mydata/sh</code>目录下，脚本内容如下：</p><p>  #!/usr/bin/env bash<br>  app_name=’mall-tiny-jenkins’<br>  docker stop ${app_name}<br>  echo ‘—-stop container—-‘<br>  docker rm ${app_name}<br>  echo ‘—-rm container—-‘<br>  docker run -p 8088:8088 –name ${app_name} <br>  –link mysql:db <br>  -v /etc/localtime:/etc/localtime <br>  -v /mydata/app/${app_name}/logs:/var/logs <br>  -d mall-tiny/${app_name}:1.0-SNAPSHOT<br>  echo ‘—-start container—-‘<br>  复制代码</p></li><li><p>给.sh脚本添加可执行权限：</p><p>  chmod +x ./mall-tiny-jenkins.sh<br>  复制代码</p></li><li><p>windows下的.sh脚本上传到linux上使用，需要修改文件格式，否则会因为有特殊格式存在而无法执行：</p><p>  #使用vim编辑器来修改<br>  vi mall-tiny-jenkins.sh</p><h1 id="查看文件格式，windows上传上来的默认为dos"><a href="#查看文件格式，windows上传上来的默认为dos" class="headerlink" title="查看文件格式，windows上传上来的默认为dos"></a>查看文件格式，windows上传上来的默认为dos</h1><p>  :set ff<br>  #修改文件格式为unix<br>  :set ff=unix<br>  #保存并退出<br>  :wq<br>  复制代码</p></li><li><p>执行.sh脚本，测试使用，可以不执行：</p><p>  ./mall-tiny-jenkins.sh<br>  复制代码</p></li></ul><h3 id="在Jenkins中创建执行任务"><a href="#在Jenkins中创建执行任务" class="headerlink" title="在Jenkins中创建执行任务"></a>在Jenkins中创建执行任务</h3><ul><li>  首先我们需要新建一个任务：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf31dc88646?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  设置任务名称后选择构建一个自由风格的软件项目：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf326373a7d?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  然后在源码管理中添加我们的git仓库地址：<a href="http://192.168.6.132:1080/macrozheng/mall-tiny-jenkins">http://192.168.6.132:1080/macrozheng/mall-tiny-jenkins</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf3332611fb?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  此时需要添加一个凭据，也就是我们git仓库的账号密码：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf33a586597?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  填写完成后选择该凭据，就可以正常连接git仓库了；</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf34218b46e?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  之后我们需要添加一个构建，选择调用顶层maven目标，该构建主要用于把我们的源码打包成Docker镜像并上传到我们的Docker镜像仓库去：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf3499f6f39?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  选择我们的maven版本，然后设置maven命令和指定pom文件位置：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf34d785260?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  之后添加一个执行远程shell脚本的构建，用于在我们的镜像打包完成后执行启动Docker容器的.sh脚本：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf3530a3a6f?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  需要设置执行的shell命令如下：/mydata/sh/mall-tiny-jenkins.sh</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf35eeeeede?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  之后点击保存操作，我们的任务就创建完成了，在任务列表中我们可以点击运行来执行该任务；</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf35ef9f3a3?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  我们可以通过控制台输出来查看整个任务的执行过程：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf37224765a?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  运行成功后，访问该地址即可查看API文档：<a href="http://192.168.6.132:8088/swagger-ui.html">http://192.168.6.132:8088/swagger-ui.html</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/16/16f0ecf378c71f8b?imageView2/0/w/1280/h/960/ignore-error/1"></p><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-jenkins">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mall-swarm微服务商城系统框架学习</title>
      <link href="/2019/12/25/mall-swarm-wei-fu-wu-shang-cheng-xi-tong-kuang-jia-xue-xi/"/>
      <url>/2019/12/25/mall-swarm-wei-fu-wu-shang-cheng-xi-tong-kuang-jia-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="mall-swarm微服务商城系统框架"><a href="#mall-swarm微服务商城系统框架" class="headerlink" title="mall-swarm微服务商城系统框架"></a>mall-swarm微服务商城系统框架</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p><code>mall-swarm</code>是一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch等核心技术，同时提供了基于Vue的管理后台方便快速搭建系统。<code>mall-swarm</code>在电商业务的基础集成了注册中心、配置中心、监控中心、网关等系统功能。</p><h2 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h2><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4d3247551?imageView2/0/w/1280/h/960/ignore-error/1" alt="系统架构图"></p><h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><pre><code>mall├── mall-common -- 工具类及通用代码模块├── mall-mbg -- MyBatisGenerator生成的数据库操作代码模块├── mall-security -- 封装SpringSecurity+JWT的安全认证的模块├── mall-registry -- 基于Eureka的微服务注册中心├── mall-config -- 基于Spring Cloud Config的微服务配置中心├── mall-gateway -- 基于Spring Cloud Gateway的微服务API网关服务├── mall-monitor -- 基于Spring Boot Admin的微服务监控中心├── mall-admin -- 后台管理系统服务├── mall-search -- 基于Elasticsearch的商品搜索系统服务├── mall-portal -- 移动端商城系统服务└── mall-demo -- 微服务远程调用测试服务复制代码</code></pre><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><ul><li>  项目文档<code>mall</code>系列教程：<a href="https://macrozheng.github.io/mall-learning">www.macrozheng.com</a></li><li>  配套<code>Spring Cloud</code>系列教程：<a href="https://github.com/macrozheng/springcloud-learning">github.com/macrozheng/…</a></li></ul><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><ul><li>  后台管理系统： <a href="http://www.macrozheng.com/admin/index.html">www.macrozheng.com/admin/index…</a></li><li>  移动端商城系统：<a href="http://www.macrozheng.com/app/index.html">www.macrozheng.com/app/index.h…</a></li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h3><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Spring Cloud</td><td>微服务框架</td></tr><tr><td>Spring Boot</td><td>容器+MVC框架</td></tr><tr><td>Spring Security</td><td>认证和授权框架</td></tr><tr><td>MyBatis</td><td>ORM框架</td></tr><tr><td>MyBatisGenerator</td><td>数据层代码生成</td></tr><tr><td>PageHelper</td><td>MyBatis物理分页插件</td></tr><tr><td>Swagger-UI</td><td>文档生产工具</td></tr><tr><td>Elasticsearch</td><td>搜索引擎</td></tr><tr><td>RabbitMq</td><td>消息队列</td></tr><tr><td>Redis</td><td>分布式缓存</td></tr><tr><td>MongoDb</td><td>NoSql数据库</td></tr><tr><td>Docker</td><td>应用容器引擎</td></tr><tr><td>Druid</td><td>数据库连接池</td></tr><tr><td>OSS</td><td>对象存储</td></tr><tr><td>JWT</td><td>JWT登录支持</td></tr><tr><td>LogStash</td><td>日志收集</td></tr><tr><td>Lombok</td><td>简化对象封装工具</td></tr><tr><td>Seata</td><td>全局事务管理框架</td></tr></tbody></table><h3 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h3><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Vue</td><td>前端框架</td></tr><tr><td>Vue-router</td><td>路由框架</td></tr><tr><td>Vuex</td><td>全局状态管理框架</td></tr><tr><td>Element</td><td>前端UI框架</td></tr><tr><td>Axios</td><td>前端HTTP框架</td></tr><tr><td>v-charts</td><td>基于Echarts的图表框架</td></tr></tbody></table><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><blockquote><p><code>mall-swarm</code>中使用到的环境和<code>mall</code>项目中大致相同，具体可以查看<a href="https://mp.weixin.qq.com/s/Q9ybpfq8IEdbZmvlaMXJdg">mall在Windows环境下的部署</a>。</p></blockquote><p>简易环境搭建流程：</p><ul><li>  安装IDEA并导入项目源码；</li><li>  安装MySql，创建一个<code>mall</code>数据库，并导入<code>/document/sql/mall.sql</code>文件；</li><li>  安装Redis、Elasticsearch、MongoDB、RabbitMQ等环境。</li></ul><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><blockquote><p><code>mall-swarm</code>项目启动有先后顺序，大家要按照以下顺序启动。</p></blockquote><h4 id="启动注册中心mall-registry"><a href="#启动注册中心mall-registry" class="headerlink" title="启动注册中心mall-registry"></a>启动注册中心<code>mall-registry</code></h4><ul><li>  直接运行com.macro.mall.MallRegistryApplication的main函数即可；</li><li>  运行完成后可以通过注册中心控制台查看：<a href="http://localhost:8001/">http://localhost:8001</a></li></ul><h4 id="启动配置中心mall-config"><a href="#启动配置中心mall-config" class="headerlink" title="启动配置中心mall-config"></a>启动配置中心<code>mall-config</code></h4><ul><li>  直接运行com.macro.mall.MallConfigApplication的main函数即可；</li><li>  访问以下接口获取mall-admin在dev环境下的配置信息：<a href="http://localhost:8301/master/admin-dev.yml">http://localhost:8301/master/admin-dev.yml</a></li></ul><h4 id="启动监控中心mall-monitor"><a href="#启动监控中心mall-monitor" class="headerlink" title="启动监控中心mall-monitor"></a>启动监控中心<code>mall-monitor</code></h4><ul><li>  直接运行com.macro.mall.MallMonitorApplication的main函数即可；</li><li>  运行完成后可以通过监控中心控制台查看：<a href="http://localhost:8101/">http://localhost:8101</a></li><li>  输入账号密码<code>macro:123456</code>可以登录查看。</li></ul><h4 id="启动网关服务mall-gateway"><a href="#启动网关服务mall-gateway" class="headerlink" title="启动网关服务mall-gateway"></a>启动网关服务<code>mall-gateway</code></h4><ul><li>  直接运行com.macro.mall.MallGatewayApplication的main函数即可；</li><li>  访问以下接口获取动态路由规则：<a href="http://localhost:8201/actuator/gateway/routes">http://localhost:8201/actuator/gateway/routes</a></li></ul><h4 id="启动后台管理服务mall-admin"><a href="#启动后台管理服务mall-admin" class="headerlink" title="启动后台管理服务mall-admin"></a>启动后台管理服务<code>mall-admin</code></h4><ul><li>  直接运行com.macro.mall.MallAdminApplication的main函数即可；</li><li>  通过<code>mall-gateway</code>网关服务访问接口文档：<a href="http://localhost:8201/mall-admin/swagger-ui.html">http://localhost:8201/mall-admin/swagger-ui.html</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4d709ef3a?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  登录接口地址：<a href="http://localhost:8201/mall-admin/admin/login">http://localhost:8201/mall-admin/admin/login</a></li><li>  访问登录接口获取到token后放入认证的头信息即可正常访问其他需要登录的接口：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4d7561624?imageView2/0/w/1280/h/960/ignore-error/1"></p><h4 id="启动前台服务mall-portal"><a href="#启动前台服务mall-portal" class="headerlink" title="启动前台服务mall-portal"></a>启动前台服务<code>mall-portal</code></h4><ul><li>  直接运行com.macro.mall.portal.MallPortalApplication的main函数即可；</li><li>  通过<code>mall-gateway</code>网关服务访问接口文档：<a href="http://localhost:8201/mall-portal/swagger-ui.html">http://localhost:8201/mall-portal/swagger-ui.html</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4d935433e?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  登录接口地址：<a href="http://localhost:8201/mall-portal/sso/login">http://localhost:8201/mall-portal/sso/login</a></li><li>  调用需要登录的接口方式同<code>mall-admin</code>。</li></ul><h4 id="启动搜索服务mall-search"><a href="#启动搜索服务mall-search" class="headerlink" title="启动搜索服务mall-search"></a>启动搜索服务<code>mall-search</code></h4><ul><li>  直接运行com.macro.mall.search.MallSearchApplication的main函数即可；</li><li>  通过<code>mall-gateway</code>网关服务访问接口文档：<a href="http://localhost:8201/mall-search/swagger-ui.html">http://localhost:8201/mall-search/swagger-ui.html</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4d94d31fc?imageView2/0/w/1280/h/960/ignore-error/1"></p><h4 id="启动测试服务mall-demo"><a href="#启动测试服务mall-demo" class="headerlink" title="启动测试服务mall-demo"></a>启动测试服务<code>mall-demo</code></h4><ul><li>  直接运行com.macro.mall.MallAdminApplication的main函数即可；</li><li>  通过<code>mall-gateway</code>网关服务访问接口文档：<a href="http://localhost:8201/mall-demo/swagger-ui.html">http://localhost:8201/mall-demo/swagger-ui.html</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac4dab3086a?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  可以通过调用FeignAdminController、FeignPortalController、FeignSearchController来测试使用Feign的远程调用功能。</li></ul><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ul><li>  注册中心服务信息：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac50a9ac036?imageView2/0/w/1280/h/960/ignore-error/1"></p><ul><li>  监控中心服务概览信息：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec1ac5111c02f6?imageView2/0/w/1280/h/960/ignore-error/1"></p><p><img src="http://image.lichongbing.com/static/2b45ff5a92e032f239a1713ff77608f4.png" alt="16ec1ac5113f9534.png"></p><ul><li>  监控中心单应用详情信息：</li></ul><p><img src="http://image.lichongbing.com/static/ba8ae3f051adcc045792b4076c03341c.png" alt="16ec1ac50e4c9c28.png"></p><p><img src="http://image.lichongbing.com/static/ad370cf79bb91ef0afe102ac747ed589.png" alt="16ec1ac5121991a0.png"></p><h2 id="扩展解决方案"><a href="#扩展解决方案" class="headerlink" title="扩展解决方案"></a>扩展解决方案</h2><ul><li>  如果想使用<code>Consul</code>作为注册及配置中心的话请参考：<a href="https://juejin.im/post/5db05582f265da4d4c20180f">Spring Cloud Consul：服务治理与配置中心</a></li><li>  如果想使用<code>Nacos</code>作为注册及配置中心的话请参考：<a href="https://juejin.im/post/5dcbf7bc5188250d1f5a78ea">Spring Cloud Alibaba：Nacos 作为注册中心和配置中心使用</a></li><li>  <code>分布式事务</code>解决方案请参考：<a href="https://juejin.im/post/5dd53a9d5188255d35425a08">使用Seata彻底解决Spring Cloud中的分布式事务问题！</a></li><li>  <code>ELK</code>日志收集系统的搭建请参考：<a href="https://juejin.im/post/5d2738a2f265da1bac404299">SpringBoot应用整合ELK实现日志收集</a>。</li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><blockquote><p>开源不易，觉得本项目有帮助的朋友可以<code>点个Star</code>支持下！</p></blockquote><p><a href="https://github.com/macrozheng/mall-swarm">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用</title>
      <link href="/2019/12/24/spring-cloud-openfeign-ji-yu-ribbon-he-hystrix-de-sheng-ming-shi-fu-wu-diao-yong/"/>
      <url>/2019/12/24/spring-cloud-openfeign-ji-yu-ribbon-he-hystrix-de-sheng-ming-shi-fu-wu-diao-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-OpenFeign：基于Ribbon和Hystrix的声明式服务调用"><a href="#Spring-Cloud-OpenFeign：基于Ribbon和Hystrix的声明式服务调用" class="headerlink" title="Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用"></a>Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spring Cloud OpenFeign 是声明式的服务调用工具，它整合了Ribbon和Hystrix，拥有负载均衡和服务容错功能，本文将对其用法进行详细介绍。</p><h2 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h2><p>Feign是声明式的服务调用工具，我们只需创建一个接口并用注解的方式来配置它，就可以实现对某个服务接口的调用，简化了直接使用RestTemplate来调用服务接口的开发量。Feign具备可插拔的注解支持，同时支持Feign注解、JAX-RS注解及SpringMvc注解。当使用Feign时，Spring Cloud集成了Ribbon和Eureka以提供负载均衡的服务调用及基于Hystrix的服务容错保护功能。</p><h2 id="创建一个feign-service模块"><a href="#创建一个feign-service模块" class="headerlink" title="创建一个feign-service模块"></a>创建一个feign-service模块</h2><blockquote><p>这里我们创建一个feign-service模块来演示feign的常用功能。</p></blockquote><h3 id="在pom-xml中添加相关依赖"><a href="#在pom-xml中添加相关依赖" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml中进行配置"><a href="#在application-yml中进行配置" class="headerlink" title="在application.yml中进行配置"></a>在application.yml中进行配置</h3><pre class="line-numbers language-none"><code class="language-none">server:  port: 8701spring:  application:    name: feign-serviceeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在启动类上添加-EnableFeignClients注解来启用Feign的客户端功能"><a href="#在启动类上添加-EnableFeignClients注解来启用Feign的客户端功能" class="headerlink" title="在启动类上添加@EnableFeignClients注解来启用Feign的客户端功能"></a>在启动类上添加@EnableFeignClients注解来启用Feign的客户端功能</h3><pre class="line-numbers language-none"><code class="language-none">@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class FeignServiceApplication {    public static void main(String[] args) {        SpringApplication.run(FeignServiceApplication.class, args);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加UserService接口完成对user-service服务的接口绑定"><a href="#添加UserService接口完成对user-service服务的接口绑定" class="headerlink" title="添加UserService接口完成对user-service服务的接口绑定"></a>添加UserService接口完成对user-service服务的接口绑定</h3><blockquote><p>我们通过@FeignClient注解实现了一个Feign客户端，其中的value为user-service表示这是对user-service服务的接口调用客户端。我们可以回想下user-service中的UserController，只需将其改为接口，保留原来的SpringMvc注释即可。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/9/5. */@FeignClient(value = "user-service")public interface UserService {    @PostMapping("/user/create")    CommonResult create(@RequestBody User user);    @GetMapping("/user/{id}")    CommonResult&lt;User&gt; getUser(@PathVariable Long id);    @GetMapping("/user/getByUsername")    CommonResult&lt;User&gt; getByUsername(@RequestParam String username);    @PostMapping("/user/update")    CommonResult update(@RequestBody User user);    @PostMapping("/user/delete/{id}")    CommonResult delete(@PathVariable Long id);}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加UserFeignController调用UserService实现服务调用"><a href="#添加UserFeignController调用UserService实现服务调用" class="headerlink" title="添加UserFeignController调用UserService实现服务调用"></a>添加UserFeignController调用UserService实现服务调用</h3><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/8/29. */@RestController@RequestMapping("/user")public class UserFeignController {    @Autowired    private UserService userService;    @GetMapping("/{id}")    public CommonResult getUser(@PathVariable Long id) {        return userService.getUser(id);    }    @GetMapping("/getByUsername")    public CommonResult getByUsername(@RequestParam String username) {        return userService.getByUsername(username);    }    @PostMapping("/create")    public CommonResult create(@RequestBody User user) {        return userService.create(user);    }    @PostMapping("/update")    public CommonResult update(@RequestBody User user) {        return userService.update(user);    }    @PostMapping("/delete/{id}")    public CommonResult delete(@PathVariable Long id) {        return userService.delete(id);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="负载均衡功能演示"><a href="#负载均衡功能演示" class="headerlink" title="负载均衡功能演示"></a>负载均衡功能演示</h2><ul><li>  启动eureka-service，两个user-service，feign-service服务，启动后注册中心显示如下：</li></ul><p><img src="http://image.lichongbing.com/static/9a1a81877d428bfcea9b6e0eb8626062.png" alt="16dab6a6c4ab5398.png"></p><ul><li>  多次调用<a href="http://localhost:8701/user/1">http://localhost:8701/user/1</a>进行测试，可以发现运行在8201和8202的user-service服务交替打印如下信息：</li></ul><pre class="line-numbers language-none"><code class="language-none">2019-10-04 15:15:34.829  INFO 9236 --- [nio-8201-exec-5] c.macro.cloud.controller.UserController  : 根据id获取用户信息，用户名称为：macro2019-10-04 15:15:35.492  INFO 9236 --- [io-8201-exec-10] c.macro.cloud.controller.UserController  : 根据id获取用户信息，用户名称为：macro2019-10-04 15:15:35.825  INFO 9236 --- [nio-8201-exec-9] c.macro.cloud.controller.UserController  : 根据id获取用户信息，用户名称为：macro复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Feign中的服务降级"><a href="#Feign中的服务降级" class="headerlink" title="Feign中的服务降级"></a>Feign中的服务降级</h2><blockquote><p>Feign中的服务降级使用起来非常方便，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可，下面我们为UserService接口添加一个服务降级实现类。</p></blockquote><h3 id="添加服务降级实现类UserFallbackService"><a href="#添加服务降级实现类UserFallbackService" class="headerlink" title="添加服务降级实现类UserFallbackService"></a>添加服务降级实现类UserFallbackService</h3><blockquote><p>需要注意的是它实现了UserService接口，并且对接口中的每个实现方法进行了服务降级逻辑的实现。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/9/5. */@Componentpublic class UserFallbackService implements UserService {    @Override    public CommonResult create(User user) {        User defaultUser = new User(-1L, "defaultUser", "123456");        return new CommonResult&lt;&gt;(defaultUser);    }    @Override    public CommonResult&lt;User&gt; getUser(Long id) {        User defaultUser = new User(-1L, "defaultUser", "123456");        return new CommonResult&lt;&gt;(defaultUser);    }    @Override    public CommonResult&lt;User&gt; getByUsername(String username) {        User defaultUser = new User(-1L, "defaultUser", "123456");        return new CommonResult&lt;&gt;(defaultUser);    }    @Override    public CommonResult update(User user) {        return new CommonResult("调用失败，服务被降级",500);    }    @Override    public CommonResult delete(Long id) {        return new CommonResult("调用失败，服务被降级",500);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改UserService接口，设置服务降级处理类为UserFallbackService"><a href="#修改UserService接口，设置服务降级处理类为UserFallbackService" class="headerlink" title="修改UserService接口，设置服务降级处理类为UserFallbackService"></a>修改UserService接口，设置服务降级处理类为UserFallbackService</h3><blockquote><p>修改@FeignClient注解中的参数，设置fallback为UserFallbackService.class即可。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">@FeignClient(value = "user-service",fallback = UserFallbackService.class)public interface UserService {}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改application-yml，开启Hystrix功能"><a href="#修改application-yml，开启Hystrix功能" class="headerlink" title="修改application.yml，开启Hystrix功能"></a>修改application.yml，开启Hystrix功能</h3><pre class="line-numbers language-none"><code class="language-none">feign:  hystrix:    enabled: true #在Feign中开启Hystrix复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务降级功能演示"><a href="#服务降级功能演示" class="headerlink" title="服务降级功能演示"></a>服务降级功能演示</h2><ul><li><p>  关闭两个user-service服务，重新启动feign-service;</p></li><li><p>  调用<a href="http://localhost:8701/user/1">http://localhost:8701/user/1</a>进行测试，可以发现返回了服务降级信息。</p></li></ul><p><img src="http://image.lichongbing.com/static/bd25fc24a1761137ee08735528e4e7b2.png" alt="16dab6a6c536b333.png"><br>日志打印功能</p><hr><blockquote><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节。</p></blockquote><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><ul><li>  NONE：默认的，不显示任何日志；</li><li>  BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li><li>  HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息；</li><li>  FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><h3 id="通过配置开启更为详细的日志"><a href="#通过配置开启更为详细的日志" class="headerlink" title="通过配置开启更为详细的日志"></a>通过配置开启更为详细的日志</h3><blockquote><p>我们通过java配置来使Feign打印最详细的Http请求日志信息。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/9/5. */@Configurationpublic class FeignConfig {    @Bean    Logger.Level feignLoggerLevel() {        return Logger.Level.FULL;    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml中配置需要开启日志的Feign客户端"><a href="#在application-yml中配置需要开启日志的Feign客户端" class="headerlink" title="在application.yml中配置需要开启日志的Feign客户端"></a>在application.yml中配置需要开启日志的Feign客户端</h3><blockquote><p>配置UserService的日志级别为debug。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">logging:  level:    com.macro.cloud.service.UserService: debug复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><blockquote><p>调用<a href="http://localhost:8701/user/1">http://localhost:8701/user/1</a>进行测试，可以看到以下日志。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">2019-10-04 15:44:03.248 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] ---&gt; GET http://user-service/user/1 HTTP/1.12019-10-04 15:44:03.248 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] ---&gt; END HTTP (0-byte body)2019-10-04 15:44:03.257 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] &lt;--- HTTP/1.1 200 (9ms)2019-10-04 15:44:03.257 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] content-type: application/json;charset=UTF-82019-10-04 15:44:03.258 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] date: Fri, 04 Oct 2019 07:44:03 GMT2019-10-04 15:44:03.258 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] transfer-encoding: chunked2019-10-04 15:44:03.258 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] 2019-10-04 15:44:03.258 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] {"data":{"id":1,"username":"macro","password":"123456"},"message":"操作成功","code":200}2019-10-04 15:44:03.258 DEBUG 5204 --- [-user-service-2] com.macro.cloud.service.UserService      : [UserService#getUser] &lt;--- END HTTP (92-byte body)复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Feign的常用配置"><a href="#Feign的常用配置" class="headerlink" title="Feign的常用配置"></a>Feign的常用配置</h2><h3 id="Feign自己的配置"><a href="#Feign自己的配置" class="headerlink" title="Feign自己的配置"></a>Feign自己的配置</h3><pre class="line-numbers language-none"><code class="language-none">feign:  hystrix:    enabled: true #在Feign中开启Hystrix  compression:    request:      enabled: false #是否对请求进行GZIP压缩      mime-types: text/xml,application/xml,application/json #指定压缩的请求数据类型      min-request-size: 2048 #超过该大小的请求会被压缩    response:      enabled: false #是否对响应进行GZIP压缩logging:  level: #修改日志级别    com.macro.cloud.service.UserService: debug复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Feign中的Ribbon配置"><a href="#Feign中的Ribbon配置" class="headerlink" title="Feign中的Ribbon配置"></a>Feign中的Ribbon配置</h3><p>在Feign中配置Ribbon可以直接使用Ribbon的配置，具体可以参考<a href="https://mp.weixin.qq.com/s/uKteoRrFjUbbl08NG522YQ">Spring Cloud Ribbon：负载均衡的服务调用</a>。</p><h3 id="Feign中的Hystrix配置"><a href="#Feign中的Hystrix配置" class="headerlink" title="Feign中的Hystrix配置"></a>Feign中的Hystrix配置</h3><p>在Feign中配置Hystrix可以直接使用Hystrix的配置，具体可以参考<a href="https://mp.weixin.qq.com/s/lEjojtuH7XOM9emXkd0TkQ">Spring Cloud Hystrix：服务容错保护</a>。</p><h2 id="使用到的模块"><a href="#使用到的模块" class="headerlink" title="使用到的模块"></a>使用到的模块</h2><pre><code>springcloud-learning├── eureka-server -- eureka注册中心├── user-service -- 提供User对象CRUD接口的服务└── feign-service -- feign服务调用测试服务复制代码</code></pre><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/macrozheng/springcloud-learning">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix Dashboard：断路器执行监控</title>
      <link href="/2019/12/24/hystrix-dashboard-duan-lu-qi-zhi-xing-jian-kong/"/>
      <url>/2019/12/24/hystrix-dashboard-duan-lu-qi-zhi-xing-jian-kong/</url>
      
        <content type="html"><![CDATA[<p>Hystrix Dashboard：断路器执行监控</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Hystrix Dashboard 是Spring Cloud中查看Hystrix实例执行情况的一种仪表盘组件，支持查看单个实例和查看集群实例，本文将对其用法进行详细介绍。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hystrix提供了Hystrix Dashboard来实时监控HystrixCommand方法的执行情况。 Hystrix Dashboard可以有效地反映出每个Hystrix实例的运行情况，帮助我们快速发现系统中的问题，从而采取对应措施。</p><h2 id="Hystrix-单个实例监控"><a href="#Hystrix-单个实例监控" class="headerlink" title="Hystrix 单个实例监控"></a>Hystrix 单个实例监控</h2><blockquote><p>我们先通过使用Hystrix Dashboard监控单个Hystrix实例来了解下它的使用方法。</p></blockquote><h3 id="创建一个hystrix-dashboard模块"><a href="#创建一个hystrix-dashboard模块" class="headerlink" title="创建一个hystrix-dashboard模块"></a>创建一个hystrix-dashboard模块</h3><blockquote><p>用来监控hystrix实例的执行情况。</p></blockquote><ul><li>  在pom.xml中添加相关依赖：<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  在application.yml进行配置：<pre class="line-numbers language-none"><code class="language-none">server:  port: 8501spring:  application:    name: hystrix-dashboardeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  在启动类上添加@EnableHystrixDashboard来启用监控功能：<pre class="line-numbers language-none"><code class="language-none">@EnableHystrixDashboard@EnableDiscoveryClient@SpringBootApplicationpublic class HystrixDashboardApplication {    public static void main(String[] args) {        SpringApplication.run(HystrixDashboardApplication.class, args);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动相关服务"><a href="#启动相关服务" class="headerlink" title="启动相关服务"></a>启动相关服务</h3></li></ul><blockquote><p>这次我们需要启动如下服务：eureka-server、user-service、hystrix-service、hystrix-dashboard，启动后注册中心显示如下。</p></blockquote><p><img src="http://image.lichongbing.com/static/fab09f7241c3141fca2529ec17576b6e.png" alt="16d5e5a49eff4329.png"></p><h3 id="Hystrix实例监控演示"><a href="#Hystrix实例监控演示" class="headerlink" title="Hystrix实例监控演示"></a>Hystrix实例监控演示</h3><ul><li>  访问Hystrix Dashboard：<a href="http://localhost:8501/hystrix">http://localhost:8501/hystrix</a></li></ul><p><img src="http://image.lichongbing.com/static/a70013866833962177afd6090d63d14b.png" alt="16d5e5a49f435f29.png"></p><ul><li>  填写好信息后点击监控按钮，这里我们需要注意的是，由于我们本地不支持https，所以我们的地址需要填入的是http，否则会无法获取监控信息；</li></ul><p><img src="http://image.lichongbing.com/static/0d266de4b0ab7764e7ef60e8c145bab0.png" alt="16d5e5a49ff037d3.png"></p><ul><li>  还有一点值得注意的是，被监控的hystrix-service服务需要开启Actuator的hystrix.stream端点，配置信息如下：<pre class="line-numbers language-none"><code class="language-none">management:  endpoints:    web:      exposure:        include: 'hystrix.stream' #暴露hystrix监控端点复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  调用几次hystrix-service的接口：<a href="http://localhost:8401/user/testCommand/1">http://localhost:8401/user/testCommand/1</a></li></ul><p><img src="http://image.lichongbing.com/static/edcf5040450ee05820bbde8d5f1f888e.png" alt="16d5e5a4a00634c6.png"></p><ul><li>  可以发现曾经我们在@HystrixCommand中添加的commandKey和threadPoolKey属性都显示在上面了，并且有7次调用都成功了。</li></ul><h3 id="Hystrix-Dashboard-图表解读"><a href="#Hystrix-Dashboard-图表解读" class="headerlink" title="Hystrix Dashboard 图表解读"></a>Hystrix Dashboard 图表解读</h3><blockquote><p>图表解读如下，需要注意的是，小球代表该实例健康状态及流量情况，颜色越显眼，表示实例越不健康，小球越大，表示实例流量越大。曲线表示Hystrix实例的实时流量变化。</p></blockquote><p><img src="http://image.lichongbing.com/static/e4c06fac89c938e78bba882d6761b110.png" alt="16d5e5a4a3c0b7f4.png"></p><h2 id="Hystrix-集群实例监控"><a href="#Hystrix-集群实例监控" class="headerlink" title="Hystrix 集群实例监控"></a>Hystrix 集群实例监控</h2><blockquote><p>这里我们使用Turbine来聚合hystrix-service服务的监控信息，然后我们的hystrix-dashboard服务就可以从Turbine获取聚合好的监控信息展示给我们了。</p></blockquote><h3 id="创建一个turbine-service模块"><a href="#创建一个turbine-service模块" class="headerlink" title="创建一个turbine-service模块"></a>创建一个turbine-service模块</h3><blockquote><p>用来聚合hystrix-service的监控信息。</p></blockquote><ul><li>  在pom.xml中添加相关依赖：<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  在application.yml进行配置，主要是添加了Turbine相关配置：<pre class="line-numbers language-none"><code class="language-none">server:  port: 8601spring:  application:    name: turbine-serviceeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/turbine:  app-config: hystrix-service #指定需要收集信息的服务名称  cluster-name-expression: new String('default') #指定服务所属集群  combine-host-port: true #以主机名和端口号来区分服务复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  在启动类上添加@EnableTurbine来启用Turbine相关功能：<pre class="line-numbers language-none"><code class="language-none">@EnableTurbine@EnableDiscoveryClient@SpringBootApplicationpublic class TurbineServiceApplication {    public static void main(String[] args) {        SpringApplication.run(TurbineServiceApplication.class, args);    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动相关服务-1"><a href="#启动相关服务-1" class="headerlink" title="启动相关服务"></a>启动相关服务</h3></li></ul><blockquote><p>使用application-replica1.yml配置再启动一个hystrix-service服务，启动turbine-service服务，此时注册中心显示如下。</p></blockquote><p><img src="http://image.lichongbing.com/static/9bc6aad2e91bc831461d695f9b41f316.png" alt="16d5e5a4a3b483a7.png"></p><h3 id="Hystrix集群监控演示"><a href="#Hystrix集群监控演示" class="headerlink" title="Hystrix集群监控演示"></a>Hystrix集群监控演示</h3><ul><li><p>  访问Hystrix Dashboard：<a href="http://localhost:8501/hystrix">http://localhost:8501/hystrix</a></p></li><li><p>  添加集群监控地址，需要注意的是我们需要添加的是turbine-service的监控端点地址：</p></li></ul><p><img src="http://image.lichongbing.com/static/c30c9ecb7a583175a7f75eb36d0840c1.png" alt="16d5e5a4d9aab179.png"></p><ul><li>  调用几次hystrix-service的接口：<a href="http://localhost:8401/user/testCommand/1">http://localhost:8401/user/testCommand/1</a>以及<a href="http://localhost:8402/user/testCommand/1">http://localhost:8402/user/testCommand/1</a></li></ul><p><img src="http://image.lichongbing.com/static/1e500816923cf5342dd970aeb79b89bb.png" alt="16d5e5a50256db12.png"></p><ul><li>  可以看到我们的Hystrix实例数量变成了两个。</li></ul><h2 id="使用到的模块"><a href="#使用到的模块" class="headerlink" title="使用到的模块"></a>使用到的模块</h2><pre><code>springcloud-learning├── eureka-server -- eureka注册中心├── user-service -- 提供User对象CRUD接口的服务├── hystrix-service -- hystrix服务调用测试服务├── turbine-service -- 聚合收集hystrix实例监控信息的服务└── hystrix-dashboard -- 展示hystrix实例监控信息的仪表盘复制代码</code></pre><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/macrozheng/springcloud-learning">github.com/macrozheng/…</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Hystrix：服务容错保护</title>
      <link href="/2019/12/24/spring-cloud-hystrix-fu-wu-rong-cuo-bao-hu/"/>
      <url>/2019/12/24/spring-cloud-hystrix-fu-wu-rong-cuo-bao-hu/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能，本文将对其用法进行详细介绍。</p><h2 id="Hystrix-简介"><a href="#Hystrix-简介" class="headerlink" title="Hystrix 简介"></a>Hystrix 简介</h2><p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p><h2 id="创建一个hystrix-service模块"><a href="#创建一个hystrix-service模块" class="headerlink" title="创建一个hystrix-service模块"></a>创建一个hystrix-service模块</h2><blockquote><p>这里我们创建一个hystrix-service模块来演示hystrix的常用功能。</p></blockquote><h3 id="在pom-xml中添加相关依赖"><a href="#在pom-xml中添加相关依赖" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml进行配置"><a href="#在application-yml进行配置" class="headerlink" title="在application.yml进行配置"></a>在application.yml进行配置</h3><p>主要是配置了端口、注册中心地址及user-service的调用路径。</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 8401spring:  application:    name: hystrix-serviceeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/service-url:  user-service: http://user-service```  ### 在启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能```java@EnableCircuitBreaker@EnableDiscoveryClient@SpringBootApplicationpublic class HystrixServiceApplication {    public static void main(String[] args) {        SpringApplication.run(HystrixServiceApplication.class, args);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建UserHystrixController接口用于调用user-service服务"><a href="#创建UserHystrixController接口用于调用user-service服务" class="headerlink" title="创建UserHystrixController接口用于调用user-service服务"></a>创建UserHystrixController接口用于调用user-service服务</h3><h1 id="服务降级演示"><a href="#服务降级演示" class="headerlink" title="服务降级演示"></a>服务降级演示</h1><ul><li>在UserHystrixController中添加用于测试服务降级的接口：</li></ul><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testFallback/{id}")public CommonResult testFallback(@PathVariable Long id) {    return userService.getUser(id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在UserService中添加调用方法与服务降级方法，方法上需要添加@HystrixCommand注解：</li></ul><pre class="line-numbers language-none"><code class="language-none">@HystrixCommand(fallbackMethod = "getDefaultUser")public CommonResult getUser(Long id) {    return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id);}public CommonResult getDefaultUser(@PathVariable Long id) {    User defaultUser = new User(-1L, "defaultUser", "123456");    return new CommonResult&lt;&gt;(defaultUser);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动eureka-server、user-service、hystrix-service服务；</li></ul><ul><li>调用接口进行测试：<a href="http://localhost:8401/user/testFallback/1">http://localhost:8401/user/testFallback/1</a></li></ul><ul><li>关闭user-service服务重新测试该接口，发现已经发生了服务降级：</li></ul><h2 id="HystrixCommand详解"><a href="#HystrixCommand详解" class="headerlink" title="@HystrixCommand详解"></a>@HystrixCommand详解</h2><h3 id="HystrixCommand中的常用参数"><a href="#HystrixCommand中的常用参数" class="headerlink" title="@HystrixCommand中的常用参数"></a>@HystrixCommand中的常用参数</h3><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。</li></ul><h3 id="设置命令、分组及线程池名称"><a href="#设置命令、分组及线程池名称" class="headerlink" title="设置命令、分组及线程池名称"></a>设置命令、分组及线程池名称</h3><ul><li>在UserHystrixController中添加测试接口：</li></ul><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testCommand/{id}")public CommonResult testCommand(@PathVariable Long id) {    return userService.getUserCommand(id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在UserService中添加方式实现功能：</p><pre class="line-numbers language-none"><code class="language-none"> @HystrixCommand(fallbackMethod = "getDefaultUser",    commandKey = "getUserCommand",    groupKey = "getUserGroup",    threadPoolKey = "getUserThreadPool")public CommonResult getUserCommand(@PathVariable Long id) {    return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用ignoreExceptions忽略某些异常降级"><a href="#使用ignoreExceptions忽略某些异常降级" class="headerlink" title="使用ignoreExceptions忽略某些异常降级"></a>使用ignoreExceptions忽略某些异常降级</h2></li><li><p>在UserHystrixController中添加测试接口：</p><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testException/{id}")public CommonResult testException(@PathVariable Long id) {    return userService.getUserException(id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在UserService中添加实现方法，这里忽略了NullPointerException，当id为1时抛出IndexOutOfBoundsException，id为2时抛出NullPointerException：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">@HystrixCommand(fallbackMethod = "getDefaultUser2", ignoreExceptions = {NullPointerException.class})public CommonResult getUserException(Long id) {    if (id == 1) {        throw new IndexOutOfBoundsException();    } else if (id == 2) {        throw new NullPointerException();    }    return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id);}public CommonResult getDefaultUser2(@PathVariable Long id, Throwable e) {    LOGGER.error("getDefaultUser2 id:{},throwable class:{}", id, e.getClass());    User defaultUser = new User(-2L, "defaultUser2", "123456");    return new CommonResult&lt;&gt;(defaultUser);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用接口进行测试：<a href="http://localhost:8401/user/tesException/1">http://localhost:8401/user/tesException/1</a></li></ul><ul><li>调用接口进行测试：<a href="http://localhost:8401/user/tesException/1">http://localhost:8401/user/tesException/1</a></li></ul><h2 id="Hystrix的请求缓存"><a href="#Hystrix的请求缓存" class="headerlink" title="Hystrix的请求缓存"></a>Hystrix的请求缓存</h2><blockquote><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p></blockquote><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><ul><li>@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</li><li>@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</li><li>@CacheRemove：移除缓存，需要指定commandKey。</li></ul><h3 id="测试使用缓存"><a href="#测试使用缓存" class="headerlink" title="测试使用缓存"></a>测试使用缓存</h3><ul><li>在UserHystrixController中添加使用缓存的测试接口，直接调用三次getUserCache方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testCache/{id}")public CommonResult testCache(@PathVariable Long id) {    userService.getUserCache(id);    userService.getUserCache(id);    userService.getUserCache(id);    return new CommonResult("操作成功", 200);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在UserService中添加具有缓存功能的getUserCache方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">@CacheResult(cacheKeyMethod = "getCacheKey")@HystrixCommand(fallbackMethod = "getDefaultUser", commandKey = "getUserCache")    public CommonResult getUserCache(Long id) {    LOGGER.info("getUserCache id:{}", id);    return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id);}/** * 为缓存生成key的方法 */public String getCacheKey(Long id) {    return String.valueOf(id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用接口测试<a href="http://localhost:8401/user/testCache/1,%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E8%B0%83%E7%94%A8%E4%BA%86%E4%B8%89%E6%AC%A1getUserCache%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AA%E6%89%93%E5%8D%B0%E4%BA%86%E4%B8%80%E6%AC%A1%E6%97%A5%E5%BF%97%EF%BC%8C%E8%AF%B4%E6%98%8E%E6%9C%89%E4%B8%A4%E6%AC%A1%E8%B5%B0%E7%9A%84%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%9A">http://localhost:8401/user/testCache/1,这个接口中调用了三次getUserCache方法，但是只打印了一次日志，说明有两次走的是缓存：</a></li></ul><h3 id="测试移除缓存"><a href="#测试移除缓存" class="headerlink" title="测试移除缓存"></a>测试移除缓存</h3><ul><li>在UserHystrixController中添加移除缓存的测试接口，调用一次removeCache方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testRemoveCache/{id}")public CommonResult testRemoveCache(@PathVariable Long id) {    userService.getUserCache(id);    userService.removeCache(id);    userService.getUserCache(id);    return new CommonResult("操作成功", 200);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在UserService中添加具有移除缓存功能的removeCache方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">@CacheRemove(commandKey = "getUserCache", cacheKeyMethod = "getCacheKey")@HystrixCommandpublic CommonResult removeCache(Long id) {    LOGGER.info("removeCache id:{}", id);    return restTemplate.postForObject(userServiceUrl + "/user/delete/{1}", null, CommonResult.class, id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用接口测试<a href="http://localhost:8401/user/testRemoveCache/1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%9C%89%E4%B8%A4%E6%AC%A1%E6%9F%A5%E8%AF%A2%E9%83%BD%E8%B5%B0%E7%9A%84%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9A">http://localhost:8401/user/testRemoveCache/1，可以发现有两次查询都走的是接口：</a></p><h3 id="缓存使用过程中的问题"><a href="#缓存使用过程中的问题" class="headerlink" title="缓存使用过程中的问题"></a>缓存使用过程中的问题</h3><p>在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭，否则会出现如下异常：</p><pre class="line-numbers language-none"><code class="language-none">java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?at com.netflix.hystrix.HystrixRequestCache.get(HystrixRequestCache.java:104) ~[hystrix-core-1.5.18.jar:1.5.18]at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:478) ~[hystrix-core-1.5.18.jar:1.5.18]at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:454) ~[hystrix-core-1.5.18.jar:1.5.18]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这里我们通过使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题：</li></ul><pre class="line-numbers language-none"><code class="language-none">/** * Created by macro on 2019/9/4. */@Component@WebFilter(urlPatterns = "/*",asyncSupported = true)public class HystrixRequestContextFilter implements Filter {    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HystrixRequestContext context = HystrixRequestContext.initializeContext();        try {            filterChain.doFilter(servletRequest, servletResponse);        } finally {            context.close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，从而达到减少通信消耗及线程数量的效果。</p><ul><li><p>@HystrixCollapser的常用属性</p></li><li><p>batchMethod：用于设置请求合并的方法；</p></li><li><p>collapserProperties：请求合并属性，用于控制实例属性，有很多；</p></li><li><p>timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；</p></li></ul><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><ul><li>在UserHystrixController中添加testCollapser方法，这里我们先进行两次服务调用，再间隔200ms以后进行第三次服务调用：</li></ul><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/testCollapser")public CommonResult testCollapser() throws ExecutionException, InterruptedException {    Future&lt;User&gt; future1 = userService.getUserFuture(1L);    Future&lt;User&gt; future2 = userService.getUserFuture(2L);    future1.get();    future2.get();    ThreadUtil.safeSleep(200);    Future&lt;User&gt; future3 = userService.getUserFuture(3L);    future3.get();    return new CommonResult("操作成功", 200);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用@HystrixCollapser实现请求合并，所有对getUserFuture的的多次调用都会转化为对getUserByIds的单次调用：</li></ul><pre class="line-numbers language-none"><code class="language-none">@HystrixCollapser(batchMethod = "getUserByIds",collapserProperties = {    @HystrixProperty(name = "timerDelayInMilliseconds", value = "100")})public Future&lt;User&gt; getUserFuture(Long id) {    return new AsyncResult&lt;User&gt;(){    @Override    public User invoke() {        CommonResult commonResult = restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id);        Map data = (Map) commonResult.getData();        User user = BeanUtil.mapToBean(data,User.class,true);        LOGGER.info("getUserById username:{}", user.getUsername());        return user;        }    };}@HystrixCommandpublic List&lt;User&gt; getUserByIds(List&lt;Long&gt; ids) {    LOGGER.info("getUserByIds:{}", ids);    CommonResult commonResult = restTemplate.getForObject(userServiceUrl + "/user/getUserByIds?ids={1}", CommonResult.class, CollUtil.join(ids,","));    return (List&lt;User&gt;) commonResult.getData();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问接口测试<a href="http://localhost:8401/user/testCollapser%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E8%AE%BE%E7%BD%AE%E4%BA%86100%E6%AF%AB%E7%A7%92%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%EF%BC%8C%E5%89%8D%E4%B8%A4%E6%AC%A1%E8%A2%AB%E5%90%88%E5%B9%B6%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%90%88%E5%B9%B6%E4%BA%86%E3%80%82">http://localhost:8401/user/testCollapser，由于我们设置了100毫秒进行一次请求合并，前两次被合并，最后一次自己单独合并了。</a></p><h2 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><pre class="line-numbers language-none"><code class="language-none">hystrix:  command: #用于控制HystrixCommand的行为    default:      execution:        isolation:          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略          thread:            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断          timeout:            enabled: true #配置HystrixCommand的执行是否启用超时时间          semaphore:            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝      fallback:        enabled: true #用于控制是否启用服务降级      circuitBreaker: #用于控制HystrixCircuitBreaker的行为        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝        forceOpen: false #强制打开断路器，拒绝所有请求        forceClosed: false #强制关闭断路器，接收所有请求      requestCache:        enabled: true #用于控制是否开启请求缓存  collapser: #用于控制HystrixCollapser的执行行为    default:      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个      requestCache:        enabled: true #控制合并请求是否开启缓存  threadpool: #用于控制HystrixCommand执行所在线程池的行为    default:      coreSize: 10 #线程池的核心线程数      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例配置"><a href="#实例配置" class="headerlink" title="实例配置"></a>实例配置</h3><blockquote><p>实例配置只需要将全局配置中的default换成与之对应的key即可。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hystrix:  command:    HystrixComandKey: #将default换成HystrixComrnandKey      execution:        isolation:          strategy: THREAD  collapser:    HystrixCollapserKey: #将default换成HystrixCollapserKey      maxRequestsInBatch: 100  threadpool:    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey      coreSize: 10```      ### 配置文件中相关key的说明* HystrixComandKey对应@HystrixCommand中的commandKey属性；* HystrixCollapserKey对应@HystrixCollapser注解中的collapserKey属性；* HystrixThreadPoolKey对应@HystrixCommand中的threadPoolKey属性。## 使用到的模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── user-service – 提供User对象CRUD接口的服务<br>└── hystrix-service – hystrix服务调用测试服务</p><pre><code>## 项目源码地址[https://github.com/macrozheng/....](https://github.com/macrozheng/springcloud-learning)&gt;作者：MacroZheng链接：https://juejin.im/post/5d822d27e51d45621479ad92来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Ribbon：负载均衡的服务调用</title>
      <link href="/2019/12/24/spring-cloud-ribbon-fu-zai-jun-heng-de-fu-wu-diao-yong/"/>
      <url>/2019/12/24/spring-cloud-ribbon-fu-zai-jun-heng-de-fu-wu-diao-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Ribbon：负载均衡的服务调用"><a href="#Spring-Cloud-Ribbon：负载均衡的服务调用" class="headerlink" title="Spring Cloud Ribbon：负载均衡的服务调用"></a>Spring Cloud Ribbon：负载均衡的服务调用</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spring Cloud Ribbon 是Spring Cloud Netflix<br>子项目的核心组件之一，主要给服务间调用及API网关转发提供负载均衡的功能，本文将对其用法进行详细介绍。</p><h2 id="Ribbon简介"><a href="#Ribbon简介" class="headerlink" title="Ribbon简介"></a>Ribbon简介</h2><p>在微服务架构中，很多服务都会部署多个，其他服务去调用该服务的时候，如何保证负载均衡是个不得不去考虑的问题。负载均衡可以增加系统的可用性和扩展性，当我们使用RestTemplate来调用其他服务时，Ribbon可以很方便的实现负载均衡功能。</p><h2 id="RestTemplate的使用"><a href="#RestTemplate的使用" class="headerlink" title="RestTemplate的使用"></a>RestTemplate的使用</h2><blockquote><p>RestTemplate是一个HTTP客户端，使用它我们可以方便的调用HTTP接口，支持GET、POST、PUT、DELETE等方法。</p></blockquote><h3 id="GET请求方法"><a href="#GET请求方法" class="headerlink" title="GET请求方法"></a>GET请求方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">postForObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">postForObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">postForObject</span><span class="token punctuation">(</span><span class="token class-name">URI</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">postForEntity</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">postForEntity</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">postForEntity</span><span class="token punctuation">(</span><span class="token class-name">URI</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> responseType<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="getForObject方法-返回对象为响应体中数据转化成的对象，举例如下："><a href="#getForObject方法-返回对象为响应体中数据转化成的对象，举例如下：" class="headerlink" title="getForObject方法 返回对象为响应体中数据转化成的对象，举例如下："></a>getForObject方法 返回对象为响应体中数据转化成的对象，举例如下：</h4><pre class="line-numbers language-none"><code class="language-none">@GetMapping("/{id}") publicCommonResult getUser(@PathVariable Long id) { return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class,id); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="getForEntity方法"><a href="#getForEntity方法" class="headerlink" title="getForEntity方法"></a>getForEntity方法</h4><p>返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等，举例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getEntityByUsername"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token class-name">CommonResult</span><span class="token function">getEntityByUsername</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">ResponseEntity</span> entity <span class="token operator">=</span>restTemplate<span class="token punctuation">.</span><span class="token function">getForEntity</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/getByUsername?username={1}"</span><span class="token punctuation">,</span><span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entity<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is2xxSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> entity<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token punctuation">(</span><span class="token string">"操作失败"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="POST请求方法"><a href="#POST请求方法" class="headerlink" title="POST请求方法"></a>POST请求方法</h3><pre class="line-numbers language-none"><code class="language-none">&lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables);&lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables);&lt;T&gt; T postForObject(URI url, @Nullable Object request, Class&lt;T&gt; responseType);&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables);&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables);&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, @Nullable Object request, Class&lt;T&gt; responseType);````### postForObject示例```java@PostMapping("/create")public CommonResult create(@RequestBody User user) {    return restTemplate.postForObject(userServiceUrl + "/user/create", user, CommonResult.class);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PUT请求方法"><a href="#PUT请求方法" class="headerlink" title="PUT请求方法"></a>PUT请求方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">URI</span> url<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DELETE请求方法"><a href="#DELETE请求方法" class="headerlink" title="DELETE请求方法"></a>DELETE请求方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> uriVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">URI</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DELETE请求示例"><a href="#DELETE请求示例" class="headerlink" title="DELETE请求示例"></a>DELETE请求示例</h3><pre class="line-numbers language-none"><code class="language-none">@DeleteMapping("/delete/{id}")public CommonResult delete(@PathVariable Long id) {   restTemplate.delete(userServiceUrl + "/user/delete/{1}", null, id);   return new CommonResult("操作成功",200);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建一个user-service模块"><a href="#创建一个user-service模块" class="headerlink" title="创建一个user-service模块"></a>创建一个user-service模块</h2><blockquote><p>首先我们创建一个user-service，用于给Ribbon提供服务调用。</p></blockquote><h3 id="在pom-xml中添加相关依赖"><a href="#在pom-xml中添加相关依赖" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml进行配置"><a href="#在application-yml进行配置" class="headerlink" title="在application.yml进行配置"></a>在application.yml进行配置</h3><blockquote><p>UserController类定义了对User对象常见的CRUD接口。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Created by macro on 2019/8/29. */</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> LOGGER <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/create"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"根据id获取用户信息，用户名称为：{}"</span><span class="token punctuation">,</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getUserByIds"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserByIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> ids<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userList<span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserByIds</span><span class="token punctuation">(</span>ids<span class="token punctuation">)</span><span class="token punctuation">;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"根据ids获取用户信息，用户列表为：{}"</span><span class="token punctuation">,</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getByUsername"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getByUsername</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/update"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/delete/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userService<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建一个ribbon-service模块"><a href="#创建一个ribbon-service模块" class="headerlink" title="创建一个ribbon-service模块"></a>创建一个ribbon-service模块</h2><blockquote><p>这里我们创建一个ribbon-service模块来调用user-service模块演示负载均衡的服务调用。</p></blockquote><h3 id="在pom-xml中添加相关依赖-1"><a href="#在pom-xml中添加相关依赖-1" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在application-yml进行配置-1"><a href="#在application-yml进行配置-1" class="headerlink" title="在application.yml进行配置"></a>在application.yml进行配置</h3><blockquote><p>主要是配置了端口、注册中心地址及user-service的调用路径。</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8301</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> ribbon<span class="token punctuation">-</span>service<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8001/eureka/<span class="token key atrule">service-url</span><span class="token punctuation">:</span>  <span class="token key atrule">user-service</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//user<span class="token punctuation">-</span>service```  <span class="token comment">### 使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span><span class="token punctuation">&gt;</span>可以看出使用Ribbon的负载均衡功能非常简单，和直接使用RestTemplate没什么两样，只需给RestTemplate添加一个@LoadBalanced即可。```java/<span class="token important">**</span> * Created by macro on 2019/8/29. <span class="token important">*/</span>@Configurationpublic class RibbonConfig <span class="token punctuation">{</span>    @Bean    @LoadBalanced    public RestTemplate restTemplate()<span class="token punctuation">{</span>        return new RestTemplate();    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加UserRibbonController类"><a href="#添加UserRibbonController类" class="headerlink" title="添加UserRibbonController类"></a>添加UserRibbonController类</h3><blockquote><p>注入RestTemplate，使用其调用user-service中提供的相关接口，这里对GET和POST调用进行了演示，其他方法调用均可参考。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Created by macro on 2019/8/29. */</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRibbonController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${service-url.user-service}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userServiceUrl<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/{1}"</span><span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getByUsername"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">getByUsername</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/getByUsername?username={1}"</span><span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getEntityByUsername"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">getEntityByUsername</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CommonResult</span><span class="token punctuation">&gt;</span></span> entity <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForEntity</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/getByUsername?username={1}"</span><span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>entity<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is2xxSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> entity<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CommonResult</span><span class="token punctuation">(</span><span class="token string">"操作失败"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/create"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/create"</span><span class="token punctuation">,</span> user<span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/update"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/update"</span><span class="token punctuation">,</span> user<span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/delete/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>userServiceUrl <span class="token operator">+</span> <span class="token string">"/user/delete/{1}"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="负载均衡功能演示"><a href="#负载均衡功能演示" class="headerlink" title="负载均衡功能演示"></a>负载均衡功能演示</h2><ul><li>启动eureka-server于8001端口；</li><li>启动user-service于8201端口；</li><li>启动另一个user-service于8202端口，可以通过修改IDEA中的SpringBoot的启动配置实现：<br><img src="http://image.lichongbing.com/static/e5688ca13e9855f438722c875d1d67c7.png" alt="16d3a4a8b90b1aa2.png"></li><li>此时运行中的服务如下：<br><img src="http://image.lichongbing.com/static/3901397e1e9f7a2ff103d46ae6fae1e7.png" alt="16d3a4a8b9591127.png"></li><li>调用接口进行测试：<a href="http://localhost:8301/user/1">http://localhost:8301/user/1</a><br><img src="http://image.lichongbing.com/static/c4f97ec608f4aa711566b414186749ea.png" alt="16d3a4a8badc1d89.png"></li><li>可以发现运行在8201和8202的user-service控制台交替打印如下信息：</li></ul><p><img src="http://image.lichongbing.com/static/9fe58b9345e89c7975ef504ef9626276.png" alt="16d3a4a8ba8e1025.png"></p><p><img src="http://image.lichongbing.com/static/0af9180495aa2a3c1d27e2d3b70990bd.png" alt="16d3a4a8bb0d1c02.png"></p><h2 id="Ribbon的常用配置"><a href="#Ribbon的常用配置" class="headerlink" title="Ribbon的常用配置"></a>Ribbon的常用配置</h2><blockquote><p>与全局配置的区别就是ribbon节点挂在服务名称下面，如下是对ribbon-service调用user-service时的单独配置。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">user-service:  ribbon:    ConnectTimeout: 1000 #服务请求连接超时时间（毫秒）    ReadTimeout: 3000 #服务请求处理超时时间（毫秒）    OkToRetryOnAllOperations: true #对超时请求启用重试机制    MaxAutoRetriesNextServer: 1 #切换重试实例的最大个数    MaxAutoRetries: 1 # 切换实例后重试最大次数    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #修改负载均衡算法    ```    ## Ribbon的负载均衡策略&gt;所谓的负载均衡策略，就是当A服务调用B服务时，此时B服务有多个实例，这时A服务以何种方式来选择调用的B实例，ribbon可以选择以下几种负载均衡策略。* com.netflix.loadbalancer.RandomRule：从提供服务的实例中以随机的方式；* com.netflix.loadbalancer.RoundRobinRule：以线性轮询的方式，就是维护一个计数器，从提供服务的实例中按顺序选取，第一次选第一个，第二次选第二个，以此类推，到最后一个以后再从头来过；* com.netflix.loadbalancer.RetryRule：在RoundRobinRule的基础上添加重试机制，即在指定的重试时间内，反复使用线性轮询策略来选择可用实例；* com.netflix.loadbalancer.WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择；* com.netflix.loadbalancer.BestAvailableRule：选择并发较小的实例；* com.netflix.loadbalancer.AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例；* com.netflix.loadbalancer.ZoneAwareLoadBalancer：采用双重过滤，同时过滤不是同一区域的实例和故障实例，选择并发较小的实例。## 使用到的模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── user-service – 提供User对象CRUD接口的服务<br>└── ribbon-service – ribbon服务调用测试服务</p><pre><code>## 项目源码地址[https://github.com/macrozheng/....](https://github.com/macrozheng/springcloud-learning)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka：服务注册与发现</title>
      <link href="/2019/12/24/spring-cloud-eureka-fu-wu-zhu-ce-yu-fa-xian/"/>
      <url>/2019/12/24/spring-cloud-eureka-fu-wu-zhu-ce-yu-fa-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Eureka：服务注册与发现"><a href="#Spring-Cloud-Eureka：服务注册与发现" class="headerlink" title="Spring Cloud Eureka：服务注册与发现"></a>Spring Cloud Eureka：服务注册与发现</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>Spring Cloud Eureka是Spring Cloud Netflix 子项目的核心组件之一，主要用于微服务架构中的服务治理。<br>本文将对搭建Eureka注册中心，搭建Eureka客户端，搭建Eureka集群及给Eureka注册中心添加登录认证进行介绍。</p></blockquote><h2 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h2><blockquote><p>在微服务架构中往往会有一个注册中心，每个微服务都会向注册中心去注册自己的地址及端口信息，注册中心维护着服务名称与服务实例的对应关系。每个微服务都会定时从注册中心获取服务列表，同时汇报自己的运行情况，这样当有的服务需要调用其他服务时，就可以从自己获取到的服务列表中获取实例地址进行调用，Eureka实现了这套服务注册与发现机制。</p></blockquote><h2 id="搭建Eureka注册中心"><a href="#搭建Eureka注册中心" class="headerlink" title="搭建Eureka注册中心"></a>搭建Eureka注册中心</h2><blockquote><p>这里我们以创建并运行Eureka注册中心来看看在IDEA中创建并运行SpringCloud应用的正确姿势。</p></blockquote><h3 id="使用IDEA来创建SpringCloud应用"><a href="#使用IDEA来创建SpringCloud应用" class="headerlink" title="使用IDEA来创建SpringCloud应用"></a>使用IDEA来创建SpringCloud应用</h3><ul><li>创建一个eureka-server模块，并使用SpringInitializer初始化一个SpringBoot项目</li><li>填写应用信息</li><li>选择你需要的SpringCloud组件进行创建</li><li>创建完成后会发现pom.xml文件中已经有了eureka-server的依赖<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>在启动类上添加@EnableEurekaServer注解来启用Euerka注册中心功能<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServerApplication</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServerApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> ```      <span class="token operator">*</span> 在配置文件application<span class="token punctuation">.</span>yml中添加<span class="token class-name">Eureka</span>注册中心的配置```yaml       server<span class="token operator">:</span>         port<span class="token operator">:</span> <span class="token number">8001</span> #指定运行端口         spring<span class="token operator">:</span>          application<span class="token operator">:</span> name<span class="token operator">:</span> eureka<span class="token operator">-</span>server #指定服务名称       eureka<span class="token operator">:</span>           instance<span class="token operator">:</span>              hostname<span class="token operator">:</span> localhost #指定主机地址           client<span class="token operator">:</span>              fetch<span class="token operator">-</span>registry<span class="token operator">:</span> <span class="token boolean">false</span> #指定是否要从注册中心获取服务（注册中心不需要开启）             register<span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>eureka<span class="token operator">:</span> <span class="token boolean">false</span> #指定是否要注册到注册中心（注册中心不需要开启）           server<span class="token operator">:</span> enable<span class="token operator">-</span>self<span class="token operator">-</span>preservation<span class="token operator">:</span> <span class="token boolean">false</span> #关闭保护模式 ```         ### 使用IDEA的<span class="token class-name">Run</span> <span class="token class-name">Dashboard</span>来运行<span class="token class-name">SpringCloud</span>应用<span class="token operator">&gt;</span>此时服务已经创建完成，点击启动类的main方法就可以运行了。但是在微服务项目中我们会启动很多服务，为了便于管理，我们使用IDEA的<span class="token class-name">Run</span> <span class="token class-name">Dashboard</span>来启动。<span class="token operator">*</span> 打开<span class="token class-name">Run</span> <span class="token class-name">Dashboard</span>，默认情况下，当IDEA检查到你的项目中有<span class="token class-name">SpringBoot</span>应用时，会提示你开启，如果你没开启，可以用以下方法开启。<span class="token operator">*</span> 运行<span class="token class-name">SpringCloud</span>应用<span class="token operator">*</span> 运行完成后访问地址可以看到<span class="token class-name">Eureka</span>注册中心的界面## 搭建<span class="token class-name">Eureka</span>客户端<span class="token operator">*</span> 新建一个eureka<span class="token operator">-</span>client模块，并在pom<span class="token punctuation">.</span>xml中添加如下依赖````xml<span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>starter<span class="token operator">-</span>netflix<span class="token operator">-</span>eureka<span class="token operator">-</span>client<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>````在启动类上添加<span class="token annotation punctuation">@EnableDiscoveryClient</span>注解表明是一个<span class="token class-name">Eureka</span>客户端````java<span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token annotation punctuation">@SpringBootApplication</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaClientApplication</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> ````在配置文件application<span class="token punctuation">.</span>yml中添加<span class="token class-name">Eureka</span>客户端的配置````yamlserver<span class="token operator">:</span>     port<span class="token operator">:</span> <span class="token number">8101</span> #运行端口号 spring<span class="token operator">:</span>     application<span class="token operator">:</span>         name<span class="token operator">:</span> eureka<span class="token operator">-</span>client #服务名称 eureka<span class="token operator">:</span>      client<span class="token operator">:</span>        register<span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>eureka<span class="token operator">:</span> <span class="token boolean">true</span> #注册到<span class="token class-name">Eureka</span>的注中心        fetch<span class="token operator">-</span>registry<span class="token operator">:</span> <span class="token boolean">true</span> #获取注册实例列表 service<span class="token operator">-</span>url<span class="token operator">:</span>           defaultZone<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">8001</span><span class="token operator">/</span>eureka<span class="token operator">/</span> #配置注册中心地址 ````<span class="token operator">*</span> 运行eureka<span class="token operator">-</span>client<span class="token operator">*</span> 查看注册中心发现<span class="token class-name">Eureka</span>客户端已经成功注册## 搭建<span class="token class-name">Eureka</span>注册中心集群### 搭建两个注册中心<span class="token operator">&gt;</span> 由于所有服务都会注册到注册中心去，服务之间的调用都是通过从注册中心获取的服务列表来调用，注册中心一旦宕机，所有服务调用都会出现问题。所以我们需要多个注册中心组成集群来提供服务，下面将搭建一个双节点的注册中心集群。<span class="token operator">*</span> 给eureka<span class="token operator">-</span>sever添加配置文件application<span class="token operator">-</span>replica1<span class="token punctuation">.</span>yml配置第一个注册中心````yamlserver<span class="token operator">:</span>    port<span class="token operator">:</span> <span class="token number">8002</span>spring<span class="token operator">:</span>      application<span class="token operator">:</span>         name<span class="token operator">:</span> eureka<span class="token operator">-</span>server eureka<span class="token operator">:</span>      instance<span class="token operator">:</span>         hostname<span class="token operator">:</span> replica1     client<span class="token operator">:</span>          serviceUrl<span class="token operator">:</span>               defaultZone<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>replica2<span class="token operator">:</span><span class="token number">8003</span><span class="token operator">/</span>eureka<span class="token operator">/</span>#注册到另一个<span class="token class-name">Eureka</span>注册中心      fetch<span class="token operator">-</span>registry<span class="token operator">:</span> <span class="token boolean">true</span>      register<span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>eureka<span class="token operator">:</span> <span class="token boolean">true</span> ````<span class="token operator">*</span> 给eureka<span class="token operator">-</span>sever添加配置文件application<span class="token operator">-</span>replica2<span class="token punctuation">.</span>yml配置第二个注册中心````yamlserver<span class="token operator">:</span>    port<span class="token operator">:</span> <span class="token number">8003</span>spring<span class="token operator">:</span>      application<span class="token operator">:</span>         name<span class="token operator">:</span> eureka<span class="token operator">-</span>server eureka<span class="token operator">:</span>      instance<span class="token operator">:</span>         hostname<span class="token operator">:</span> replica2     client<span class="token operator">:</span>          serviceUrl<span class="token operator">:</span>               defaultZone<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>replica2<span class="token operator">:</span><span class="token number">8002</span><span class="token operator">/</span>eureka<span class="token operator">/</span> #注册到另一个<span class="token class-name">Eureka</span>注册中心      fetch<span class="token operator">-</span>registry<span class="token operator">:</span> <span class="token boolean">true</span>      register<span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>eureka<span class="token operator">:</span> <span class="token boolean">true</span> ````<span class="token operator">*</span><span class="token operator">*</span>这里我们通过两个注册中心互相注册，搭建了注册中心的双节点集群，由于defaultZone使用了域名，所以还需在本机的host文件中配置一下。<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> 修改本地host文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>127.0.0.1 replica1<br>127.0.0.1 replica2 </p><pre class="line-numbers language-none"><code class="language-none">### 运行Eureka注册中心集群&gt;在IDEA中我们可以通过使用不同的配置文件来启动同一个SpringBoot应用。* 添加两个配置，分别以application-replica1.yml和application-replica2.yml来启动eureka-server  &gt; 从原启动配置中复制一个出来  &gt;配置启动的配置文件* 启动两个eureka-server，访问其中一个注册中心发现另一个已经成为其备份* 修改Eureka-client，让其连接到集群&gt; 添加eureka-client的配置文件application-replica.yml，让其同时注册到两个注册中心。````yaml server:    port: 8102spring:     application:        name: eureka-client eureka:     client:         register-with-eureka: true         fetch-registry: true         service-url:             defaultZone:http://replica1:8002/eureka/,http://replica2:8003/eureka/ #同时注册到两个注册中心 ````以该配置文件启动后访问任意一个注册中心节点都可以看到eureka-client ## 给Eureka注册中心添加认证### 创建一个eureka-security-server模块，在pom.xml中添加以下依赖&gt; 需要添加SpringSecurity模块。```xml&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加application-yml配置文件"><a href="#添加application-yml配置文件" class="headerlink" title="添加application.yml配置文件"></a>添加application.yml配置文件</h3><blockquote><p>主要是配置了登录注册中心的用户名和密码。</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8004</span> <span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">application</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>security<span class="token punctuation">-</span>server     <span class="token key atrule">security</span><span class="token punctuation">:</span> <span class="token comment">#配置SpringSecurity登录用户名和密码</span>         <span class="token key atrule">user</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> macro            <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span> <span class="token key atrule">eureka</span><span class="token punctuation">:</span>     <span class="token key atrule">instance</span><span class="token punctuation">:</span>          <span class="token key atrule">hostname</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">client</span><span class="token punctuation">:</span>          <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>          <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> ```         <span class="token comment">###添加Java配置WebSecurityConfig</span><span class="token punctuation">&gt;</span> 默认情况下添加SpringSecurity依赖的应用每个请求都需要添加CSRF <span class="token punctuation">&gt;</span>token才能访问，Eureka客户端注册时并不会添加，所以需要配置/eureka/<span class="token important">**路径不需要CSRF</span> token。````java@EnableWebSecurity public class WebSecurityConfig extendsWebSecurityConfigurerAdapter <span class="token punctuation">{</span> @Override protected void configure(HttpSecurityhttp) throws Exception <span class="token punctuation">{</span> http.csrf().ignoringAntMatchers("/eureka/<span class="token important">**");</span>super.configure(http); <span class="token punctuation">}</span> <span class="token punctuation">}</span>````<span class="token comment">### 运行eureka-security-server，访问发现需要登录认证</span><span class="token comment">### eureka-client注册到有登录认证的注册中心</span>* 配置文件中需要修改注册中心地址格式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>http://${username}:${password}@${hostname}:${port}/eureka/</p><pre class="line-numbers language-none"><code class="language-none">* 添加application-security.yml配置文件，按格式修改用户名和密码````yamlserver:     port: 8103 spring:    application:       name: eureka-client eureka:     client:       register-with-eureka: true      fetch-registry: true       service-url:          defaultZone: http://macro:123456@localhost:8004/eureka/ ````* 以application-security.yml配置运行eureka-client，可以在注册中心界面看到eureka-client已经成功注册## Eureka的常用配置````yamleureka:     client: #eureka客户端配置        register-with-eureka: true #是否将自己注册到eureka服务端上去       fetch-registry: true #是否获取eureka服务端上注册的服务列表        service-url: defaultZone:       http://localhost:8001/eureka/ # 指定注册中心地       enabled: true # 启用eureka客户端        registry-fetch-interval-seconds: 30 #定义去eureka服务端获取服务列表的时间间隔    instance: #eureka客户端实例配置     lease-renewal-interval-in-seconds: 30 #定义服务多久去注册中心续约      lease-expiration-duration-in-seconds: 90 #定义服务多久不去续约认为服务失效      metadata-map: zone: jiangsu #所在区域     hostname: localhost #服务主机名称      prefer-ip-address: false #是否优先使用ip来作为主机名   server:#eureka服务端配置     enable-self-preservation: false #关闭eureka服务端的保护机制 ````## 使用到的模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>springcloud-learning<br> ├── eureka-server – eureka注册中心<br> ├── eureka-security-server – 带登录认证的eureka注册中心<br> └── eureka-client – eureka客户端 </p><pre><code>## 项目源码地址[github.com/macrozheng/…](https://github.com/macrozheng/springcloud-learning)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 整体架构认识</title>
      <link href="/2019/12/24/spring-cloud-zheng-ti-jia-gou-ren-shi/"/>
      <url>/2019/12/24/spring-cloud-zheng-ti-jia-gou-ren-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>协调任何服务，简化分布式系统开发。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>构建分布式系统不应该是复杂的，SpringCloud对常见的分布式系统模式提供了简单易用的编程模型，帮助开发者构建弹性、可靠、协调的应用程序。<br>SpringCloud是在SpringBoot的基础上构建的，使开发者可以轻松入门并快速提高工作效率。<br>SpringCloud为开发人员提供了快速构建分布式系统架构的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态等。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="http://image.lichongbing.com/static/bddac0ec81db2d66f76c84863c95973f.png" alt="16d1624a59de8e36.png"></p><h2 id="SpringCloud的版本关系-SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。"><a href="#SpringCloud的版本关系-SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。" class="headerlink" title="SpringCloud的版本关系 SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。"></a>SpringCloud的版本关系 SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。</h2><p>为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。<br>为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本,<br>Brixton是第二个版本。 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service<br>releases”版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。</p><h3 id="SpringCloud和SpringBoot版本对应关系"><a href="#SpringCloud和SpringBoot版本对应关系" class="headerlink" title="SpringCloud和SpringBoot版本对应关系"></a>SpringCloud和SpringBoot版本对应关系</h3><table><thead><tr><th>SpringCloud Version</th><th>SpringBoot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><h3 id="SpringCloud和各子项目版本对应关系"><a href="#SpringCloud和各子项目版本对应关系" class="headerlink" title="SpringCloud和各子项目版本对应关系"></a>SpringCloud和各子项目版本对应关系</h3><table><thead><tr><th>Component</th><th>Edgware.SR6</th><th>Greenwich.SR2</th></tr></thead><tbody><tr><td>spring-cloud-bus</td><td>1.3.4.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-commons</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-config</td><td>1.4.7.RELEASE</td><td>2.1.3.RELEASE</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.7.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-security</td><td>1.2.4.RELEASE</td><td>2.1.3.RELEASE</td></tr><tr><td>spring-cloud-consul</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.6.RELEASE</td><td>2.1.1.RELEASE</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR5</td><td>Fishtown.SR3</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.3.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-boot</td><td>1.5.21.RELEASE</td><td>2.1.5.RELEASE</td></tr><tr><td>spring-cloud-task</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.3.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-openfeign</td><td>暂无</td><td>2.1.2.RELEASE</td></tr></tbody></table><p><strong>注意：Greenwich版本是基于SpringBoot<br>2.1.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</strong><br>##SpringCloud子项目简介</p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p><h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><ul><li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li><li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li><li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li><li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li><li>Zuul：API网关组件，对请求提供路由及过滤功能。</li></ul><h3 id="SpringCloud-Bus"><a href="#SpringCloud-Bus" class="headerlink" title="SpringCloud Bus"></a>SpringCloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p><h3 id="SpringCloud-Consul"><a href="#SpringCloud-Consul" class="headerlink" title="SpringCloud Consul"></a>SpringCloud Consul</h3><p>基于Hashicorp Consul的服务治理组件。</p><h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p><h3 id="Spring-CloudStream"><a href="#Spring-CloudStream" class="headerlink" title="Spring CloudStream"></a>Spring CloudStream</h3><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ<br>###Spring Cloud Task<br>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p><h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><p>基于Apache Zookeeper的服务治理组件。</p><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>API网关组件，对请求提供路由及过滤功能。</p><h3 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在SpringCloud2.0中已经取代Feign成为了一等公民。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>v</title>
      <link href="/2019/12/23/mall-springboot-ban-zhi-shi-zheng-li/"/>
      <url>/2019/12/23/mall-springboot-ban-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<blockquote>转载请标明出处：&nbsp;<br><a href="https://macrozheng.github.io/mall-learning/#/foreword/mall_foreword_02?id=idea" target="_blank">https://macrozheng.github.io/mall-learning/#/foreword/mall_foreword_02?id=idea</a>&nbsp;<br>本文出自<a href="http://blog.csdn.net/forezp" target="_blank">掘金作者MacroZheng</a></blockquote><h1 id="mall学习所需知识点"><a href="#mall学习所需知识点" class="headerlink" title="mall学习所需知识点"></a>mall学习所需知识点</h1><blockquote>由于mall项目涉及到很多知识点，比如SpringBoot、ElasticSearch、Redis、Mongodb等，本教程不会详细讲述这些，只会讲述本项目相关部分，所以推荐以下资料。对其中一些知识点并不熟悉的同学，可以看下下面推荐的资料。</blockquote><h1 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h1><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>《IntelliJ-IDEA-Tutorial》：<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></p><blockquote>特别全的IDEA使用教程，可以学到很多实用的技巧。</blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>《Spring实战（第4版）》：<a href="https://book.douban.com/subject/26767354/">https://book.douban.com/subject/26767354/</a></p><blockquote>经典的、畅销的Spring学习和实践指南,从此书可以学习到Spring的实用用法，对Spring有个整体的了解，推荐整本阅读。</blockquote><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>《Spring Boot实战》：<a href="https://book.douban.com/subject/26857423/">https://book.douban.com/subject/26857423/</a></p><blockquote>SpringBoot的入门书，一共也就200多页，反正我是看完了，其中关于Groovy和Grails部分大可不看。</blockquote><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>《MyBatis从入门到精通》：<a href="https://book.douban.com/subject/27074809/">https://book.douban.com/subject/27074809/</a></p><blockquote>很好的一本MyBatis入门书，作者是开源插件PageHelper的项目主，平时忘了MyBatis的一些用法的时候可以当工具书使用，推荐整本阅读</blockquote><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><p>《深入浅出MySQL》：<a href="https://book.douban.com/subject/25817684/">https://book.douban.com/subject/25817684/</a></p><blockquote>网易DBA写的一本MySql书籍，作为一个开发者，我们只要看第一部分基础篇、第二部分开发篇、第三部分优化篇即可。</blockquote><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>《循序渐进Linux（第2版）》：<a href="https://book.douban.com/subject/26758194/">https://book.douban.com/subject/26758194/</a></p><blockquote>南非蚂蚁写的一本Linux书籍，作为一个开发者，我们只要看第一篇基础知识篇、第二篇服务器搭建篇即可，后面讲到生产环境部署项目会用到。</blockquote><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>《Elasticsearch 权威指南》：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><blockquote>Elasticsearch官方推荐的中文学习资料，基于Elasticsearch2.4.x版本，比较老，但是可堪一用。大多数成熟的框架，版本迭代用法相差不会很大。</blockquote><p>《Elasticsearch 技术解析与实战》：<a href="https://book.douban.com/subject/26967826/">https://book.douban.com/subject/26967826/</a></p><blockquote>如果你觉得上面那本ElasticSearch版本太老的话可以看这本。</blockquote><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>《MongoDB实战(第二版)》：<a href="https://book.douban.com/subject/27061123/">https://book.douban.com/subject/27061123/</a></p><blockquote>很好的一本MongoDB实战书，作者参与过MongoDB的驱动开发，感兴趣的可以都看下。</blockquote><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>《Spring Cloud与Docker微服务架构实战》：<a href="https://book.douban.com/subject/27028228/">https://book.douban.com/subject/27028228/</a></p><blockquote>我们只需要看下这本书的Docker部分即可，后面讲到生产环境部署项目会用到。</blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>如果你按照我的推荐看了以上部分的资料，或者你已经有了以上部分的基础，那么你学习mall的时候会非常顺利。</blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker部署spring cloud项目</title>
      <link href="/2019/12/22/docker-bu-shu-spring-cloud-xiang-mu/"/>
      <url>/2019/12/22/docker-bu-shu-spring-cloud-xiang-mu/</url>
      
        <content type="html"><![CDATA[<blockquote>转载请标明出处：&nbsp;<br><a href="http://blog.csdn.net/forezp/article/details/70198649" target="_blank">http://blog.csdn.net/forezp/article/details/70198649</a>&nbsp;<br>本文出自<a href="http://blog.csdn.net/forezp" target="_blank">方志朋的博客</a></blockquote><h2 id="一、docker简介"><a href="#一、docker简介" class="headerlink" title="一、docker简介"></a><a name="t0" target="_blank"></a>一、docker简介</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。&nbsp;<br>Docker通常用于如下场景：</p><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><p>Docker 的优点</p><ul><li>1、简化程序：&nbsp;<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。</li></ul><ul><li>2、避免选择恐惧症：&nbsp;<br>如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</li></ul><ul><li>3、节省开支：&nbsp;<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li></ul><p>上面文字参考了相关文章；另，关于docker 的安装和基本的使用见<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank">相关教程</a>。</p><h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a><a name="t1" target="_blank"></a>二、准备工作</h2><p>环境条件：</p><ul><li>linux系统，不建议windows</li><li>docker最新版本</li><li>jdk 1.8</li><li>maven3.0</li></ul><p>本文采用的工程来自第一篇文章的工程，采用maven的方式去构建项目，并采用docker-maven-plugin去构建docker镜像。</p><h2 id="三、改造工程、构建镜像"><a href="#三、改造工程、构建镜像" class="headerlink" title="三、改造工程、构建镜像"></a><a name="t2" target="_blank"></a>三、改造工程、构建镜像</h2><h5 id="改造eureka-server工程"><a href="#改造eureka-server工程" class="headerlink" title="改造eureka-server工程"></a><a name="t3" target="_blank"></a>改造eureka-server工程</h5><p>在pom文件加上插件：</p><pre class="line-numbers language-none"><code class="language-none">&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;!-- tag::plugin[] --&gt;            &lt;plugin&gt;                &lt;groupId&gt;com.spotify&lt;/groupId&gt;                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;0.4.3&lt;/version&gt;                &lt;configuration&gt;                    &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                    &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;                    &lt;resources&gt;                        &lt;resource&gt;                            &lt;targetPath&gt;/&lt;/targetPath&gt;                            &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                            &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                        &lt;/resource&gt;                    &lt;/resources&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- end::plugin[] --&gt;        &lt;/plugins&gt;    &lt;/build&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。</p><ul><li>imageName指定了镜像的名字，本例为 forep/eureka-server</li><li>dockerDirectory指定 Dockerfile 的位置</li><li>resources是指那些需要和 Dockerfile 放在一起，在构建镜像时使用的文件，一般应用 jar 包需要纳入。</li></ul><p>修改下配置文件：</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 8761eureka:  instance:    prefer-ip-address: true  client:    registerWithEureka: false    fetchRegistry: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编写dockerfile文件："><a href="#编写dockerfile文件：" class="headerlink" title="编写dockerfile文件："></a><a name="t4" target="_blank"></a>编写dockerfile文件：</h4><pre class="line-numbers language-FROM" data-language="FROM"><div class="caption"><span>frolvlad/alpine-oraclejdk8:slim</span></div><code class="language-FROM">VOLUME /tmpADD eureka-server-0.0.1-SNAPSHOT.jar app.jar#RUN bash -c 'touch /app.jar'ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]EXPOSE 8761<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="docker-file编写指令："><a href="#docker-file编写指令：" class="headerlink" title="docker file编写指令："></a><a name="t5" target="_blank"></a>docker file编写指令：</h4><ul><li>FROM</li></ul><pre class="line-numbers language-none"><code class="language-none">FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt; &lt;digest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>FROM指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。</p><ul><li>VOLUME</li></ul><p>格式为：</p><pre class="line-numbers language-none"><code class="language-none">VOLUME ["/data"]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。</p><ul><li>ADD</li></ul><p>从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包</p><ul><li>ENTRYPOINT</li></ul><p>指定Docker容器启动时执行的命令，可以多次设置，但是只有最后一个有效。</p><ul><li>EXPOSE</li></ul><p>为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。</p><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a><a name="t6" target="_blank"></a>构建镜像</h4><p>执行构建docker镜像maven命令：</p><pre class="line-numbers language-none"><code class="language-none">mvn cleanmvn package docker:build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://image.lichongbing.com/static/e0011f5453a85e87822d4a5606d1e8d9.png" alt="20190601114057480.png"><br>构建eureka-server镜像成功。</p><h4 id="同理构建service-hi镜像"><a href="#同理构建service-hi镜像" class="headerlink" title="同理构建service-hi镜像"></a><a name="t7" target="_blank"></a>同理构建service-hi镜像</h4><ul><li>pom文件导入同eurek-server</li><li>修改下配置文件：</li></ul><pre class="line-numbers language-none"><code class="language-none"> eureka:  client:    serviceUrl:      defaultZone: http://eureka-server:8761/eureka/ # 这个需要改为eureka-serverserver:  port: 8763spring:  application:    name: service-hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里说下：defaultZone发现服务的host改为镜像名。</p><p>-<br>dockefile 编写同eureka-server</p><p>-<br>构建镜像：</p><pre class="line-numbers language-none"><code class="language-none">mvn cleanmvn package docker:build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://image.lichongbing.com/static/5a1c1170ebc3de5fc7ac08ed2bf9edee.png" alt="20190601114116418.png"><br>这时我们运行docke的eureka-server 和service-hi镜像：</p><pre class="line-numbers language-none"><code class="language-none">docker run -p 8761: 8761 -t forezp/eureka-serverdocker run -p 8763: 8763 -t forezp/service-hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>访问localhost:8761<br><img src="http://image.lichongbing.com/static/22d6092969e3ab6015e9e69f053c7e89.png" alt="20190601114134655.png"></p><h2 id="四、采用docker-compose启动镜像"><a href="#四、采用docker-compose启动镜像" class="headerlink" title="四、采用docker-compose启动镜像"></a><a name="t8" target="_blank"></a>四、采用docker-compose启动镜像</h2><p>Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。下面我们进入Compose的实战吧。<br>采用docker-compose的方式编排镜像，启动镜像：</p><pre class="line-numbers language-none"><code class="language-none"> version: '3'services:  eureka-server:    image: forezp/eureka-server    restart: always    ports:      - 8761:8761  service-hi:    image: forezp/service-hi    restart: always    ports:      - 8763:8763<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入命令： docker-compose up<br><img src="http://image.lichongbing.com/static/4c4918f7048a10e26754870d7a9af656.png" alt="201906011142016.png"><br>发现2个镜像按照指定的顺序启动了。<br>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11" target="_blank">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11</a></p><h2 id="五、采用docker-compose编排并启动镜像"><a href="#五、采用docker-compose编排并启动镜像" class="headerlink" title="五、采用docker-compose编排并启动镜像"></a><a name="t9" target="_blank"></a>五、采用docker-compose编排并启动镜像</h2><p>docker-compose也可以构建镜像，现在我们采用docker-compose的方式构建镜像。<br>现在以eureka-server为例：&nbsp;<br>将Dockerfile移到eureka-server的主目录，改写ADD的相对路径：</p><pre class="line-numbers language-none"><code class="language-none">FROM frolvlad/alpine-oraclejdk8:slimVOLUME /tmpADD ./target/eureka-server-0.0.1-SNAPSHOT.jar app.jar#RUN bash -c 'touch /app.jar'ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]EXPOSE 8761<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理修改service-hi目录；<br>编写构建镜像docker-compose-dev文件：</p><pre class="line-numbers language-none"><code class="language-none">version: '3'services:  eureka-server:    build: eureka-server    ports:      - 8761:8761  service-hi:    build: service-hi    ports:      - 8763:8763<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令构建镜像并启动：</p><pre class="line-numbers language-none"><code class="language-none">docker-compose -f docker-compose.yml -f docker-compose-dev.yml up <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://image.lichongbing.com/static/e502a55a6edb66b5b8eaec67eaa2652b.png" alt="20190601114221265.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客工具分享博客文章采集输出md格式</title>
      <link href="/2019/12/22/bo-ke-gong-ju-fen-xiang-bo-ke-wen-zhang-cai-ji-shu-chu-md-ge-shi/"/>
      <url>/2019/12/22/bo-ke-gong-ju-fen-xiang-bo-ke-wen-zhang-cai-ji-shu-chu-md-ge-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="项目连接"><a href="#项目连接" class="headerlink" title="项目连接"></a>项目连接</h2><p>1.码云:<a href="https://gitee.com/pythonywy/html_to_md">https://gitee.com/pythonywy/html_to_md </a></p><p>2.<a href="github:https://github.com/a568972484/html_to_md">github:https://github.com/a568972484/html_to_md</a></p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>需要安装的python模块</p><p><code>pip3 install requests</code></p><p><code>pip3 install lxml</code></p><p><code>pip3 install beautifulsoup4</code></p><p>代码以更新可以运行<code>Crawl_blog_post_6.1.py</code>,可以运行<code>visual.exe</code>,exe文件就不用安装依赖</p><ul><li>功能一：批量爬取博客园首页的所有随笔字典并保存JSON文件，且随笔全部转成MD格式文件</li><li>功能二：输入指定随笔网址把随笔内容转成MD并且保存</li><li>功能三：爬取某个分目录下博客</li><li>功能四:  按照分类爬取分类下所有博客,内容添加hexo传输内容包括标题,日期,方便个人博客搭建</li></ul><p>由于不同博客具有不同的见状性`要根据博客能让进行适当的修改就可以使用此程序</p><p>程序没有加入<code>多进程</code>与<code>多线程</code>进去增加博客园的负担</p><p>爬取内容<code>请不要用做商业用途</code></p><p>初衷<code>主要是为了帮助博主把已上传的随笔下载至本地方便修改</code></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><img src="https://image.lichongbing.com/static/7e9fc1c8d57f4fc649af82ec5206553a.png" alt="o_微信截图_20191029202056.png"><br><img src="http://image.lichongbing.com/static/e1b0ccf5ba586e1653c0b2ad5bfc9aa4.png" alt="o_微信截图_20191029202157.png"><br><img src="http://image.lichongbing.com/static/42f018e2796ffaf6a798e2c87e7c7323.png" alt="o_微信截图_20191029202245.png"></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p><code>2019.7.20</code></p><p>增加了功能</p><p>功能介绍:爬取某个分目录下博客</p><p>版本升级至5.0,增加了可视化界面可视化界面exe程序,增加了见状性,</p><p>只需下载exe运行即可</p><p>温馨提示:</p><p>程序由可能会被流氓杀毒软件屏蔽请自行恢复</p><p>绝对无毒的,没有添加任何恶意信息</p><p>运行程序第一功能和第三功能会因为博客数量多出现卡顿,由于本人对程序理解还不深刻没能找到解决办法,请大家见谅请不要关闭程序,结束后会自动出现数据的</p><p>都是自学的一些模块可能会有点理解不到位请大家见谅,需要原代码的解压密码私聊我就好了.</p><p>核心代码在’core_code.py’中注释都加全了</p><p><code>2019.8.21</code></p><p>增加了功能</p><p>功能介绍:按照分类爬取分类下所有博客,内容添加hexo传输内容包括标题,日期,方便个人博客搭建</p><p>exe文件没有更新,更新了核心文件</p><p>修复了:无法获取博客内容</p><p>md文本内容匹配更加规范,内容更加完善</p><p><code>2019.9.2</code></p><p>版本更新至6.1</p><ul><li>修正了匹配规则</li><li>修正了li与ul标签</li><li>修正了```格式</li><li>修正了最后一行会出现宫格</li><li>我将可视化界面代码全部展示了,但是版本还是5.版本的</li></ul><p><code>2019.10.16</code></p><ul><li>生成可视化解码</li></ul><p><code>2019.10.18</code></p><ul><li>修正批量爬取文件标题匹配不到倒bug修正匹配格式</li><li>exe文件还未<code>更新</code>,py程序已更新</li></ul><p><code>2019.10.29</code></p><ul><li>修正保存文件时候由于<code>/</code>或者<code>\</code>等特殊符号出现导致路径保存失败</li></ul><h1 id="再次强调"><a href="#再次强调" class="headerlink" title="再次强调"></a>再次强调</h1><p><code>该程序只为了帮助学习</code></p><p>码云名称:YWY</p><p>码云链接:<a href="https://gitee.com/pythonywy">https://gitee.com/pythonywy</a></p><p>github_id:a568972484</p><p>github_url:<a href="https://github.com/a568972484">https://github.com/a568972484</a></p><p>作者博客:小小咸鱼ywy</p><p>博客链接:`<a href="https://www.cnblogs.com/pythonywy">https://www.cnblogs.com/pythonywy</a></p><p><code>希望得到大家相关体验,好进行后续的改进,谢谢</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring boot面试问题集锦</title>
      <link href="/2019/12/22/spring-boot-mian-shi-wen-ti-ji-jin/"/>
      <url>/2019/12/22/spring-boot-mian-shi-wen-ti-ji-jin/</url>
      
        <content type="html"><![CDATA[<p>译文作者：<strong>david</strong>   原文链接：<a href="https://www.javainuse.com/spring/SpringBootInterviewQuestions">https://www.javainuse.com/spring/SpringBootInterviewQuestions</a><br><br>A： 多年来，随着新功能的增加，spring变得越来越复杂。只需访问页面<a href="https://spring.io/projects">https://spring.io/projects</a>，我们将看到所有在应用程序中使用的不同功能的spring项目。<strong>如果必须启动一个新的spring项目，我们必须添加构建路径或maven依赖项，配置application server，添加spring配置。因此，启动一个新的spring项目需要大量的工作，因为我们目前必须从头开始做所有事情</strong>。Spring Boot是这个问题的解决方案。Spring boot构建在现有Spring框架之上。使用spring boot，我们可以避免以前必须执行的所有样板代码和配置。因此，Spring boot帮助我们更健壮地使用现有的Spring功能，并且只需最少的工作量。<br>&nbsp;<br><br>Q:Spring Boot的优点是什么?<br><br>A: Spring Boot的优点是<br><br>　　减少开发、测试的时间和工作量。<br><br>　　使用JavaConfig有助于避免使用XML。<br><br>　　避免大量maven导入和各种版本冲突。<br><br>　　提供可选的开发方法。<br><br>　　通过提供默认开发方式进行快速开发。<br><br>　　不需要单独的Web服务器。这意味着您不再需要启动Tomcat、Glassfish或其他任何东西。<br><br>　　由于没有web.xml文件，所以需要更少的配置。只需添加带@ configuration注释的类，然后可以添加带@ bean注释的方法，Spring将自动加载对象并像往常一样管理它。您甚至可以将@Autowired添加到bean方法中，使Spring autowire成为bean所需的依赖项。<br><br>　　基于环境的配置——使用这些属性，您可以将其传递到您正在使用的应用程序环境中:- dspring .profile .active={enviorement}。在加载主应用程序属性文件之后，Spring将在(application-{environment}.properties)处加载后续的应用程序属性文件。<br>&nbsp;<br><br>Q:您使用过哪些构建工具来开发Spring引导应用程序?<br><br>A:&nbsp;Spring Boot应用程序可以使用Maven和Gradle开发。<br>&nbsp;<br><br>Q:什么是JavaConfig?<br><br>A:Spring JavaConfig是Spring社区的一个产品，它提供了一种纯java方法来配置Spring IoC容器。因此，它有助于避免使用XML配置。使用JavaConfig的优点是：<br><br>　　面向对象的配置。因为配置在JavaConfig中定义为类，所以用户可以充分利用Java中的面向对象特性。一个配置类可以子类化另一个配置类，覆盖它的@Bean方法，等等。<br><br>　　减少或消除XML配置。已经证明了基于依赖注入原则的外部化配置的好处。然而，许多开发人员不愿意在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯java方法来配置Spring容器，这种方法在概念上类似于XML配置。从技术上讲，仅使用　　 JavaConfig配置类来配置容器是可行的，但是在实践中，许多人发现将JavaConfig与XML混合并匹配是理想的。<br><br>　　类型安全的重构能力。JavaConfig提供了一种类型安全的配置Spring容器的方法。由于Java 5.0对泛型的支持，现在可以通过类型而不是名称检索bean，不需要进行任何基于类型转换或字符串的查找。<br>&nbsp;<br><br>问:如何在不重启服务器的情况下在Spring引导时重新加载我的更改?<br>答:这可以通过开发工具来实现。有了这个依赖项，您保存的任何更改都将重新启动嵌入的tomcat。Spring Boot有一个开发人员工具(DevTools)模块，它有助于提高开发人员的工作效率。Java开发人员面临的关键挑战之一是将文件更改自动部署到服务器并自动重启服务器。开发人员可以在Spring引导时重新加载更改，而不必重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布第一个版本时没有这个特性。这是开发人员最需要的特性。DevTools模块完全满足开发人员的需求。此模块将在生产环境中禁用。它还提供了H2-database控制台，以便更好地测试应用程序。使用以下依赖项</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>devtools<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>optional<span class="token operator">&gt;</span>true<span class="token operator">&lt;</span><span class="token operator">/</span>optional<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的<a href="https://www.javainuse.com/spring/SpringBootUsingPagination" target="_blank">示例</a>演示了自动启动和H2 DB控制台的DevTool依赖项用法<br><br><br>什么是Spring boot actuator?<br>答:Spring boot actuator是Spring boot framework的重要特性之一。Spring boot actuator帮助您访问生产环境中正在运行的应用程序的当前状态，在生产环境中必须检查和监视几个指标。甚至一些外部应用程序也可能使用这些服务来触发对相关人员的警报消息。actuator模块公开一组REST端点，这些端点可以作为HTTP URL直接访问，以检查状态。<br><br>问:如何将Spring Boot应用程序作为war包部署?<br>答:<a href="https://www.javainuse.com/spring/boot-war" target="_blank">Spring Boot WAR部署</a><br><br><br>问:什么是Docker吗?如何将Spring引导应用程序部署到Docker?<br>A: <a href="https://www.javainuse.com/devOps/docker" target="_blank">Docker是什么</a><br><a href="https://www.javainuse.com/devOps/docker/docker-war" target="_blank">将基于Spring的WAR应用程序部署到Docker</a><br><a href="https://www.javainuse.com/devOps/docker/docker-jar" target="_blank">将基于Spring的JAR应用程序部署到Docker</a><br><br><br>问:如何禁用执行器端点安全在Spring启动?<br>答:默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准HttpServletRequest.isUserInRole方法实现的。<br>我们可以使用-禁用安全性<br>management.security.enabled = false<br>建议仅当在防火墙后访问ACTUATOR端点时禁用安全性。<br><br>问:如何将Spring引导应用程序运行到自定义端口?<br>要在自定义端口上运行spring引导应用程序，可以在application.properties中指定端口。<br>server.port = 8090<br><br>什么是ELK堆栈?如何与Spring Boot一起使用?<br>答:ELK堆栈由三个开源产品组成——Elasticsearch、Logstash和Kibana from Elastic。<br><img src="https://img2018.cnblogs.com/blog/486074/201902/486074-20190212160437188-910625386.png" alt=""><br>Elasticsearch是一个基于Lucene搜索引擎的NoSQL数据库。<br>　　　　Logstash是一个日志管道工具，它接受来自不同来源的输入，执行不同的转换，并将数据导出到不同的目标。它是一个动态的数据收集管道，具有可扩展的插件生态系统和强大的弹性搜索协同作用<br>　　　　Kibana是一个可视化UI层，工作在Elasticsearch之上。<br>这三个项目一起用于各种环境中的日志分析。因此Logstash收集和解析日志、弹性搜索索引并存储这些信息，而Kibana提供了一个UI层，提供可操作的可见性。<br><a href="https://www.javainuse.com/spring/springboot-microservice-elk" target="_blank">Spring Boot + ELK stack</a><br><br>问:您有使用Spring Boot编写测试用例吗?<br>答:SpringBoot为编写单元测试用例提供了@SpringBootTest<br><a href="https://www.javainuse.com/spring/springboot_testcases" target="_blank">Spring引导单元测试的简单示例</a><br><br>问:YAML是什么?<br>答:YAML是一种人类可读的数据序列化语言。它通常用于配置文件。<br>与属性文件相比，YAML文件的结构更加结构化，如果我们希望在配置文件中添加复杂的属性，那么它不会造成太大的混乱。可以看到，YAML具有分层的配置数据。<br><a href="https://www.javainuse.com/spring/bootyaml" target="_blank">在Spring引导中使用YAML属性</a><br><br><br>问:如何为Spring引导应用程序实现安全性?<br><br>答:为了实现Spring Boot的安全性，我们使用Spring - Boot -starter-security依赖项，必须添加安全配置。它只需要很少的代码。Config类必须扩展WebSecurityConfigurerAdapter并覆盖它的方法。<br><a href="https://www.javainuse.com/spring/sprboot_sec" target="_blank">Spring引导安全性示例和说明</a><br><br>问:您是否集成了Spring Boot和ActiveMQ ?<br><br>为了集成Spring Boot和ActiveMQ，我们使用Spring - Boot -starter- ActiveMQ依赖项，它只需要很少的配置，没有样板代码。<br><a href="https://www.javainuse.com/spring/sprboot_activemq" target="_blank">Spring引导ActiveMQ说明</a><br><br>问:您是否集成了Spring Boot和Apache Kafka ?<br><br>答:为了集成Spring Boot和Apache Kafka，我们使用Spring - Kafka依赖项。<br><a href="https://www.javainuse.com/spring/spring-boot-apache-kafka-hello-world" target="_blank">Spring Boot + Apache Kafka示例</a><br><br>问:如何使用Spring引导实现分页和排序?<br><br>答:使用Spring Boot实现分页非常简单。使用Spring Data-JPA，这是通过传递可分页的org.springframe .data.domain来实现的。可分页到存储库方法。<br><a href="https://www.javainuse.com/spring/SpringBootInterviewQuestions" target="_blank">Spring引导分页说明</a><br><br>什么是Swagger?您是否使用Spring Boot实现了它?<br><br>答:Swagger被广泛用于可视化api，Swagger UI为前端开发人员提供在线沙箱环境。在本教程中，我们将使用Swagger 2规范的Springfox实现。Swagger是一种工具、规范和完整的框架实现，用于生成RESTful Web服务的可视化表示。它允许文档以与服务器相同的速度更新。当通过Swagger正确定义时，使用者可以用最少的实现逻辑理解远程服务并与之交互。因此Swagger消除了调用服务时的猜测。<br><a href="https://www.javainuse.com/spring/boot_swagger" target="_blank">Spring Boot + Swagger2</a><br><br>问:什么是Spring Profiles?如何使用Spring Boot实现它?<br><br>答:Spring Profiles允许用户根据配置文件(dev, test, prod等)注册bean。因此，当应用程序在开发中运行时，只能加载某些bean，当应用程序在生产中运行时，只能加载某些其他bean。假设我们的需求是Swagger文档只对QA环境启用，对所有其他环境禁用。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常容易。<br><a href="https://www.javainuse.com/spring/boot_swagger_profile" target="_blank">Spring引导+配置文件</a><br><br>什么是Spring Boot Batch?如何使用Spring Boot实现它?<br><br>答:Spring Boot Batch提供了处理大量记录所必需的可重用功能，包括日志/跟踪、事务管理、作业处理统计信息、作业重启、作业跳过和资源管理。它还提供了更高级的技术服务和特性，通过优化和分区技术，这些特性将支持极高容量和高性能的批处理作业。无论是简单的还是复杂的，大容量批处理作业都可以以高度可伸缩的方式利用该框架来处理大量信息。<br><a href="https://www.javainuse.com/spring/bootbatch" target="_blank">Spring Boot Batch</a><br><br>问:什么是FreeMarker模板?如何使用Spring Boot实现它?<br><br>答:FreeMarker是一个基于java的模板引擎，最初专注于使用MVC软件架构生成动态web页面。使用Freemarker的主要优势是完全分离了表示层和业务层。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后，使用freemarker，这些可以组合在一起，给出最终的输出页面。<br><a href="https://www.javainuse.com/spring/spring-boot-freemarker-hello-world" target="_blank">Spring Boot + FreeMarker的例子</a><br><br>问:如何使用Spring Boot实现异常处理?<br><br>答:Spring提供了一种非常有用的方法，可以使用ControllerAdvice处理异常。我们将实现一个ControlerAdvice类，它将处理控制器类抛出的所有异常。<br><a href="https://www.javainuse.com/spring/boot-exception-handling" target="_blank">Spring引导异常处理</a><br><br>什么是缓存?您在Spring引导中使用过缓存框架吗?<br><br>答:缓存是本地内存的一个区域，它保存了频繁访问的数据的副本，否则获取或计算这些数据将非常昂贵。使用Hazelcast进行缓存。<br><a href="https://www.javainuse.com/spring/spring-boot-hazelcast" target="_blank">Spring Boot + Hazelcast示例</a><br><br>问:您是否使用Spring Boot公开了SOAP web服务端点?<br>是的。使用Spring Boot公开了要使用的web服务。使用契约优先的方法从wsdl生成类。<br><a href="https://www.javainuse.com/spring/springbootsoapwebservice" target="_blank">Spring引导+ SOAP Web服务示例</a><br><br>问:您如何使用Spring Boot执行数据库操作?<br><br>答:<a href="https://www.javainuse.com/spring/SpringBoot_DataJPA" target="_blank">Spring引导教程-Spring Data JPA</a><br><a href="https://www.javainuse.com/spring/bootjdbc" target="_blank">Spring引导JDBC示例</a><br><br>问:如何使用Spring上传文件?<br><br>A: <a href="https://www.javainuse.com/spring/bootupload" target="_blank">Spring Boot +文件上传的例子</a><br>&nbsp;<br><br>问:如何用Spring Boot实现拦截器?<br>答:<a href="https://www.javainuse.com/spring/bootInterceptor" target="_blank">使用Spring MVC HandlerInterceptor与Spring引导</a><br><br>问:如何在Spring Boot下使用schedulers ?<br>答:<a href="https://www.javainuse.com/spring/bootTask" target="_blank">Spring引导任务调度程序示例</a><br><br>问:您使用过哪些启动器maven依赖项?<br>答:使用过不同的starter依赖项，如spring-boot-starter-activemq依赖项、spring-boot-starter-security依赖项、spring-boot-starter-web依赖项。<br>这有助于减少依赖项的数量，并减少版本组合。<br><a href="https://www.javainuse.com/spring/sprboot_sec" target="_blank">Spring引导安全性示例和说明</a><br><br>什么是CSRF攻击?如何启用CSRF对其进行保护?<br>CSRF代表跨站请求伪造。它是一种攻击，迫使最终用户在其当前已经过身份验证的web应用程序上执行不需要的操作。CSRF攻击专门针对状态更改请求，而不是数据窃取，因为攻击者无法看到对伪造请求的响应。<br><a href="https://www.javainuse.com/spring/boot_security_csrf" target="_blank">Spring引导安全性—启用CSRF保护</a><br><br>问:如何使用Spring引导使用表单登录身份验证?<br>答:<a href="https://www.javainuse.com/spring/boot_form_security" target="_blank">Spring引导表单安全登录Hello World示例</a><br><br>什么是OAuth2?如何使用Spring Boot实现它?<br>答:<a href="https://www.javainuse.com/spring/spring-boot-oauth-introduction" target="_blank">Spring Boot + OAuth2实现</a><br><br>问:GZIP是什么?如何使用Spring Boot实现它?<br>答:gzip是一种文件格式，是一种用于文件压缩和解压缩的软件应用程序。<br><a href="https://www.javainuse.com/spring/boot-zip" target="_blank">Spring引导+ GZIP压缩</a><br><br>问:您在Spring引导中使用过集成框架吗?<br>答:已将Apache Camel与Spring引导集成。使用Apache Camel Spring启动启动依赖项。<br><a href="https://www.javainuse.com/spring/bootcamel" target="_blank">Spring Boot +Apache Camel</a><br><br>问:什么是Apache Freemarker?什么时候使用它而不是JSP?如何与Spring Boot集成?<br>答:JSP是为网页量身定做的，Freemarker模板是一种更通用的模板语言——它可以用来生成html、纯文本、电子邮件等。<br><a href="https://www.javainuse.com/spring/spring-boot-freemarker-hello-world" target="_blank">Spring Boot + FreeMarker的例子</a><br><br>问:你什么时候使用WebSockets?如何使用Spring Boot实现它?<br>答:WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信通道。<br><img src="http://image.lichongbing.com/static/99d9d9b81f23eaf30224e83406028d43.png" alt="486074-20190212161343669-846418019.png"><br>WebSocket是双向的——使用WebSocket客户端或服务器都可以发起发送消息。<br>WebSocket是全双工的——客户端和服务器之间的通信是相互独立的。<br>单个TCP连接——初始连接使用HTTP，然后将此连接升级为基于套接字的连接。然后，这个单一连接将用于未来的所有通信<br>轻- WebSocket消息数据交换比http轻得多。<br><a href="https://www.javainuse.com/spring/boot-websocket" target="_blank">Spring Boot + WebSockets的例子</a><br><br>什么是AOP?如何与Spring Boot一起使用?<br>答:在软件开发过程中，跨越应用程序多个点的功能称为横切关注点。这些横切关注点不同于应用程序的主要业务逻辑。因此，将这些横切关注点从业务逻辑中分离出来是面向方面编程(AOP)的切入点。<br><a href="https://www.javainuse.com/spring/spring-boot-aop" target="_blank">Spring Boot + AOP示例</a><br><br>问:什么是Apache Kafka?如何与Spring Boot集成?<br>答:apache Kafka是一个分布式发布-订阅消息传递系统。它是一个可伸缩的、容错的、发布-订阅消息传递系统，使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适用于离线和在线的消息消费。<br><a href="https://www.javainuse.com/spring/spring-boot-apache-kafka-hello-world" target="_blank">Spring Boot + Apache Kafka示例</a><br><br>问:我们如何监视所有Spring Boot微服务?<br>答:Spring Boot提供了actuator&nbsp;端点来监控单个微服务的指标。这些端点对于获取关于应用程序的信息非常有帮助，比如应用程序是否启动，它们的组件(如数据库等)是否正常工作。但是，使用actuator&nbsp;接口的一个主要缺点或困难是，我们必须逐个命中这些接口，以了解应用程序的状态或健康状况。假设微服务涉及50个应用程序，管理员将不得不命中所有50个应用程序的actuator&nbsp;端点。为了帮助我们处理这种情况，我们将使用位于<a href="https://github.com/codecentric/springing-boot-admin%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%82">https://github.com/codecentric/springing-boot-admin的开源项目。</a><br>它构建在Spring Boot Actuator之上，提供了一个web UI，使我们能够可视化多个应用程序的指标。<br><a href="https://www.javainuse.com/spring/boot-admin">Spring Boot Admin</a><br><br>问:您在Spring引导中使用过Spring Cloud组件吗?<br>答:使用过Netflix Eureka等Spring Cloud组件进行服务注册，Ribbon用于负载平衡。<br><a href="https://www.javainuse.com/spring/springcloud">Spring Boot + Cloud Components&nbsp;</a><br><a href="https://www.javainuse.com/spring/spring-cloud-interview-questions">Spring Cloud interview Questions</a><br><br>问:如何将Spring Boot应用程序部署到Pivotal Cloud Foundry(PCF)?<br><a href="https://www.javainuse.com/pcf/pcf-hello">Deploying Spring Boot Application to PCF</a>&nbsp;<br><br>问:如何将Spring Boot + MySQL应用部署到Pivotal Cloud Foundry(PCF)?<br>A:&nbsp;<a href="https://www.javainuse.com/pcf/pcf-sql">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + MySQL Application to PCF</a>&nbsp;<br><br>问:如何将Spring Boot + RabbitMQ应用部署到Pivotal Cloud Foundry(PCF)?<br>A:&nbsp;<a href="https://www.javainuse.com/pcf/pcf-rabbitmq">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + RabbitMQ Application to PCF</a>&nbsp;<br>&nbsp;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构建大型电商微服务亿级架构服务之用户服务</title>
      <link href="/2019/12/19/gou-jian-da-xing-dian-shang-wei-fu-wu-yi-ji-jia-gou-fu-wu-zhi-yong-hu-fu-wu/"/>
      <url>/2019/12/19/gou-jian-da-xing-dian-shang-wei-fu-wu-yi-ji-jia-gou-fu-wu-zhi-yong-hu-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务商城角色图"><a href="#微服务商城角色图" class="headerlink" title="微服务商城角色图"></a>微服务商城角色图</h1><p><img src="http://image.lichongbing.com/static/3338b6593a1e5209344298f0ca65ad10.png" alt="微服务商城角色.png"><br>这节主要是用户服务环境构建</p><h2 id="采用的是分布式构建，先搭建父项目"><a href="#采用的是分布式构建，先搭建父项目" class="headerlink" title="采用的是分布式构建，先搭建父项目"></a>采用的是分布式构建，先搭建父项目</h2><p><img src="http://image.lichongbing.com/static/db678d6d38f238f9dd01942e6f68697e.png" alt="截屏2019-12-1922.07.55.png"></p><h2 id="项目名称就是bigmall"><a href="#项目名称就是bigmall" class="headerlink" title="项目名称就是bigmall"></a>项目名称就是bigmall</h2><p><img src="http://image.lichongbing.com/static/f32ddda04e10a70a12d4116065f082f7.png" alt="截屏2019-12-1922.08.50.png"></p><h2 id="选springboot2-2-2版本"><a href="#选springboot2-2-2版本" class="headerlink" title="选springboot2.2.2版本"></a>选springboot2.2.2版本</h2><p><img src="http://image.lichongbing.com/static/43214becf0e7490483d2efb78d40ce8d.png" alt="截屏2019-12-1922.09.46.png"></p><h2 id="再构建子项目"><a href="#再构建子项目" class="headerlink" title="再构建子项目"></a>再构建子项目</h2><p><img src="http://image.lichongbing.com/static/86fa112827eafec17eda326ef6bc40b2.png" alt="截屏2019-12-1922.11.58.png"></p><h2 id="子项目名称就是bigmalluser"><a href="#子项目名称就是bigmalluser" class="headerlink" title="子项目名称就是bigmalluser"></a>子项目名称就是bigmalluser</h2><p><img src="http://image.lichongbing.com/static/ed5239a35487c31841237333d272d170.png" alt="截屏2019-12-1922.13.06.png"></p><h2 id="选springboot2-2-2版本保持统一"><a href="#选springboot2-2-2版本保持统一" class="headerlink" title="选springboot2.2.2版本保持统一"></a>选springboot2.2.2版本保持统一</h2><p><img src="http://image.lichongbing.com/static/8200999f156fc3e9afff0b2d656413a5.png" alt="截屏2019-12-1922.13.17.png"></p><h2 id="单击完成"><a href="#单击完成" class="headerlink" title="单击完成"></a>单击完成</h2><p><img src="http://image.lichongbing.com/static/c1a263c1844bf5979bb058f373474bfe.png" alt="截屏2019-12-1922.13.27.png"></p><h2 id="依赖包配置"><a href="#依赖包配置" class="headerlink" title="依赖包配置"></a>依赖包配置</h2><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.lichongbing&lt;/groupId&gt;    &lt;artifactId&gt;bigmalluser&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;bigmalluser&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;     &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.2.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="编辑application-properties"><a href="#编辑application-properties" class="headerlink" title="编辑application.properties"></a>编辑application.properties</h2><pre><code> spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test3?useUnicode=true&amp;characterEncoding=gbk&amp;zeroDateTimeBehavior=convertToNull spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre><h2 id="编辑log4j-properties"><a href="#编辑log4j-properties" class="headerlink" title="编辑log4j.properties"></a>编辑log4j.properties</h2><pre><code>#config root loggerlog4j.rootLogger = INFO,system.outlog4j.appender.system.out=org.apache.log4j.ConsoleAppenderlog4j.appender.system.out.layout=org.apache.log4j.PatternLayoutlog4j.appender.system.out.layout.ConversionPattern=[Log] %5p[%F:%L]:%m%n#config this Project.file loggerlog4j.logger.thisProject.file=INFO,thisProject.file.outlog4j.appender.thisProject.file.out=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.thisProject.file.out.File=logContentFile.loglog4j.appender.thisProject.file.out.layout=org.apache.log4j.PatternLayout</code></pre><h2 id="用户服务文件结构"><a href="#用户服务文件结构" class="headerlink" title="用户服务文件结构"></a>用户服务文件结构</h2><pre><code>└── bigmalluser    ├── Application.java    ├── control    │&nbsp;&nbsp; └── UserControl.java    ├── dao    │&nbsp;&nbsp; └── UserDao.java    ├── mapper    │&nbsp;&nbsp; └── UserMappper.java    ├── model    │&nbsp;&nbsp; └── User.java    └── service        └── UserService.java</code></pre><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><pre><code>-- Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (`id` int(11) NOT NULL,`name` varchar(255) DEFAULT NULL,`age` int(11) DEFAULT NULL,`password` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', '7player', '18', '123456');</code></pre><h2 id="UserMapper-xml"><a href="#UserMapper-xml" class="headerlink" title="UserMapper.xml"></a>UserMapper.xml</h2><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="bigmalluser.mapper.UserMapper"&gt;  &lt;select id="findUserInfo" resultType="bigmalluser.model.User"&gt;       select name, age,password from user;  &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><pre><code>public class User {private int id;//主键private String name;//姓名private int age ;//年龄private String password;//密码public int getId() {    return id;}public String getName() {    return name;}public int getAge() {    return age;}public String getPassword() {    return password;}public void setId(int id) {    this.id = id;}public void setName(String name) {    this.name = name;}public void setAge(int age) {    this.age = age;}public void setPassword(String password) {    this.password = password;}}</code></pre><h2 id="UserMapper"><a href="#UserMapper" class="headerlink" title="UserMapper"></a>UserMapper</h2><pre><code> public interface UserMappper {   public User findUserInfo(); }</code></pre><h2 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h2><pre><code>@Componentpublic class UserDao {@AutowiredUserMappper userMappper;public User findUserInfo(){    return userMappper.findUserInfo();}}</code></pre><h2 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h2><pre><code> @Servicepublic class UserService {@AutowiredUserDao userDao;public User findUserInfo(){    return userDao.findUserInfo();}}</code></pre><h2 id="UserControl"><a href="#UserControl" class="headerlink" title="UserControl"></a>UserControl</h2><pre><code>@Controllerpublic class UserControl {@AutowiredUserService userServive;@RequestMapping("/getUserInfo")@ResponseBodypublic User getUserInfo() {    User user = userServive.findUserInfo();    if(user!=null){        System.out.println("user.getName():"+user.getName());    }    return user;}}</code></pre><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><pre><code>@EnableAutoConfiguration@SpringBootApplication@ComponentScan@MapperScan("com.bigmalluser.mapper")public class Application {private static Logger logger = Logger.getLogger(Application.class);@Bean@ConfigurationProperties(prefix="spring.datasource")public DataSource dataSource() {    return new org.apache.tomcat.jdbc.pool.DataSource();}@Beanpublic SqlSessionFactory sqlSessionFactoryBean() throws Exception {    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource());    PathMatchingResourcePatternResolver resolver = new     PathMatchingResourcePatternResolver();    sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath:/mappers/*.xml"));    return sqlSessionFactoryBean.getObject();}@Beanpublic PlatformTransactionManager transactionManager() {    return new DataSourceTransactionManager(dataSource());}/** * Start */public static void main(String[] args) {    SpringApplication.run(Application.class, args);    logger.info("SpringBoot Start Success");}}</code></pre><h2 id="用户服务的基本功能"><a href="#用户服务的基本功能" class="headerlink" title="用户服务的基本功能"></a>用户服务的基本功能</h2><p><img src="http://image.lichongbing.com/static/0f6da9b5f631c25c57ad88f1c5f3472f.png" alt="用户服务的基本功能.png"></p><h2 id="UserControl-1"><a href="#UserControl-1" class="headerlink" title="UserControl"></a>UserControl</h2><pre><code>@Controllerpublic class UserControl {@AutowiredUserService userServive;@RequestMapping("/getUserInfo")@ResponseBodypublic User getUserInfo() {    User user = userServive.findUserInfo();    if(user!=null){        System.out.println("user.getName():"+user.getName());    }    return user;}@RequestMapping(value = "/touserregister",method = RequestMethod.GET)public String touserregister() {    return "userregister";}@RequestMapping(value = "/userregister",method = RequestMethod.POST)public void userregister(User user) {    userServive.inseruserInfo(user);   return;}}</code></pre><h2 id="UserService-1"><a href="#UserService-1" class="headerlink" title="UserService"></a>UserService</h2><pre><code>@Servicepublic class UserService {@AutowiredUserDao userDao;public User findUserInfo(){    return userDao.findUserInfo();}public void inseruserInfo(User user){    userDao.inseruserInfo(user);}}</code></pre><h2 id="UserDao-1"><a href="#UserDao-1" class="headerlink" title="UserDao"></a>UserDao</h2><pre><code> @Component public class UserDao { @Autowired UserMappper userMappper; public User findUserInfo(){    return userMappper.findUserInfo();}public void inseruserInfo(User user){    userMappper.inseruserInfo(user);}}</code></pre><h2 id="UserMappper"><a href="#UserMappper" class="headerlink" title="UserMappper"></a>UserMappper</h2><pre><code>public interface UserMappper {public User findUserInfo();public void inseruserInfo(User user);} </code></pre><h2 id="UserMapper-xml-1"><a href="#UserMapper-xml-1" class="headerlink" title="UserMapper.xml"></a>UserMapper.xml</h2><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.youfan.mapper.UserMappper"&gt;&lt;select id="findUserInfo" resultType="com.youfan.model.User"&gt;    select name, age,address,telphone,qq,weixin,email,sex,birthday from user;&lt;/select&gt;&lt;insert id="inseruserInfo" parameterType="com.youfan.model.User"&gt;    &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt;        SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;    insert into user(name,account,age,passwordencrypt,address,telphone,qq,weixin,email,sex,birthday) value(#{name},#{account},#{age},#{passwordencrypt},#{address},#{telphone},#{qq},#{weixin},#{email},#{sex},#{birthday})&lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="userregister-html"><a href="#userregister-html" class="headerlink" title="userregister.html"></a>userregister.html</h2><pre><code>&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="userregister" method="post"&gt;    姓名：&lt;input name="name"/&gt;&lt;br/&gt;    用户名：&lt;input name="account"/&gt;&lt;br/&gt;    密码：&lt;input name="passwordencrypt"/&gt;&lt;br/&gt;    手机号码：&lt;input name="telphone"/&gt;&lt;br/&gt;    qq：&lt;input name="qq"/&gt;&lt;br/&gt;    微信：&lt;input name="weixin"/&gt;&lt;br/&gt;    email:&lt;input name="email"/&gt;&lt;br/&gt;    地址:&lt;input name="address"/&gt;&lt;br/&gt;    性别：男：&lt;input type="radio" name="sex" value="1" checked="true"/&gt;女：&lt;input     type="radio" name="sex" value="2"/&gt;&lt;br/&gt;    生日时间：&lt;input name="birthday"/&gt;&lt;br/&gt;    &lt;input type="submit" value="提交"/&gt;&lt;br/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h2><pre><code>@EnableAutoConfiguration@SpringBootApplication@ComponentScan@MapperScan("com.youfan.mapper")public class Application {private static Logger logger = Logger.getLogger(Application.class);@Bean@ConfigurationProperties(prefix="spring.datasource")public DataSource dataSource() {    return new org.apache.tomcat.jdbc.pool.DataSource();}@Beanpublic SqlSessionFactory sqlSessionFactoryBean() throws Exception {    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource());    PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();    sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath:/mappers/*.xml"));    return sqlSessionFactoryBean.getObject();}@Beanpublic PlatformTransactionManager transactionManager() {    return new DataSourceTransactionManager(dataSource());}/** * Start */public static void main(String[] args) {    SpringApplication.run(Application.class, args);    logger.info("SpringBoot Start Success");}}   </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构建大型电商微服务亿级架构服务概要</title>
      <link href="/2019/12/19/gou-jian-da-xing-dian-shang-wei-fu-wu-yi-ji-jia-gou-fu-wu-gai-yao/"/>
      <url>/2019/12/19/gou-jian-da-xing-dian-shang-wei-fu-wu-yi-ji-jia-gou-fu-wu-gai-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="构建大型电商微服务亿级架构服务概要"><a href="#构建大型电商微服务亿级架构服务概要" class="headerlink" title="构建大型电商微服务亿级架构服务概要"></a>构建大型电商微服务亿级架构服务概要</h1><p>本课程将手把手带大家从无到有实现一个真实的大型电商微服务项目，该项目是基于真实的知名互联网企业项目讲解的，本课程将分为3个阶段：</p><ul><li>第一阶段：会实现电商系统的大部分功能，包括：用户管理，订单管理，商品管理，支付功能，后台管理系统，单点登录，购物车，搜索功能，个人中心等等。</li><li>第二阶段：进一步完善系统，深入讲解和优化系统，包括：系统性能优化，分布式事务处理，高并发，高可用，缓存，数据库优化，消息队列的数据完整性、一致性，缓存数据的一致性，大事务的性能优化等等。</li><li>第三阶段：引入大数据分析，加入防爬虫功能，采用多语言构建我们的微服务，比如：Python，Go语言等。<br><img src="http://image.lichongbing.com/static/db3945b7309655a626f529cfa1691a55.png" alt="项目结构说明.png"></li><li>本课程包含的技术：<ul><li>SpringBoot版本1.5.13.RELEASE、SpringCloud版本Edgware.SR3 、Mybatis</li><li>微服务持续集成解决方案（Jenkins）</li><li>微服务认证解决方案（JWT）</li><li>微服务网关解决方案（Zuul）</li><li>微服务负载均衡解决方案（Ribbon）</li><li>微服务熔断解决方案（Hystrix）</li><li>微服务集中配置解决方案（SpringCloudConfig）</li><li>消息中间件解决方案（RabbitMQ）</li><li>MyCat MySQL分布式集群解决方案</li><li>FastDFS分布式文件系统（图片服务器）</li><li>Maven构建项目 Redis（缓存服务器）</li><li>MavenProfilel实现开发与生产环境切换</li><li>Thymeleaf（模板引擎技术）</li><li>Lucene、Solr（搜索）</li><li>Nginx（web服务器）</li><li>Go语言</li><li>Python实现消息通知微服务</li><li>CORS实现跨域</li><li>CAS（单点登录）</li><li>Swagger2 文档生成工具</li><li>Quartz分布式任务调度</li><li>Zookeeper</li><li>Ehcache</li><li>分布式事务</li><li>MySQL（数据库）</li><li>Restful</li><li>微信支付 银联支付 支付宝支付</li><li>CSS+DIV jQuery EasyUI</li><li>大数据技术：</li><li>Spark生态圈、Hadoop、Hive、Hbase、Kafka、Flume、Sqoop等等</li></ul></li><li>课程亮点：<ul><li>1.多语言微服务（Java、Python、Go）</li><li>2.前后端分离</li><li>3.涵盖主流支付</li><li>4.与企业无缝对接</li><li>5.跨域</li><li>6.从无到有构建微服务</li><li>7.从无到有构建大数据平台</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自建邮件服务器域名解析设置(A与MX记录)</title>
      <link href="/2019/12/19/zi-jian-you-jian-fu-wu-qi-yu-ming-jie-xi-she-zhi-a-yu-mx-ji-lu/"/>
      <url>/2019/12/19/zi-jian-you-jian-fu-wu-qi-yu-ming-jie-xi-she-zhi-a-yu-mx-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="自建邮件服务器域名解析设置-A与MX记录"><a href="#自建邮件服务器域名解析设置-A与MX记录" class="headerlink" title="自建邮件服务器域名解析设置(A与MX记录)"></a>自建邮件服务器域名解析设置(A与MX记录)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果域名没有做解析，只能用于内网收发邮件。要想实现与外网邮箱的收发，需要做域名解析。是在“域名解析后台”进行设置（域名提供商提供“域名解析后台”）。</p><ol><li>域名的申请<br>目前在国内提供域名申请的服务商很多，下面列表常见的服务商以供考。万网，新网 ，商务中国<br>有关域名的申请可以请见各网站的相关说明，在此就不作详细说明。域名一般是每年是要缴一定的服务费的。</li><li>域名的设置<br>下面我们以万网 为例来讲述设置的全过程，其他的域名服务商的所提供域名设置与此类似。<br>万网的域名设置</li></ol><h2 id="A-域名与固定-IP-地址的设置"><a href="#A-域名与固定-IP-地址的设置" class="headerlink" title="A. 域名与固定 IP 地址的设置"></a>A. 域名与固定 IP 地址的设置</h2><p>1）登录万网账户进入【控制台】<br><img src="http://image.lichongbing.com/static/6476d42875fb8b3838c54f3db06dfded.png" alt="wKioL1kaqZyioiEYAAN9LmC_KW4068.png"><br>2） 在管理后台找到【域名】菜单<br><img src="http://image.lichongbing.com/static/fed524b51b5f011224924728b5890b82.png" alt="wKiom1kaqZ3CCxHdAACYsWOAfCA642.png"><br>3） 在“增加新记录”下增加 MX 记录，类型选择 MX记录，值可以填写主机名，也可以填写你的固定的 IP 地址。我们这里填写主机名：mail.chinaumail.com, 优先级设置为5<br><img src="http://image.lichongbing.com/static/66b361dd8606bfe72014493f68115a1e.png" alt="wKioL1kaqZ3CDLnlAABlH0Ss4yI499.png"><br>说明：值的最后有一个点，代表主机名结束。在有些域名服务商网站设置的时候不会自动帮您加上，如果漏掉的话 DNS 服务器在解析的时候，会自动并上你的域名，这样会引起解析错误。<br>4） 如果 MX 记录设置的值为主机名或是域名，则需要增加对应的 A 记录。例如我们MX记录的值设置的是 mail.chinaumail.com 则需要增加一条相应的 A 记录。<br><img src="http://image.lichongbing.com/static/885d85fa5bd8b131632b5e9772137c38.png" alt="wKiom1kaqZ2w4vUfAABQPw7os0o166.png"><br>5） 对于某些客户需要用客户端来收发邮件，建议增加pop,smtp,imap记录。增加完毕，可以在记录列表中看到设置的MX记录和A记录。<br><img src="http://image.lichongbing.com/static/0bd5b6ae89f43471e15f2c269d8c335b.png" alt="wKioL1kaqZ3TePfBAACHPmjJgM4958.png"></p><h2 id="B-域名与动态域名的配合"><a href="#B-域名与动态域名的配合" class="headerlink" title="B. 域名与动态域名的配合"></a>B. 域名与动态域名的配合</h2><p>1） 登录万网账户进入【控制台】<br><img src="http://image.lichongbing.com/static/6476d42875fb8b3838c54f3db06dfded.png" alt="wKiom1kaqZ_xBUHSAAN9LmC_KW4547.png"><br>2）在管理后台找到【域名】菜单<br><img src="http://image.lichongbing.com/static/fed524b51b5f011224924728b5890b82.png" alt="wKioL1kaqZ_Q0ZEYAACYsWOAfCA037.png"><br>3） 在“增加新记录”下增加 MX 记录，类型选择MX记录,值可以填写动态域名 umailtest.vicp.net，优先级一般设置为5。<br><img src="http://image.lichongbing.com/static/ca804bffd9c76d7bd0d0c9557dd5994d.png" alt="wKiom1kaqaDw6le-AABo15MG_xs120.png"><br><strong>说明</strong>：值的最后有一个点，代表主机名结束。在有些域名服务商网站设置的时候不会自动帮您加上，如果漏掉的话 DNS 服务器在解析的时候，会自动并上你的域名，这样会引起解析错误。<br>4） 万网还提供了主机名可以指向到一个别名（CNAME 记录），这时我们可以设置一个主机名 mail.chinaumail.com ，指向到动态域名umailtest.vicp.net 。<br><img src="http://image.lichongbing.com/static/f19ac02a6036fdf8f5c010ba21e3e2ed.png" alt="wKioL1kaqaCQ2FtxAABYcIRT8lc322.png"><br>5）对于某些客户需要用客户端来收发邮件，建议增加pop,smtp,imap记录。增加完毕，可以在记录列表中看到设置的 MX 记录和 CNAME 记录。<br><img src="http://image.lichongbing.com/static/d385691c51f754079a7f52d075fc277b.png" alt="wKioL1kaqaCSTpfzAACT7IHv4Rw137.png"></p><p>正确安装设置完 U-Mail邮件系统。 并对 Internet 开放 SMTP 25 ， POP3 110 ， Webmail 80 等端口（经过路由的需要做端口映射），您的邮件服务器就可以正常使用了。<br><strong>注意</strong>：</p><pre><code>1. 域名的 MX 或 A 记录设置后一般需要 12-24小时才能生效，各域名服务商的更新时间不完全一样，所以生效时间也不一样。下面的安装和设置过程中，我们假定域名设置已经生效。用户在域名设置没有生效前，可以在需要填写主机名的位置，暂时使用你的 IP 地址或动态域名地址来代替换。2. 在下面的设置过程中我们umailtest.vicp.net和 mail.chinaumail.com作为例子，用户在实际运用中可以根据自己的实际情况，来设置确定要申请的域名，并以新申请的域名来设置邮件系统。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最新ubuntu搭建公网个人邮件服务器(基于postfix，dovecot,mysql)</title>
      <link href="/2019/12/18/zui-xin-ubuntu-da-jian-gong-wang-ge-ren-you-jian-fu-wu-qi-ji-yu-postfix-dovecot-mysql/"/>
      <url>/2019/12/18/zui-xin-ubuntu-da-jian-gong-wang-ge-ren-you-jian-fu-wu-qi-ji-yu-postfix-dovecot-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="最新ubuntu搭建公网个人邮件服务器-基于postfix，dovecot-mysql"><a href="#最新ubuntu搭建公网个人邮件服务器-基于postfix，dovecot-mysql" class="headerlink" title="最新ubuntu搭建公网个人邮件服务器(基于postfix，dovecot,mysql)"></a>最新ubuntu搭建公网个人邮件服务器(基于postfix，dovecot,mysql)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做了一个应用，需要用邮件发通知，但是免费的邮箱每天发信数量是有限制的，所以呢就想着搭建一个自己的邮件服务器，能够实现邮件的发送和接收即可,其中大概花了一个星期找资料，测试，终于成功了，写个教程分享给大家。<br>本教程基于 ubuntu 18.04（其他的 linux 理论上也是可以的，只是安装的软件包不一样）。用到的主要软件为：postfix,dovecot,mysql.废话不多说，下面是教程：</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>mysql 数据库。本教程中使用 mysql 存储域名，用户信息等。</p><p>域名。需要有域名才能实现向公网发邮件/收邮件。这里以 lichongbing.com 为例。</p><p>ssl 证书。有不少免费的 ssl 证书提供商，或者使用自签证书，百度即可。</p><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><p>切换到 root 用户下，执行以下命令：</p><pre><code>apt updateapt install postfix postfix-mysql dovecot-core dovecot-pop3d dovecot-imapd dovecot-lmtpd     dovecot-mysql</code></pre><p>安装过程中 postfix 会弹出提示：</p><p><img src="http://image.lichongbing.com/static/ff39986df48e20489dfeaa12594d1f0e.png" alt="20190425132019.png"><br>选择类别<br>这里我们选择第二项：Internet Site。<br>接着会有如下提示：<br><img src="http://image.lichongbing.com/static/fbabe3f64919e05da04afc452a66f454.png" alt="20190425132348.png"></p><p>域名</p><p>这里填入：lichongbing.com</p><h4 id="配置-mx-解析"><a href="#配置-mx-解析" class="headerlink" title="配置 mx 解析"></a>配置 mx 解析</h4><p>在域名提供商增加以下解析：</p><p>MX 记录：lichongbing.com 指向 服务器IP</p><p>A 记录：pop3.lichongbing.com 指向 服务器IP</p><p>A 记录：smtp.lichongbing.com 指向 服务器IP</p><h4 id="创建-mysql-数据库"><a href="#创建-mysql-数据库" class="headerlink" title="创建 mysql 数据库"></a>创建 mysql 数据库</h4><p>新建一个数据库 mailserver，管理账号为：admin/123456</p><p>创建虚拟域表，作为认证域。该表是邮件服务器用以接收邮件的域名：</p><pre><code>-- 建立表CREATE TABLE `virtual_domains` (`id`  INT NOT NULL AUTO_INCREMENT,`name` VARCHAR(50) NOT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 插入一条记录insert into virtual_domains values(1,'test.com')</code></pre><p>创建用户表，用于用户身份认证。</p><pre><code> -- 创建用户表 CREATE TABLE `virtual_users` (  `id` INT NOT NULL AUTO_INCREMENT,  `domain_id` INT NOT NULL,  `password` VARCHAR(106) NOT NULL,  `email` VARCHAR(120) NOT NULL,  PRIMARY KEY (`id`), UNIQUE KEY  `email` (`email`),  FOREIGN KEY (domain_id) REFERENCES virtual_domains(id)  ON DELETE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 插入两个用户,以md5加密密码，实际应用中应该选择强度更高的算法，md5目前以及不安全了 insert into virtual_users values(1,1,md5('123456'),'first@lichongbing.com'); insert into virtual_users values(2,1,md5('123456'),'second@lichongbing.com');</code></pre><p>创建别名表.该表作用相当于当 source 收到邮件时，该邮件会自动转发到 destination 上。</p><pre><code>-- 创建表CREATE TABLE `virtual_aliases` (`id` int(11) NOT NULL auto_increment,`domain_id` int(11) NOT NULL,`source` varchar(100) NOT NULL,`destination` varchar(100) NOT NULL,PRIMARY KEY (`id`),FOREIGN KEY (domain_id) REFERENCES virtual_domains(id) ON DELETE CASCADE)ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 插入数据,所有发给first的邮件都会自动转发给secondinsert into virtual_aliases values(1,1,'first@lichongbing.com','second@lichongbing.com')</code></pre><p>生成 ssl 证书<br>生成 ssl 证书可参考这一篇<a href="https://www.jianshu.com/p/b47d862bceeb.%E4%B8%BA">https://www.jianshu.com/p/b47d862bceeb.为</a> test.com 生成 ssl 证书，假设证书存放地址为：</p><p>公钥 /etc/letsencrypt/live/test.com/fullchain.pem;<br>私钥 /etc/letsencrypt/live/test.com/privkey.pem;<br>配置 postfix<br>首选备份 postfix 的默认配置文件,然后编辑main.cf</p><pre><code>cp /etc/postfix/main.cf /etc/postfix/main.cf.bakvim /etc/postfix/main.cf</code></pre><p>注释下面的配置：<br><img src="http://image.lichongbing.com/static/e8ef7778092d366ee91cb0711ccb00c7.jpg" alt="QQ20191219-0.jpg"><br>注释</p><p>然后加入如下的配置：</p><pre><code># 使用自己的ssl证书smtpd_tls_cert_file=/etc/letsencrypt/live/test.com/fullchain.pemsmtpd_tls_key_file=/etc/letsencrypt/live/test.com/privkey.pemsmtpd_use_tls=yessmtpd_tls_auth_only = yes# 使用dovecot来做身份认证smtpd_sasl_type = dovecotsmtpd_sasl_path = private/authsmtpd_sasl_auth_enable = yessmtpd_recipient_restrictions =     permit_sasl_authenticated,permit_mynetworks,reject_unauth_destination</code></pre><p>修改 myhostname,myorigin 为如下的值：</p><pre><code>myhostname = lichongbing.commyorigin = $myhostname</code></pre><p>修改 mydestination 值为 localhost,以启动 mysql 中的虚拟域。：</p><pre><code>mydestination = localhost</code></pre><p>在配置文件的最后加入以下行，确保将邮件投递给 mysql 表中列出的虚拟域。</p><pre><code>virtual_transport = lmtp:unix:private/dovecot-lmtp</code></pre><p>最后加入以下三项参数，告知 Postfix 配置虚拟域、用户和别名</p><pre><code>virtual_mailbox_domains = mysql:/etc/postfix/mysql-virtual-mailbox-domains.cfvirtual_mailbox_maps = mysql:/etc/postfix/mysql-virtual-mailbox-maps.cfvirtual_alias_maps = mysql:/etc/postfix/mysql-virtual-alias-maps.cf</code></pre><p>接下来创建上面最后加入的三项参数对应的文件。</p><p>创建/etc/postfix/mysql-virtual-mailbox-domains.cf,内容如下：</p><pre><code>user = adminpassword = 123456port = 3306hosts = 127.0.0.1dbname = mailserverquery = SELECT 1 FROM virtual_domains WHERE name='%s'</code></pre><p>接着重启 postfix，并测试 postfix 能否找到域,如果成功返回 1：</p><pre><code>service postfix restartpostmap -q lichongbing.com mysql:/etc/postfix/mysql-virtual-mailbox-domains.cf</code></pre><p>创建/etc/postfix/mysql-virtual-mailbox-maps.cf,内容如下：</p><pre><code>user = adminpassword = 123456port = 3306hosts = 127.0.0.1dbname = mailserverquery = SELECT 1 FROM virtual_users WHERE email='%s'接着重启 postfix，并测试其能否找到邮箱地址，成功返回 1：service postfix restartpostmap -q first@lichongbing.com mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf</code></pre><p>最后创建/etc/postfix/mysql-virtual-alias-maps.cf,内容如下：</p><pre><code>user = adminpassword = 123456port = 3306hosts = 127.0.0.1dbname = mailserverquery = SELECT destination FROM virtual_aliases WHERE source='%s'</code></pre><p>同样重启 postfix，验证能否正确找到别名，并返回：</p><pre><code>service postfix restartpostmap -q first@lichongbing.com mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf</code></pre><p>如果响应使用 587 端口来进行俺的 smtp 通信，需修改/etc/postfix/master.cf 文件：<br>取消以下行的注释：</p><p>配置 dovecot<br>postfix 配置完毕，现在来配置 dovecot，首先编辑主配置文件/etc/dovecot/dovecot.conf:</p><p>首先确保下面一行是启用的：</p><pre><code>!include conf.d/*.conf</code></pre><p>然后在配置文件的最后加入如下配置，启用各协议：</p><pre><code>protocols = imap lmtp pop3</code></pre><p>修改/etc/dovecot/conf.d/10-mail.conf,确保存在以下两个配置：</p><pre><code>mail_location = maildir:/var/mail/vhosts/%d/%nmail_privileged_group = mail</code></pre><p>上面的配置将邮件存放目录设置在/var/mail 中，因此将该文件夹的所属人改为 vmail/vmail.命令如下：</p><pre><code>groupadd -g 5000 vmailuseradd -g vmail -u 5000 vmail -d /var/mailchown -R vmail:vmail /var/mail</code></pre><p>修改/etc/dovecot/conf.d/10-auth.conf。首先确保如下两个配置存在且值正确：</p><pre><code>disable_plaintext_auth = yesauth_mechanisms = plain login</code></pre><p>然后修改配置以禁用系统用户登陆，并开启 mysql 支持,如下图所示：<br>启用mysql支持</p><p>修改/etc/dovecot/conf.d/auth-sql.conf.ext文件，将内容改成下面的内容：</p><pre><code>passdb {  driver = sql  args = /etc/dovecot/dovecot-sql.conf.ext}userdb {  driver = static  args = uid=vmail gid=vmail home=/var/mail/vhosts/%d/%n}</code></pre><p>修改/etc/dovecot/dovecot-sql.conf.ext:<br>首选取消 driver 参数注释并设置为 mysql</p><pre><code>driver = mysql</code></pre><p>然后取消 connect 行注释并设置为如下内容：</p><pre><code>connect = host=127.0.0.1 port=3306 dbname=mailserver user=admin password=123456</code></pre><p>接着取消 default_pass_scheme 行的注释并改为 MD5</p><pre><code>default_pass_scheme = MD5</code></pre><p>接着取消 password_query 行的注释并设置为以下信息：</p><pre><code>password_query = SELECT email as user, password FROM virtual_users WHERE email='%u';</code></pre><p>最后将/etc/dovecot的拥有者改为 vmail:dovecot</p><pre><code>chown -R vmail:dovecot /etc/dovecotchmod -R o-rwx /etc/dovecot</code></pre><p>修改/etc/dovecot/conf.d/10-master.conf:</p><p>首先将 imap-login , pop3-login 下第一个的 port 设置为 0，以禁用非 ssl 加密的 imap 和 pop3 协议，如下图所示：</p><p>然后找到service lmtp将其修改为如下：</p><pre><code>service lmtp {  unix_listener /var/spool/postfix/private/dovecot-lmtp {    mode = 0600    user = postfix    group = postfix  }  # Create inet listener only if you can't use the above UNIX socket  #inet_listener lmtp {    # Avoid making LMTP visible for the entire internet    #address =    #port =  #}}</code></pre><p>然后找到service auth将其内容修改为如下：</p><pre><code>service auth {  unix_listener /var/spool/postfix/private/auth {    mode = 0666    user = postfix    group = postfix  }  unix_listener auth-userdb {    mode = 0600    user = vmail    #group =  }  user = dovecot}</code></pre><p>最后找到service auth-worker改为如下内容：</p><pre><code>service auth-worker {  # Auth worker process is run as root by default, so that it can access  # /etc/shadow. If this isn't necessary, the user should be changed to  # $default_internal_user.  user = vmail}</code></pre><p>最后要改的就是/etc/dovecot/conf.d/10-ssl.conf,以开启 ssl 认证.</p><p>首先将 ssl 参数改为 required：</p><pre><code>ssl = required</code></pre><p>然后设置 ssl 证书路径就 ok 了,还是用之前的 ssl 证书：</p><pre><code>ssl_cert = &lt;/etc/letsencrypt/live/test.com/fullchain.pemssl_key = &lt;/etc/letsencrypt/live/test.com/privkey.pem</code></pre><p>到这里所有的配置都 OK，重启 postfix，dovecot 后就可以用邮箱客户端（比如 foxmail）连接了。</p><pre><code>service postfix restartservice dovecot restart</code></pre><p>结束<br>配合一个邮件客户端看似很简单，实际上还是有很多坑的，看看上面那么多的配置项就知道了，一定要耐心。</p><p>如果无法登陆，可以看看 postfix 和 dovecot 的日志报错情况，再去修改。日志位置在/var/log</p><p>注意:<br>被这个问题困扰了好几天，未找到解决办法，最后放弃.</p><p>目前很多主机厂商都不支持和其他服务器的 25 端口通信，已知的有（谷歌云，阿里云），这样就导致在这些机器上搭建的 postfix 邮件服务器，无法向其他的外网邮箱发送邮件，因为无法和其他 smtp 服务器的 25 端口建立连接。貌似是为了避免有人恶意搭建邮件服务器向其他的邮件服务器发送大量的垃圾邮件，从而导致此服务器 IP 被反垃圾邮件组织列入 SML。</p><p>本博客原创发布于：<a href="http://tapme.top/blog/detail/2019-04-05!">https://tapme.top/blog/detail/2019-04-05</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot Web Https 配置</title>
      <link href="/2019/12/16/springboot-web-https-pei-zhi/"/>
      <url>/2019/12/16/springboot-web-https-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我最近搭建一个网盘，兴高采烈分享给身边的朋友使用，其中有朋友觉得不安全，于是我把http升级https，以增加安全性。比如目前火热的小程序，要求服务端必须支持https，苹果商店也有说http请求要修改为https。所以https将会是游戏服务器的普遍需求。</p><h2 id="一，证书生成"><a href="#一，证书生成" class="headerlink" title="一，证书生成"></a>一，证书生成</h2><p>证书可以自己使用jdk生成进行测试。但是在正常使用的时候，需要去第三方机构购买，网上也有免费的。不过有效期有限制。具体获取证书的方法这里不再详细说明了。一般拿到证书之后会得到这几个文件：</p><pre><code>3232526_cloud.lichongbing.com.jks    https.jks 3232526_cloud.lichongbing.com.pfx    pfx-password.txt certificate.crt    detail.txtprivate.pem    www.jks certificate.pfx    fullchain.crt    public.pem</code></pre><h2 id="二，证书格式选择与部分转化。"><a href="#二，证书格式选择与部分转化。" class="headerlink" title="二，证书格式选择与部分转化。"></a>二，证书格式选择与部分转化。</h2><p>如果使用nginx跳转的话，上面的证书文件可以直接使用，但是在老版本tomcat中，证书的配置文件格式必须是.keystore的文件。所以需要做一下转化。以下2点参考</p><p>1、生成pkcs12格式的密钥文件：</p><pre><code>$ openssl pkcs12 -export -in cert.pem -inkey privkey.pem -out my.pk12 -name mykey</code></pre><p>(注：此过程中需要输入密码：123456)</p><p>2、生成keystore：</p><pre><code>$ keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore my.keystore -srckeystore my.pk12 -srcstoretype PKCS12 -srcstorepass 123456 -alias shkey</code></pre><p>成功之后会获得my.keystore文件。</p><p>3、而我选择.pfx格式文件直接使用，因为新版tomcat支持.pfx和jks。</p><h2 id="三，在Spring-boot-web中配置https"><a href="#三，在Spring-boot-web中配置https" class="headerlink" title="三，在Spring boot web中配置https"></a>三，在Spring boot web中配置https</h2><p>首先是在application.yml中添加配置</p><pre><code>server:     ssl:        key-store: 3228357_www.lichongbing.com.pfx        key-store-password: XXxxx00  #pfx-password.txt中复制出来的密码        keyStoreType: PKCS12        enabled: true     port: 443http:    port: 80</code></pre><p>这样配置之后，启动服务，就可以https访问了。</p><h2 id="四，同时支持http和https访问"><a href="#四，同时支持http和https访问" class="headerlink" title="四，同时支持http和https访问"></a>四，同时支持http和https访问</h2><h3 id="1，http请求不跳转成https访问（仅供参考）"><a href="#1，http请求不跳转成https访问（仅供参考）" class="headerlink" title="1，http请求不跳转成https访问（仅供参考）"></a>1，http请求不跳转成https访问（仅供参考）</h3><p>这种方式是http请求单独走一个端口，https请求单独走一个端口。但是spring boot 的appplication.properties只能配置一个端口，这就需要我们手动再添加一个Connector了。</p><pre><code>@Configurationpublic class TomcatConfig {@Beanpublic EmbeddedServletContainerFactory servletContainerFactory(){TomcatEmbeddedServletContainerFactory tomcatConfig = new     TomcatEmbeddedServletContainerFactory();tomcatConfig.addAdditionalTomcatConnectors(this.newHttpConnector());return tomcatConfig;}private Connector newHttpConnector() {Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");connector.setScheme("http");connector.setPort(80);connector.setSecure(false);return connector;}}</code></pre><p>　　</p><p>这样普通 的http请求，可以访问8080端口了。</p><h3 id="2，将http请求强制跳转到https（仅供参考）"><a href="#2，将http请求强制跳转到https（仅供参考）" class="headerlink" title="2，将http请求强制跳转到https（仅供参考）"></a>2，将http请求强制跳转到https（仅供参考）</h3><p>有时候我们的一些旧业务是使用的http，但是新业务以及将来的框架都必须强制使用https，那就需要做一下跳转，把收到的http请求强制跳转到https上面。</p><pre><code>@Configurationpublic class TomcatConfig {@Beanpublic EmbeddedServletContainerFactory servletContainerFactory(){TomcatEmbeddedServletContainerFactory tomcatConfig = new     TomcatEmbeddedServletContainerFactory(){@Overrideprotected void postProcessContext(Context context) {SecurityConstraint securityConstraint = new SecurityConstraint();securityConstraint.setUserConstraint("CONFIDENTIAL");SecurityCollection collection = new SecurityCollection();// 这里不知道为什么，只能配置以/*结尾的path。这样配置表示全部请求使用安全模式，必须走httpscollection.addPattern("/*");//另外还可以配置哪些请求必须走https，这表示以/home/开头的请求必须走httpscollection.addPattern("/home/*");securityConstraint.addCollection(collection);context.addConstraint(securityConstraint);}};tomcatConfig.addAdditionalTomcatConnectors(this.newHttpConnector());return tomcatConfig;}private Connector newHttpConnector() {Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");connector.setScheme("http");connector.setPort(80);connector.setSecure(false);// 如果只需要支持https访问，这里把收到的http请求跳转到https的端口connector.setRedirectPort(8446);return connector;}}</code></pre><p>而我比较简单粗暴参考我的代码，就是在springboot主程序入口添加两个函数方法。例如我的项目</p><pre><code>package com.lichongbing.devreume;import org.apache.catalina.Context;import org.apache.catalina.connector.Connector;import org.apache.tomcat.util.descriptor.web.SecurityCollection;import org.apache.tomcat.util.descriptor.web.SecurityConstraint;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.servlet.server.ServletWebServerFactory;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class DevreumeApplication {    public static void main(String[] args) {       SpringApplication.run(DevreumeApplication.class, args);    }    @Bean    public ServletWebServerFactory servletContainer() {        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {            @Override            protected void postProcessContext(Context context) {                // 如果要强制使用https，请松开以下注释                SecurityConstraint constraint = new SecurityConstraint();                constraint.setUserConstraint("CONFIDENTIAL");                SecurityCollection collection = new SecurityCollection();                collection.addPattern("/*");                constraint.addCollection(collection);                context.addConstraint(constraint);            }        };        tomcat.addAdditionalTomcatConnectors(createStandardConnector()); // 添加http        return tomcat;    }    // 配置http    private Connector createStandardConnector() {        // 默认协议为org.apache.coyote.http11.Http11NioProtocol        Connector connector = new     Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);        connector.setSecure(false);        connector.setScheme("http");        connector.setPort(port);        connector.setRedirectPort(httpsPort); // 当http重定向到https时的https端口号        return connector;    }        @Value("${http.port}")        private Integer port;        @Value("${server.port}")        private Integer httpsPort;    }</code></pre><p>以上跳转也可以使用nginx实现。如果有什么问题可以评论留言或加QQ：873610008交流</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>业余时间写的代码也算公司的？Nginx之父被捕引发争议</title>
      <link href="/2019/12/16/ye-yu-shi-jian-xie-de-dai-ma-ye-suan-gong-si-de-nginx-zhi-fu-bei-bu-yin-fa-zheng-yi/"/>
      <url>/2019/12/16/ye-yu-shi-jian-xie-de-dai-ma-ye-suan-gong-si-de-nginx-zhi-fu-bei-bu-yin-fa-zheng-yi/</url>
      
        <content type="html"><![CDATA[<p>据ZDNet报道，近日，俄罗斯的两位开发者突然被捕，其中一人是风靡全球的网页服务器 Nginx之父 Igor Sysoev。警方给出的理由是二人涉嫌项目侵权。这个项目指的是Nginx，是Igor Sysoev 15年前在老东家任职期间利用业余时间开发的。</p><p>Igor Sysoev15年前任职于俄罗斯公司 Rambler（俄罗斯最大的搜索引擎和互联网门户之一“rambler.ru”的母公司），在此期间利用业余时间开发了网页服务器 Nginx。目前，Nginx已经成为风靡全球的服务器，BAT、Facebook 都将其作为企业IT架构的一部分。Igor Sysoev也于2011年利用此项目创办了 NGINX公司。但多年之后，他的老东家Rambler声称：Nginx是Sysoev在Rambler公司任职期间开发的，所有权也应该是公司的。</p><p>Nginx之父突然被捕</p><p>据ZDnet报道，12月12日，俄罗斯警方搜查了商业服务器公司Nginx，并当场带走了两位联合创始人。</p><p>最早爆出这个消息的是Nginx的一名员工，他在一条推特中称：公司的两位创始人Konovalov和Sysoev被带走了。同时他表示，情况正在审查中，其他人员目前没有被拘留。<br>图源：<br><img src="https://image.lichongbing.com/static/0b2b7268d1f5b17c2d19ea587f363cdf.jpg" alt="a099-ikrsess8317893.jpg"></p><p>推特用户@AntonNesterov<br><img src="https://image.lichongbing.com/static/37374dfa331ed3cdf91a58fb46f2c9bb.jpg" alt="ec4a-ikrsess8317933.jpg"></p><p>图源：</p><p>ZDnet</p><p>Nginx是一款轻量级的Web服务器/反向代服务器及电子邮件代理服务器，在BSD-like协议下发行，有着“占有内存少”和“并发 能力强”的特点，第一个公开版本0.1.0发布于2004年10月4日。国内很多企业都会nginx网站，包括百度、京东、新浪、网易、腾讯、淘宝等这些Top级公司。</p><p>2019年2月，NGINX最终取代ApacheHTTPD，成为互联网上部署最广泛的服务器。据Netcraft在2019年12月的Web服务器调查显示，NGINX的市场份额高达38%。</p><p>Nginx此番被搜查疑似和此前Rambler集团的起诉有关。Rambler集团是俄罗斯最大的搜索引擎和互联网门户之一“rambler.ru”的母公司。上周，Rambler集团曾对NGINX公司提起版权侵犯诉讼，声称拥有NGINX代码的完全所有权。理由是Igor Sysoev在Rambler集团担任系统管理员时开发了Nginx，因此Rambler集团是Nginx所有代码的合法所有者。</p><p>两位联合创始人被带走当日，Nginx的员工@igorippolitov在推特上发出了搜查令的相关图片，随即被要求删除，但原推已被网友截图，引发关注。<br><img src="https://image.lichongbing.com/static/b39f62e3eb48c725af2bbaec08367cb9.jpg" alt="edf2-ikrsess8317934.jpg"></p><p>推文内容：“看来是Rambler填写了这份关于Nginx和Sysoev的版权声明，NGINX受到了警方的突击检查（未经证实）。NGINX员工@igorippolitov是原始发布者，但有人要求他删帖。”</p><p><img src="https://image.lichongbing.com/static/8e4d75a714137b772e926f6e597a53dc.jpg" alt="9bf5-ikrsess8317991.jpg"></p><p>Rambler集团方面的版权声明。</p><p>后来，Rambler集团也向媒体方面作出了俄文版正式回复：</p><p><img src="https://image.lichongbing.com/static/042915890f597c537fb8ec8ea4b538dd.jpg" alt="5189-ikrsess8317999.jpg"></p><p>图源：</p><p>俄罗斯媒体TheBell</p><p>在这篇回复中，Rambler集团就两个问题进行了说明，一是“搜查事件是否与此前Rambler集团的声明有关？”，二是“声明中侵犯Rambler集团权利的确切含义是什么？”</p><p>Rambler集团表示，自2000年初以来，Igor Sysoev所完成的开发工作均属于其与Rambler的劳资关系框架内，因此未经Rambler集团同意，其他主体对本程序的任何使用均侵犯了专有权。</p><p>据接近NGINX的媒体人士了解，两位联合创始人在被询问后已获释，不过他们的个人手机已被没收。<br><img src="https://image.lichongbing.com/static/17cb7f0e971eec09a5c5925e0180c842.jpg" alt="a52c-ikrsess8318044.jpg"></p><p>图源：俄罗斯媒体TheBell</p><p>目前，NGINX公司对此事还未正式回应。</p><p>Igor Sysoev：Nginx确系任职Rambler期间开发，但利用的是业余时间</p><p>Igor Sysoev在领英上的自我介绍是“Nginx的作者”。他毕业于莫斯科国立鲍曼技术大学（Bauman Moscow State Technical University），2000年-2011年就职于俄罗斯Rambler公司，担任该公司的系统管理员，任职时间接近11年。</p><p><img src="https://image.lichongbing.com/static/cc9de1ebc1836670f991b8b6ed36a6bc.jpg" alt="6776-ikrsess8318093.jpg"></p><p>Sysoev从来没有否认Nginx是他在前东家Rambler任职期间开发的。但在2012年的一次访谈中，他表示自己开发Nginx用的是业余时间，最初Rambler甚至都不知道。</p><p>他表示，该服务器最初并不是部署在Rambler公司的，而是部署在Rate.ee和zvuki.ru网站上。在一名好奇同事询问之后，Rambler才开始使用Nginx。</p><p>在离开Rambler之后，Igor Sysoev在美国创办了NGINX公司，为Nginx部署系统提供配套的工具和支持服务。该公司总部位于旧金山，但在世界各地（包括莫斯科）设有办事处。</p><p>2019年，NGINX被F5Framework公司收购，作为后者的子公司继续运营。</p><p>业余时间开发的东西也属于公司吗？</p><p>在Igor Sysoev被捕之后，知乎上也发起了相关讨论——开发者业余时间开发的东西到底是属于自己还是属于公司？</p><p>从回答区可以看出，不同的公司对于这个问题有着不同的态度。有的公司为了避免纠纷或损害公司利益，会直接在劳动合同里写明个人在业余时间创作的东西也属于公司。但也有公司比较宽松，只要开发的过程中没有用到属于该公司的软件copy和硬件设置，开发成果就属于员工个人。</p><p>但从公司的角度来讲，跟离职员工争知识产权真的是一种利益最大化的做法吗？还有没有其他选择？</p><p>Google前高级资深研究员吴军在《浪潮之巅》中曾经提到过思科在这个问题上的做法。</p><p>在上市之后，思科的创始员工面临积极性减弱、效率降低的问题，但他们身上依然具备很多创业者身上的优秀品质，如创造力、勤奋、热情等。</p><p>为了让这一部分员工人尽其才，思科的管理者钱伯斯开始鼓励有能力的员工创业。这种做法表面看起来对公司没有什么好处，还有可能造成优秀员工的流失。但钱伯斯的做法是，投资自己员工创办的公司，如果这些公司有所成就，思科享有优先收购权。</p><p>这种创新的管理模式在思科的成功之路上发挥了很大作用。</p><p>当然，这种做法并不一定适合每个公司，也不一定都能造就一个成功的企业。但这个例子可以说明，在对待“员工业余时间创作的知识成果”方面，我们可能还有其他选择。</p><p>文/蛋酱、张倩</p><p>来源：机器之心（ID:almosthuman2014）</p><p>参考链接：</p><p><a href="https://www.zdnet.com/article/russian-police-raid-nginx-moscow-Office/">https://www.zdnet.com/article/russian-police-raid-nginx-moscow-Office/</a></p><p><a href="http://baijiahao.baidu.com/s?id=1652792311899717676&amp;wfr=spider&amp;for=pc">http://baijiahao.baidu.com/s?id=1652792311899717676&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://www.zhihu.com/question/360737017/answer/934801767?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=56560353017856">https://www.zhihu.com/question/360737017/answer/934801767?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=56560353017856</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用用阿里云API实现DDNS</title>
      <link href="/2019/12/16/li-yong-yong-a-li-yun-api-shi-xian-ddns/"/>
      <url>/2019/12/16/li-yong-yong-a-li-yun-api-shi-xian-ddns/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前动态域名解析是用的是腾达路由器上集成的第三方动态解析服务花生壳，解析费用一年40元。后来觉得域名前缀不好，想换掉，花生壳需要重新购买新的域名解析费用，增加1条或者2条动态解析无所谓，万一以后增多了，那就不划算了。于是我决定用阿里云的动态解析api。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>1.有公网IP</p><p>2.主域名备案</p><h3 id="如何使用DDNS"><a href="#如何使用DDNS" class="headerlink" title="如何使用DDNS"></a>如何使用DDNS</h3><p>1.登录阿里云，获取 <code>AccessKeyId</code> 与<code>AccessKeySecret</code>；确定解析的域名例如我的域名是<code>cloud.lichongbing.com</code></p><p>2.为了节省时间和精力，直接把阿里云ddns的代码实例拷贝首先用IDEA编译器快速搭建springboot项目，把代码放到主程序里就行。确保您已经安装了Alibaba Cloud SDK for Java，准确的SDK版本号，请参见阿里云开发工具包（SDK）。<br>在pom.xml 如下</p><pre><code> &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;groupId&gt;com.lichongbing&lt;/groupId&gt;&lt;artifactId&gt;ddns&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;name&gt;ddns&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/com.aliyun/aliyun-java-sdk-core --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.aliyun&lt;/groupId&gt;        &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;        &lt;version&gt;4.4.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/com.aliyun/aliyun-java-sdk-alidns --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.aliyun&lt;/groupId&gt;        &lt;artifactId&gt;aliyun-java-sdk-alidns&lt;/artifactId&gt;        &lt;version&gt;2.0.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;</code></pre><p>构建springboot工程目录结构如下</p><pre><code>├── HELP.md├── dnns.iml├── mvnw├── mvnw.cmd├── pom.xml├── src│&nbsp;&nbsp; ├── main│&nbsp;&nbsp; │&nbsp;&nbsp; ├── java│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── com│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── lichongbing│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;         └── dnns│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;             └── DnnsApplication.java│&nbsp;&nbsp; │&nbsp;&nbsp; └── resources│&nbsp;&nbsp; │&nbsp;&nbsp;     └── application.properties│&nbsp;&nbsp; └── test│&nbsp;&nbsp;     └── java│&nbsp;&nbsp;         └── com│&nbsp;&nbsp;             └── lichongbing│&nbsp;&nbsp;                 └── dnns│&nbsp;&nbsp;                     └── DnnsApplicationTests.java└── target    ├── classes    │&nbsp;&nbsp; ├── application.properties    │&nbsp;&nbsp; └── com    │&nbsp;&nbsp;     └── lichongbing    │&nbsp;&nbsp;         └── dnns    │&nbsp;&nbsp;             └── DnnsApplication.class    ├── ddns-0.0.1.jar    ├── ddns-0.0.1.jar.original    ├── generated-sources    │&nbsp;&nbsp; └── annotations    ├── generated-test-sources    │&nbsp;&nbsp; └── test-annotations    ├── maven-archiver    │&nbsp;&nbsp; └── pom.properties    ├── maven-status    │&nbsp;&nbsp; └── maven-compiler-plugin    │&nbsp;&nbsp;     ├── compile    │&nbsp;&nbsp;     │&nbsp;&nbsp; └── default-compile    │&nbsp;&nbsp;     │&nbsp;&nbsp;     ├── createdFiles.lst    │&nbsp;&nbsp;     │&nbsp;&nbsp;     └── inputFiles.lst    │&nbsp;&nbsp;     └── testCompile    │&nbsp;&nbsp;         └── default-testCompile    │&nbsp;&nbsp;             ├── createdFiles.lst    │&nbsp;&nbsp;             └── inputFiles.lst    ├── surefire-reports    │&nbsp;&nbsp; ├── TEST-com.lichongbing.dnns.DnnsApplicationTests.xml    │&nbsp;&nbsp; └── com.lichongbing.dnns.DnnsApplicationTests.txt    └── test-classes        └── com            └── lichongbing                └── dnns                    └── DnnsApplicationTests.class</code></pre><p>本文操作示例主要以代码形式体现，具体代码如下其中四处提示你修改：</p><pre><code> import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.alidns.model.v20150109.DescribeDomainRecordsRequest; import com.aliyuncs.alidns.model.v20150109.DescribeDomainRecordsResponse; import com.aliyuncs.alidns.model.v20150109.UpdateDomainRecordRequest; import com.aliyuncs.alidns.model.v20150109.UpdateDomainRecordResponse; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.profile.DefaultProfile; import com.google.gson.Gson; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; /**  * 动态域名解析  */ public class DnnsApplication {/** * 获取主域名的所有解析记录列表 */private DescribeDomainRecordsResponse describeDomainRecords(DescribeDomainRecordsRequest           request, IAcsClient client){         try {             // 调用SDK发送请求             return client.getAcsResponse(request);         } catch (ClientException e) {             e.printStackTrace();             // 发生调用错误，抛出运行时异常             throw new RuntimeException();         }     }     /**      * 获取当前主机公网IP      */     private String getCurrentHostIP(){         // 这里使用jsonip.com第三方接口获取本地IP         String jsonip = "https://jsonip.com/";         // 接口返回结果         String result = "";         BufferedReader in = null;         try {             // 使用HttpURLConnection网络请求第三方接口             URL url = new URL(jsonip);             HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();             urlConnection.setRequestMethod("GET");             urlConnection.connect();             in = new BufferedReader(new InputStreamReader(                urlConnection.getInputStream()));                  String line;             while ((line = in.readLine()) != null) {            result += line;             }         } catch (Exception e) {             e.printStackTrace();         }         // 使用finally块来关闭输入流         finally {             try {                 if (in != null) {                     in.close();                 }             } catch (Exception e2) {                 e2.printStackTrace();             }         }         // 正则表达式，提取xxx.xxx.xxx.xxx，将IP地址从接口返回结果中提取出来         String rexp = "(\\d{1,3}\\.){3}\\d{1,3}";         Pattern pat = Pattern.compile(rexp);         Matcher mat = pat.matcher(result);         String res="";         while (mat.find()) {             res=mat.group();             break;         }         return res;     }     /**      * 修改解析记录      */     private UpdateDomainRecordResponse updateDomainRecord(UpdateDomainRecordRequest request, IAcsClient client){         try {        // 调用SDK发送请求             return client.getAcsResponse(request);         } catch (ClientException e) {             e.printStackTrace();             // 发生调用错误，抛出运行时异常             throw new RuntimeException();         }     }     private static void log_print(String functionName, Object result) {         Gson gson = new Gson();         System.out.println("-------------------------------" + functionName + "-------------------------------");         System.out.println(gson.toJson(result));     }     public static void main(String[] args) {         // 设置鉴权参数，初始化客户端         DefaultProfile profile = DefaultProfile.getProfile(                 "cn-chengdu",// 地域ID            "LTAI4Fq6g9sCiESU7y8h9fy3",// 修改成您的AccessKey ID                 "2Ap5cT4jucTub95HEw666eDWOSunh4");// 修改成您的AccessKey Secret         IAcsClient client = new DefaultAcsClient(profile);         DnnsApplication ddns = new DnnsApplication();         // 查询指定二级域名的最新解析记录         DescribeDomainRecordsRequest describeDomainRecordsRequest = new      DescribeDomainRecordsRequest();         // 主域名         describeDomainRecordsRequest.setDomainName("lichongbing.com");// 修改成您的主域名         // 主机记录         describeDomainRecordsRequest.setRRKeyWord("cloud");// 修改成您的域名前缀，没有就写@         // 解析记录类型         describeDomainRecordsRequest.setType("A");         DescribeDomainRecordsResponse describeDomainRecordsResponse =      ddns.describeDomainRecords(describeDomainRecordsRequest, client);         log_print("describeDomainRecords",describeDomainRecordsResponse);         List&lt;DescribeDomainRecordsResponse.Record&gt; domainRecords = describeDomainRecordsResponse.getDomainRecords();         // 最新的一条解析记录         if(domainRecords.size() != 0 ){             DescribeDomainRecordsResponse.Record record = domainRecords.get(0);             // 记录ID             String recordId = record.getRecordId();             // 记录值             String recordsValue = record.getValue();             // 当前主机公网IP                  String currentHostIP = ddns.getCurrentHostIP();             System.out.println("-------------------------------当前主机公网IP为："+currentHostIP+"-------------------------------");             if(!currentHostIP.equals(recordsValue)){                 // 修改解析记录                 UpdateDomainRecordRequest updateDomainRecordRequest = new UpdateDomainRecordRequest();                 // 主机记录                 updateDomainRecordRequest.setRR("cloud");                 // 记录ID                 updateDomainRecordRequest.setRecordId(recordId);                 // 将主机记录值改为当前主机IP                 updateDomainRecordRequest.setValue(currentHostIP);                 // 解析记录类型                 updateDomainRecordRequest.setType("A");                 UpdateDomainRecordResponse updateDomainRecordResponse = ddns.updateDomainRecord(updateDomainRecordRequest, client);                 log_print("updateDomainRecord",updateDomainRecordResponse);             }         }     } }</code></pre><p>运行结果</p><p>正确运行结果类似如下：</p><pre><code> -------------------------------describeDomainRecords------------------------------- {     "requestId": "6AE588B9-FAFA-45FE-8FBE-CACB196D3539",     "totalCount": 1,     "pageNumber": 1,     "pageSize": 20,     "domainRecords": [         {             "domainName": "lichongbing.com",             "recordId": "1846657850481xxxx",             "rR": "cloud",             "type": "A",             "value": "1.1.1.1",             "tTL": 600,             "line": "default",             "status": "ENABLE",             "locked": false,             "weight": 1         }     ] } -------------------------------当前主机公网IP为：123.123.123.123-------------------------------</code></pre><p>如果ip不一样就会动态解析</p><pre><code> -------------------------------updateDomainRecord------------------------------- {     "requestId": "08DC052F-7DF7-4451-8214-8489EC15D96A",     "recordId": "1846657850481xxxx" }</code></pre><p>最后打包发布到本地服务器上，编写启动脚本和定时命令。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac 定时去执行某shell脚本</title>
      <link href="/2019/12/16/mac-ding-shi-qu-zhi-xing-mou-shell-jiao-ben/"/>
      <url>/2019/12/16/mac-ding-shi-qu-zhi-xing-mou-shell-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>进入根目录</p><pre><code>cd／</code></pre><p>通过终端打开Finder的根目录</p><pre><code>open／touch test.shvim test.sh</code></pre><p>点击esc键，然后输:wq来保存退出</p><p>linux应该都有crontab，没有的话可以安装一下：</p><pre><code>brew install vixie-cronbrew install crontabs：</code></pre><p>vixie-cron软件包是cron的主程序；<br>crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用苹果的Schedule jobs using launchd设置定时任务。需要写一个plist文件，描述任务的动作、间隔的时间、日志输出等参数。</p><p>我创建一个plist文件com.hanlingzhi.cron.meican.plist，大概内容如下：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt;    &lt;key&gt;Disabled&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;KeepAlive&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;Label&lt;/key&gt;    &lt;string&gt;com.caoyujiao.crib.meican&lt;/string&gt;    &lt;key&gt;ProgramArguments&lt;/key&gt;    &lt;array&gt;        &lt;string&gt;/usr/bin/php&lt;/string&gt;        &lt;string&gt;/Users/caoyujiao/Desktop/IQIYI/tvOS/my.sh&lt;/string&gt;    &lt;/array&gt;    &lt;key&gt;RunAtLoad&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;StandardErrorPath&lt;/key&gt;    &lt;string&gt;/Users/caoyujiao/Desktop/IQIYI/tvOS/stderr&lt;/string&gt;    &lt;key&gt;StandardOutPath&lt;/key&gt;    &lt;string&gt;/Users/caoyujiao/Desktop/IQIYI/tvOS/stdout&lt;/string&gt;    &lt;key&gt;StartCalendarInterval&lt;/key&gt;    &lt;dict&gt;        &lt;key&gt;Hour&lt;/key&gt;        &lt;integer&gt;0&lt;/integer&gt;        &lt;key&gt;Minute&lt;/key&gt;        &lt;integer&gt;1&lt;/integer&gt;    &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;</code></pre><p>然后将plist文件放在/Users/hanlingzhi/Library/LaunchAgents，你的用户目录下，然后执行<code>launchctl load plist</code>就可以启动了。</p><pre><code>launchctl load -w com.caoyujiao.crib.meican.plist 加载launchctl unload -w com.caoyujiao.crib.meican.plist 卸载</code></pre><p>加载后，终端文案会在stdout文件中显示<br>错误信息显示在stderr文件里面<br>plist脚本存放路径为<code>/Library/LaunchDaemons</code>或用户目录<code>/Library/LaunchAgents</code>，其区别是后一个路径的脚本当用户登陆系统后才会被执行，前一个只要系统启动了，哪怕用户不登陆系统也会被执行。</p><p>系统定义了几个位置来存放任务列表</p><p><code>~/Library/LaunchAgents</code> 由用户自己定义的任务项</p><p><code>/Library/LaunchAgents</code> 由管理员为用户定义的任务项</p><p><code>/Library/LaunchDaemons</code> 由管理员定义的守护进程任务项</p><p><code>/System/Library/LaunchAgents</code> 由Mac OS X为用户定义的任务项</p><p><code>/System/Library/LaunchDaemons</code> 由Mac OS X定义的守护进程任务项</p><p>可以通过两种方式来设置脚本的执行时间。一个是使用<code>StartInterval</code>，它指定脚本每间隔多长时间（单位：秒）执行一次；另外一个使用<code>StartCalendarInterval</code>，它可以指定脚本在多少分钟、小时、天、星期几、月时间上执行，类似如crontab的中的设置。</p><p>launchctl的命令使用大家看一下帮助文档。</p><p>由于操作还是比较复杂，为了帮助快速执行，写了个shell快速拷贝新的plist并完成服务重启</p><p>总结一下</p><p>虽然plist的设置会复杂很多。但是当前在mac os还是倾向于推荐使用Plist的方法，crontab已不推荐使用。<br>两者的区别：</p><p>1、plist可以设置到秒，而crontab只能到分钟。</p><p>2、plist可以同时应用于Mac OS/Iphone。</p><p>3、plist对于MAC上系统交互的操作更支持(我就出现过用crontab设置，运行时出现execution error: 不允许用户交互。 (-1713)的错误)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04系统中不能ssh外网远程</title>
      <link href="/2019/12/15/ubuntu-18-04-xi-tong-zhong-bu-neng-ssh-wai-wang-yuan-cheng/"/>
      <url>/2019/12/15/ubuntu-18-04-xi-tong-zhong-bu-neng-ssh-wai-wang-yuan-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我不小心动了电插板，导致服务器断电，用远程命令开机，居然很长时间没反应，索性就亲自按电源键重启。服务器正常开机启动，ssh可以内网访问，远程命令内网有效果，就是外网不行。经过分析排查，是不是服务器开启防火墙，导致外网不能访问，继续排查路由器是不是映射出现问题，经过最后排除是ssh出现问题。</p><h2 id="在Ubuntu-18-04系统中不能ssh远程"><a href="#在Ubuntu-18-04系统中不能ssh远程" class="headerlink" title="在Ubuntu 18.04系统中不能ssh远程"></a>在Ubuntu 18.04系统中不能ssh远程</h2><p>Ubuntu默认安装了openssh-client，没有安装openssh-server,因此想远程SSH登陆Ubuntu，需要先在Ubuntu上安装openssh-server。</p><p>1.命令行输入：</p><pre><code>lcbroot@lichongbing:~$ ps -e|grep ssh 4343 ?        00:00:00 sshd 5057 ?        00:00:00 sshd 5179 ?        00:00:00 sshd</code></pre><p>2.输入以下命令安装OpenSSH服务：</p><pre><code>lcbroot@lichongbing:~$ sudo apt-get install openssh-server</code></pre><p>3.修改“ /etc/ssh/sshd_config”:</p><pre><code>lcbroot@lichongbing:~$ sudo vim /etc/ssh/sshd_config</code></pre><p>添加PermitRootLogin yes （默认为#PermitRootLogin prohibit-password）<br>4.重启SSH:</p><pre><code>lcbroot@lichongbing:~$ sudo service ssh restart</code></pre><p>5.有ssh服务启动后，即可登陆，登陆命令格式为：ssh username@IP， 外网可以访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频2</title>
      <link href="/2019/12/15/shi-pin-2/"/>
      <url>/2019/12/15/shi-pin-2/</url>
      
        <content type="html"><![CDATA[<iframe src="http://image.lichongbing.com/static/%E9%83%AB%E5%8E%BF%E7%99%BE%E4%BC%A6%E7%88%B1%E8%BE%BE%E4%B9%90%E8%9B%8B%E7%B3%95%E5%BA%972017%E5%B9%B44%E6%9C%88.mp4" frameborder="0" scrolling="no" width="760" height="428" allowfullscreen=""> </iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS的区别</title>
      <link href="/2019/12/12/http-yu-https-de-qu-bie/"/>
      <url>/2019/12/12/http-yu-https-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>一、HTTP和HTTPS的基本概念</p><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>二、HTTP与HTTPS有什么区别？</p><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p>三、HTTPS的工作原理</p><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。<br><img src="https://image.lichongbing.com/static/75c170ad0732f840c093bcd2fb703f4b.jpg" alt="1-150H120343I41.jpg"></p><p>HTTP与HTTPS的区别-马海祥博客</p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>（6）Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="https://image.lichongbing.com/static/c874a75de6049c8d3e22ef70dfdbbd9b.gif" alt="2012071410212142.gif"></p><p>四、HTTPS的优点</p><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><p>五、HTTPS的缺点</p><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><p>六、http切换到HTTPS</p><p>如果需要将网站从http切换到https到底该如何实现呢？</p><pre><code> 这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com</code></pre><p>BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84%E3%80%82">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp协议详解-滑动窗口</title>
      <link href="/2019/12/11/tcp-xie-yi-xiang-jie-hua-dong-chuang-kou/"/>
      <url>/2019/12/11/tcp-xie-yi-xiang-jie-hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<p>TCP协议作为基本的传输控制协议，提供了面向连接的、可靠的通信机制。由于其优越的特性，被广泛应用于网络通信中，成为了今天互联网的基石。其为了屏蔽网络底层种种复杂的因素做出了巨大的努力,同时也导致了TCP内部各种机制之间的相互作用,让初接触它的人们很难理清头绪。本文就从TCP的传输窗口这个点切入，带领大家一睹TCP实现机制的风采。<br>2. TCP窗口</p><p>TCP发送窗口由slide_window（滑动窗口）、congestion_window（拥塞窗口）两者决定，代码如下（4.4BSD-Lite2）：</p><pre><code>  #已发送未确认的字节数=下一个发送序号-最早的未确认序号  off = tp-&gt;snd_nxt - tp-&gt;snd_una;   #发送窗口为min(当前发送窗口,拥塞窗口)    win = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd);      ...  #发送长度=发送窗口-已发送未确认字节数  len = min(so-&gt;so_snd.sb_cc, win) - off;</code></pre><p>2.1 滑动窗口</p><p>上面的snd_wnd、snd_una、snd_nxt三个字段组成了滑动窗口。 如下图所示：<br><img src="https://image.lichongbing.com/static/26649e5da9909107782cb15cc3bab96b.jpeg" alt="140518_Jgf4_990211.png.jpeg"></p><p>2.2 发送端滑动窗口</p><p>发送端窗口随时间滑动图（不考虑重传）例如下所示：<br><img src="https://image.lichongbing.com/static/9ba38aca6ff33aa21f54a86172904598.png" alt="140708_XDkc_990211.png"></p><p>(1）我们一共需要发送900字节数据。可发送数据为1-500字节，尚未发送数据。假设首先发送400字节的数据。</p><p>（2）发送了400字节后，对端返回一个ack表示收到200序号之内的数据且窗口通告为500。于是如图示，窗口向前滑动了200字节。当前已发送未确认字节序号为200-400,可发送字节序号为401-700,假设在此尚未发送数据。</p><p>（3）对端返回一个ack表示收到400序号内的数据且窗口通告为400。于是如图示，窗口向前滑动了200字节。已确认数据序号为1-400，可发送数据为401-800。<br>2.3 接收端窗口通告</p><p>snd_wnd此字段主要由接收端的窗口通告决定，接收端窗口通告由当前接收端剩余多少空闲的剩余缓存决定。如下图所示：<br><img src="https://image.lichongbing.com/static/1dac3526be629241def321289f06530b.png" alt="140751_xWZF_990211.png"><br>（1）发送端：写入2KB的数据[seq=0]。<br>（2）接收端：收到数据,初始化接收端缓冲区4K,写入后还剩2K,于是通告ack[seq=2048,win=2048]。<br>（3）发送端：接收到窗口通告为2048,于是最多只能写入2K的数据，将2K数据写入[seq=2048]。<br>（4）接收端：应用层尚未消费缓冲区。接收到2K数据后，缓冲区满。于是通告窗口为0,返回ack[seq=4096,win=0]。<br>（5）发送端：由于发送窗口为0，不能发送任何数据。此时发送端就需要定时的发送1字节的数据去探测接收端窗口。所需的定时器即为持续定时器（TCPT_PERSIST）。<br>（6）发送端：发送0字节的探测数据。<br>（7）接收端：缓冲区满,窗口通告为0,ack[seq=4096,win=0]。<br>（8）发送端：继续发送0字节的探测数据。<br>（9）接收端：缓冲区被应用层消费了2K,缓冲区可用字节为2K,通告窗口为2048,ack[seq=4096,win=2048]。<br>（10）发送端：继续写入1K的数据。</p><p>2.4 拥塞窗口<br>TCP用拥塞窗口（cwnd）来进行拥塞控制，主要利用了慢启动、拥塞避免、快速重传和快速恢复这四个算法。</p><p>2.4.1 慢启动和拥塞避免</p><p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。慢启动的目的是:防止一开始速率过快，导致耗尽中间路由器存储空间，从而严重降低TCP连接的吞吐量。拥塞避免的目的是:当拥塞发生时，降低网络的传输速率。这可以通过调用慢启动的动作来降低网络的传输速率。所以在实际中这两个算法通常在一起实现。<br>下述代码描述的是慢启动的过程（4.4BSD-Lite2）。</p><pre><code>     {     u_int win = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd) / 2 / tp-&gt;t_maxseg;      if (win &lt; 2)     win = 2;     tp-&gt;snd_cwnd = tp-&gt;t_maxseg;     tp-&gt;snd_ssthresh = win * tp-&gt;t_maxseg;     tp-&gt;t_dupacks = 0;     }</code></pre><p>其将win置为现有窗口的大小,同时慢启动门限tp-&gt;snd_ssthresh设置为现有窗口大小的一半。snd_cwnd（拥塞窗口）被设定为只能容纳一个报文t_maxseg)，这样就强迫TCP执行慢启动。之后拥塞窗口会先以指数形式增长，达到慢启动门限snd_ssthressh之后,再线性增长。<br>线性增长的过程即是拥塞避免算法。<br>此过程如以下代码注释所示（4.4BSD-Lite2）：</p><pre><code>    /*    * When new data is acked, open the congestion window.    * If the window gives us less than ssthresh packets    * in flight, open exponentially (maxseg per packet).    * Otherwise open linearly: maxseg per window    * (maxseg * (maxseg / cwnd) per packet).    */    {     register u_int cw = tp-&gt;snd_cwnd;     register u_int incr = tp-&gt;t_maxseg;     if (cw &gt; tp-&gt;snd_ssthresh)      incr = incr * incr / cw;      tp-&gt;snd_cwnd = min(cw + incr, TCP_MAXWIN&lt;&lt;tp-&gt;snd_scale);    }</code></pre><p>慢启动图例</p><p><img src="https://image.lichongbing.com/static/0c868f962bfca16830631f55f4087462.png" alt="140900_h1Ea_990211.png"><br>图中Cwnd指数增长的阶段,即从1到ssthresh时间段是过程是慢启动。<br>图中Cwnd线性增长的阶段,即从ssthresh到max的时间段是拥塞避免的过程。<br>值得注意的是，TCP连接刚建立时刻也会有慢启动的过程。如果用的是短连接(即发送一个请求之后即抛弃此连接)且发送数据较少的话，大部分时间都耗在了慢启动上面，并没有充分的利用带宽。再加上建立连接所需要三次握手的消耗,导致短连接的效率要远低于长连接。</p><p>2.4.2 快速重传和快速恢复</p><p>快速重传和快速恢复算法各自独立，但一般都在一起实现。</p><p>快速重传：在接收到相同ACK后，推断出丢失报文段起始序号，然后立即重传此报文<br>快速恢复：在快速重传的基础上，如果发生了快速重传，则执行拥塞避免算法而非慢启动。<br>快速重传和快速恢复图例：</p><p><img src="https://image.lichongbing.com/static/b9958c4a3b1495a3134fb9c649f5b2f6.jpeg" alt="140929_VRch_990211.png.jpeg"><br>从上图中我们可以看到，快速恢复的时候tcp窗口仅仅降低到ssthresh而后线性增加，即只进行了拥塞避免算法。</p><p>2.5 TCP粘包<br>经过上述讨论，可知TCP窗口的大小取决于当前的网络状况、对端的缓冲大小等等因素，TCP将这些都从底层屏蔽。开发者无法从应用层获取这些信息。这就意味着，当你在接收TCP数据流的时候无法知道当前接收了有多少数据流，数据可能在任意一个比特位（seq）上。这就是所谓的”粘包”问题。开发者必须小心的组织帧格式来解决”粘包”。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂TCP与UDP的区别</title>
      <link href="/2019/12/11/yi-wen-gao-dong-tcp-yu-udp-de-qu-bie/"/>
      <url>/2019/12/11/yi-wen-gao-dong-tcp-yu-udp-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>摘要：计算机网络基础<br><img src="https://image.lichongbing.com/static/dde44b3adf2705384be3c854c3e02a13.jpg" alt="1105508-20190322093746970-682324622.jpg"></p><p>引言</p><p>网络协议是每个前端工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p><p>一、TCP/IP网络模型</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。<br>网络层：负责路由以及把分组报文发送给目标网络或主机。<br>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。<br>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。<br><img src="https://image.lichongbing.com/static/3f5d995ceef7bd19796d5b3b5c746643.png" alt="2019-03-21-01.png"></p><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><p>二、UDP</p><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它有以下几个特点：</p><ol><li>面向无连接</li></ol><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><p>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作<br>2. 有单播，多播，广播的功能</p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><ol start="3"><li>UDP是面向报文的</li></ol><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><ol start="4"><li>不可靠性</li></ol><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<br><img src="https://image.lichongbing.com/static/8bb7a0bb387ea1408ae01deeb3fcdd7f.png" alt="截屏2019-12-1111.00.49.png"></p><p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><ol start="5"><li>头部开销小，传输数据报文时是很高效的。<br><img src="https://image.lichongbing.com/static/dab04ae9fdd2512583e89a45333935ec.png" alt="2019-03-21-03.png"></li></ol><p>UDP 头部包含了以下几个数据：</p><p>两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>整个数据报文的长度<br>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><p>三、TCP</p><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><ol><li>TCP连接过程</li></ol><p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:</p><p><img src="https://image.lichongbing.com/static/413b2097337a2ec95e7cc210dadfcc80.png" alt="2019-03-21-04.png"></p><p>第一次握手</p><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p><p>第二次握手</p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p>第三次握手</p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。<br><img src="https://image.lichongbing.com/static/0bcc9a7b4e52fd690da756b173d576a1.png" alt="截屏2019-12-1111.02.50.png"></p><ol start="2"><li>TCP断开链接</li></ol><p><img src="https://image.lichongbing.com/static/feb927113def1b587a45bddb34641cc9.png" alt="2019-03-21-06.png"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><p>第一次握手</p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p>第二次握手</p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p><p>第三次握手</p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p>第四次握手</p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><ol start="3"><li>TCP协议的特点</li></ol><p>面向连接</p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><p>仅支持单播传输</p><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p>面向字节流<br>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><p>可靠传输</p><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><p>提供拥塞控制</p><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><p>TCP提供全双工通信<br>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><p>四、TCP和UDP的比较</p><ol><li><p>对比</p><pre><code>                     UDP                            TCP     是否连接          无连接                      面向连接     是否可靠    不可靠传输，不使用流量控制和拥塞控制    可靠传输，使用流量控制和拥塞控制     连接对象个数    支持一对一，一对多，多对一和多对多交互通信    只能是一对一通信     传输方式    面向报文    面向字节流     首部开销    首部开销小，仅8字节    首部最小20字节，最大60字节     适用场景    适用于实时应用（IP电话、视频会议、直播等）    适用于要求可靠传输的应用，例如文件传输</code></pre></li><li><p>总结</p></li></ol><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CP的三次握手与四次挥手理解及面试题（很全面）</title>
      <link href="/2019/12/11/cp-de-san-ci-wo-shou-yu-si-ci-hui-shou-li-jie-ji-mian-shi-ti-hen-quan-mian/"/>
      <url>/2019/12/11/cp-de-san-ci-wo-shou-yu-si-ci-hui-shou-li-jie-ji-mian-shi-ti-hen-quan-mian/</url>
      
        <content type="html"><![CDATA[<p>本文经过借鉴书籍资料、他人博客总结出的知识点，欢迎提问<br><img src="http://image.lichongbing.com/static/21cec9d61122a391c311c49b8049af17.jpeg" alt="20180717201939345.jpeg"></p><p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；<br>给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p><p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认<br>号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p><p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p><p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，<br>ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被<br>置1，握手完成后SYN标志位被置0。</p><p>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p><p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p><p>。。。。。</p><pre><code>字段    含义URG    紧急指针是否有效。为1，表示某一位需要被优先处理ACK    确认号是否有效，一般置为1。PSH    提示接收端应用程序立即从TCP缓冲区把数据读走。RST    对方要求重新建立连接，复位。SYN    请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1FIN&nbsp;&nbsp; &nbsp;    希望断开连接。</code></pre><p>三次握手过程理解<br><img src="http://image.lichongbing.com/static/58e86d3db57fe355d4f320e938b31027.png" alt="20180717202520531.png"></p><p>&nbsp;</p><p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p>四次挥手过程理解<br><img src="http://image.lichongbing.com/static/70262048464052fa72aa624e53c30532.png" alt="20180717204202563.png"></p><p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p>常见面试题</p><p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>【问题3】为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>————————————————<br>版权声明：本文为CSDN博主「青柚_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_38950316/article/details/81087809">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI七层模型</title>
      <link href="/2019/12/11/osi-qi-ceng-mo-xing/"/>
      <url>/2019/12/11/osi-qi-ceng-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>OSI七层模型</p><p><img src="http://image.lichongbing.com/static/0eb5e548e2321e789db12555b55dcc59.gif" alt="1099668-20170212153338135-125492424.jpg.gif"><br><img src="http://image.lichongbing.com/static/ccc5d1677299c9d248f896a2831200a8.png" alt="截屏2019-12-1110.31.23.png"><br><img src="http://image.lichongbing.com/static/a2290e0c5da5574b99224baf2b4fec9a.png" alt="截屏2019-12-1110.31.54.png"><br><img src="http://image.lichongbing.com/static/7300a98c6da43d7cea246751b273c61b.png" alt="截屏2019-12-1110.32.44.png"></p><pre><code>相关协议         缩写</code></pre><p>应用层</p><pre><code>HTTP 超文本传输协议FTP 文件传输协议SMTP 简单邮件传输协议TELNET TCP/IP终端仿真协议POP3 邮局协议第三版Finger 用户信息协议NNTP 网络新闻传输协议IMAP4 因特网信息访问协议第四版LPR UNIX 远程打印协议Rwho UNIX 远程 Who协议Rexec UNIX远程执行协议Login UNIX 远程登陆协议RSH UNIX 远程Shell协议NTF HP网络文件传输协议RDA HP 远程数据库访问协议VT 虚拟终端仿真协议RFA HP 远程文件访问协议RPC Remote Process Comm.S-HTTP 安全超文本传输协议GDP网关发现协议X-WindowCMOT 基于TCP/IP的CMIP协议SOCKS 安全套接字协议FANP流属性通知协议SLP服务定位协议MSN微软网络服务Radius 远程用户拨号认证服务协议DNS 域名系统NFS网络文件系统协议NIS SUN 网络信息系统协议R-STAT SUN远程状态协议NSM SUN 网络状态监测协议PMAP SUN 端口映射协议MountLPR UNIX远程打印协议</code></pre><p>常用UDP协议的应用层服务</p><pre><code>BOOTP引导协议DHCP动态主机配套协议NTP网络时间协议TFTP简单文件传输协议SNMP简单网络管理协议</code></pre><p>表示层</p><pre><code>DECnet NSPLPP 轻量级表示协议NBSSN NetBIOS会话服务协议XDP外部数据表示协议IPX</code></pre><p>会话层</p><pre><code>SSL 安全套接字层协议TLS传输层安全协议DAP目录访问协议LDAP轻量级目录访问协议RPC远程过程调用协议VINES NETRPCVFRPNeTBIOSIPX</code></pre><p>传输层</p><pre><code>XOT 基于tcp之上的X协议Van Jacobson 压缩TCP协议ISO-DE ISO 开发环境--------&gt;NetBISOTALI 传输适配层接口协议DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPCUDP用户数据报协议RUDP可靠的用户数据报协议Mobile IP 移动IP协议</code></pre><p>网络层</p><pre><code>IP/IPv6 互联网协议/互联网协议第六版ICMPv6互联网控制信息协议第六版ICMP互联网控制信息协议IGMP 互联网组管理协议SLIP 串行线路IP协议</code></pre><p>安全协议</p><pre><code>AH 认证头协议ESP 安装封装有效载荷协议</code></pre><p>路由协议</p><pre><code>EGP 外部网关协议OSPF 开放最短路径优先协议IGRP 内部网关路由协议NHRP 下一跳解析协议IE-IRGP 增强内部网关路由选择协议RIPng for IPv6 IPv6路由信息协议</code></pre><p>GGP 网关到网关协议</p><pre><code>VRRP 虚拟路由器冗余协议PGM 实际通用组播协议RSVP 资源预留协议PIM-DM 密集模式独立组播协议DVMRP 距离矢量组播路由协议RIP2 路由信息协议第二版PIM-SM 稀疏模式独立组播协议MOSPF 组播开放最短路径优先协议</code></pre><p>数据链路层</p><pre><code>MPLS 多协议标签交换协议XTP 压缩传输协议DCAP 数据转换客户访问协议SLE 串行连接封装协议IPinIP IP套IP封装协议隧道协议PPTP点对点隧道协议L2F第二层转发协议L2TP 第二层隧道协议ATMP接入隧道管理协议Cisco 协议CDP 思科发现协议CGMP 思科组管理协议地址解析协议ARP地址解析协议RAR逆向地址解析协议</code></pre><p>物理层</p><pre><code>IEEE 802.2Ethernet v.2Internetwork</code></pre><p>完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。</p><p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br>具体说:<br>物理层：网卡，网线，集线器，中继器，调制解调器</p><p>数据链路层：网桥，交换机</p><p>网络层：路由器</p><p>网关工作在第四层传输层及其以上</p><p>集线器是物理层设备,采用广播的形式来传输信息。</p><p>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。</p><p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。</p><p>交换机和路由器的区别</p><p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。<br>使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。<br>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。<br>总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p><p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p><p>集线器与路由器在功能上有什么不同?</p><p>首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。</p><p>总的来说，路由器与交换机的主要区别体现在以下几个方面：</p><p>（1）工作层次不同<br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</p><p>（2）数据转发所依据的对象不同<br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p><p>（3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域<br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。</p><p>（4）路由器提供了防火墙的服务<br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p><p>物理层<br>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。<br>物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>数据链路层<br>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。<br>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><p>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；</p><p>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。<br>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><p>网络层<br>网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。</p><p>在实现网络层功能时，需要解决的主要问题如下：<br>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。<br>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。<br>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。<br>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</p><p>传输层<br>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。<br>该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。<br>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：<br>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。<br>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。<br>监控服务质量。<br>会话层<br>会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br>用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：<a href="http://www.3721.com就是一个域名。会话层的具体功能如下：">www.3721.com就是一个域名。会话层的具体功能如下：</a><br>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。<br>会话流量控制：提供会话流量控制和交叉会话功能。<br>寻址：使用远程地址建立会话连接。l<br>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。<br>表示层<br>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：<br>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。<br>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。<br>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。<br>数据的加密和解密：可以提高网络的安全性。</p><p>应用层<br>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：<br>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。<br>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</p><p>OSI7层模型的小结<br>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。<br>以下是TCP/IP分层模型<br><img src="http://image.lichongbing.com/static/1fcb2d579a8a6aec8e7b222aa8505474.png" alt="20190105165022790.png"><br><img src="http://image.lichongbing.com/static/2d58d3beaa124ab15d404933b69eb7fd.png" alt="20190105165116628.png"><br><img src="http://image.lichongbing.com/static/cbb3ab66ef3eb22a33b68ae51c70ae0d.png" alt="20190105165204409.png"><br>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。</p><p>TCP/IP分层模型的四个协议层分别完成以下的功能：</p><p>第一层:网络接口层</p><p>包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p><p>第二层:网间层</p><p>对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p><p>第三层:传输层</p><p>对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p><p>第四层:应用层</p><p>对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等，这也是本书将要讨论的重点。<br>————————————————<br>版权声明：本文为CSDN博主「Five-菜鸟级」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_41923622/article/details/85805003">https://blog.csdn.net/qq_41923622/article/details/85805003</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>慕课网剑指offer面试题</title>
      <link href="/2019/12/10/mu-ke-wang-jian-zhi-offer-mian-shi-ti/"/>
      <url>/2019/12/10/mu-ke-wang-jian-zhi-offer-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>我在慕课网买的教程，整理出来。</p><p>1.赋值运算函数</p><p>思路:</p><ul><li>将返回值类型声明为该类型的引用</li><li>把传入的参数类型声明为常量引用 释放实例自身已有的内存</li><li>判断传入的参数和当前的实例是不是同一个实例</li></ul><p>2.单例设计模式<br>思路:</p><ul><li>静态内部类</li></ul><p>3.在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完 成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路:</p><ul><li>从右上角或左下角开始找，逐行删除，或者用二分法查找</li></ul><p>代码实现:</p><pre><code>public boolean find(int[][] array,int target) { if (array == null) {      return false;  }int row = 0;int column = array[0].length-1;while (row &lt; array.length &amp;&amp; column &gt;= 0) { if(array[row][column] == target) {          return true;      }if(array[row][column] &gt; target) { column--;      } else {          row++;} }  return false;}</code></pre><p>4.将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>思路:</p><ul><li>从后往前复制，数组长度会增加，或使用StringBuilder、StringBuffer类</li></ul><p>代码实现:</p><pre><code>public String replaceSpace(StringBuffer str) { if (str == null)return null;StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; str.length(); i++) {if (String.valueOf(str.charAt(i)).equals(" ")) {sb.append("%20"); }else {sb.append(str.charAt(i)); }}return String.valueOf(sb); }</code></pre><p>5.输入一个链表，从尾到头打印链表每个节点的值。</p><p>思路:</p><ul><li>借助栈实现，或使用递归的方法。</li></ul><p>代码实现:</p><pre><code>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (listNode == null)      return list;      Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();       while (listNode != null) {      stack.push(listNode);       listNode = listNode.next; }      while (!stack.isEmpty()) {       list.add(stack.pop().val);      }     return list;     }</code></pre><p>6.输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中 都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并 返回。</p><p>思路:</p><ul><li>先找出根节点，然后利用递归方法构造二叉树</li></ul><p>代码实现:</p><pre><code> static class TreeNode {   int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } public TreeNode reConstructBinaryTree(int [] pre,int [] in) { if (pre == null || in == null) { return null; } if (pre.length == 0 || in.length == 0) { return null; }  if (pre.length != in.length) {      return null;  } TreeNode root = new TreeNode(pre[0]); for (int i = 0; i &lt; pre.length; i++) { if (pre[0] == in[i]) { root.left = reConstructBinaryTree( Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i)); root.right = reConstructBinaryTree( Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); } }  return root; }</code></pre><p>7.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路:</p><ul><li>一个栈压入元素，而另一个栈作为缓冲，将栈1的元素出栈后压入栈2中。也可以将栈1中的最后一个元<br>素直接出栈，而不用压入栈2中再出栈。</li></ul><p>代码实现:</p><pre><code> public void push(int node) { stack1.push(node);  } public int pop() throws Exception { if (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) { throw new Exception("栈为空!"); } if (stack2.isEmpty()) { while(!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.pop(); }</code></pre><p>8.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一 个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE:给出的所有元素都大于0，若数组大小为0，请返回0</p><p>思路:</p><ul><li>利用二分法，找到中间的数，然后和最左边的值进行比较，若大于最左边的数，则最左边从mid开始， 若小于最右边值，则最右边从mid开始。若左中右三值相等，则取mid前后值中较小的数。</li></ul><p>代码实现:</p><pre><code> public int minNumberInRotateArray(int [] array) { if (array == null || array.length == 0) return 0; int left = 0; int right = array.length - 1; int mid = 0; while (array[left] &gt;= array[right]) { if(right - left &lt;= 1) { mid = right; break; } mid = (left + right)/2; if (array[left] == array[mid] &amp;&amp; array[mid] == array[right]) { if (array[left+1] != array[right-1]) { mid = array[left+1] &lt; array[right-1] ? left+1:right-1;          } else {            left++; right--; } } else { if (array[left] &lt;= array[mid]) { left = mid; } else { right = mid; } } }  return array[mid]; }</code></pre><p>9.1现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p><p>思路:</p><ul><li>递归的效率低，使用循环方式。</li></ul><p>代码实现:</p><pre><code>public long fibonacci(int n) { long result=0;long preOne=1; long preTwo=0; if(n==0) {      return preTwo;  }if(n==1) {return preOne;preOne = result; }  return result; }</code></pre><p>9.2.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>9.2代码与9.1相同</p><p>9.3我们可以用21 矩形，n 21的小矩形无重叠地覆盖一个2*n的大总共有多少种方法?</p><p>思路:</p><ul><li>斐波那契数列思想</li></ul><p>代码实现:</p><pre><code>public int Fibonaccik(int n) { int number = 1;  int sum = 1; if (n &lt;= 0)  return 0; if (n == 1 ) {  return 1; }  while (n-- &gt;= 2) { sum += number;  number = sum - number; }  return sum;   }</code></pre><p>9.4一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共 有多少种跳法。</p><p>思路:</p><ul><li>2^(n-1)</li></ul><p>代码实现:</p><pre><code>public int JumpFloor2(int target) {     return (int) Math.pow(2,target-1);}</code></pre><p>10.输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>思路:</p><ul><li>a&amp;(a-1)的结果会将a最右边的1变为0，直到a = 0，还可以先将a&amp;1 != 0，然后右移1位，但不能计算负<br>数的值，</li></ul><p>代码实现:</p><pre><code>public int NumberOf1(int n) {int count = 0;while (n != 0) { count++;n = (n-1) &amp; n; }  return count;}</code></pre><p>11.给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。不得使用库函数， 不需要考虑大数问题</p><p>思路:</p><ul><li>不能用==比较两个浮点数是否相等，因为有误差。考虑输入值的多种情况。</li></ul><p>代码实现:</p><pre><code>  public double Power(double base, int exponent) {   double res = 0;  if (equal(base,0)) {      return 0;   }  if (exponent == 0) {  return 1.0; }  if (exponent &gt; 0) {  res = mutiply(base,exponent);  }else {  res = mutiply(1/base,-exponent);   }  return res; }  public double mutiply(double base, int e) { double sum = 1;  for (int i = 0; i &lt; e; i++) { sum = sum * base;  } return sum; } public boolean equal(double a, double b) { if (a - b &lt; 0.000001 &amp;&amp; a - b &gt; -0.000001) {      return true;  }  return false;  }</code></pre><p>12.打印1到最大的n位数</p><p>思路:</p><ul><li>考虑大数问题，使用字符串或数组表示。</li></ul><p>代码实现:</p><pre><code> public void printToMaxOfNDigits(int n) { int[] array=new int[n]; if(n &lt;= 0)      return;  printArray(array, 0);  } private void printArray(int[] array,int n) {  for(int i = 0; i &lt; 10; i++) { if(n != array.length) { array[n] = i;          printArray(array, n+1);      } else {  boolean isFirstNo0 = false;  for(int j = 0; j &lt; array.length; j++) {  if(array[j] != 0) {   System.out.print(array[j]); if(!isFirstNo0)   isFirstNo0 = true; } else {  if(isFirstNo0) System.out.print(array[j]);  } } System.out.println(); return ; }  } }</code></pre><p>13.O(1)时间删除链表节点</p><p>思路:</p><ul><li>将要删除节点的下一个节点的值赋给要删除的节点，然后指向下下一个节点</li></ul><p>代码实现:</p><pre><code> public void deleteNode(ListNode head, ListNode deListNode) {  if (deListNode == null || head == null) return; if (head == deListNode) { head = null; } else { // 若删除节点是末尾节点，往后移一个 if (deListNode.nextNode == null) { ListNode pointListNode = head; while (pointListNode.nextNode.nextNode != null) { pointListNode = pointListNode.nextNode; } pointListNode.nextNode = null; } else { deListNode.data = deListNode.nextNode.data;deListNode.nextNode = deListNode.nextNode.nextNode; }} }</code></pre><p>14.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所 有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</p><p>思路:</p><ul><li>每次只和前面一个数交换位置。或者利用辅助数组</li></ul><p>代码实现:</p><pre><code> public void reOrderArray(int [] array) {  if(array == null) return ; for(int i = 1; i &lt; array.length; i++){  int temp = array[i]; int j = i - 1;  if(array[i] % 2 != 0){ while(j &gt;= 0){ if(array[j] % 2 != 0){ break; } if(array[j]%2 == 0){  int t = array[j+1];  array[j+1] = array[j];   array[j] = t; j--;  } }  }   array[j+1] = temp; } }</code></pre><p>15.输入一个链表，输出该链表中倒数第k个结点。 扩展题:找中间节点，使用两个指针，一个走一步，一个走两步。找到中间节点</p><p>思路:</p><ul><li>定义一快一慢两个指针，快指针走K步，然后慢指针开始走，快指针到尾时，慢指针就找到了倒数第K个 节点。</li></ul><p>代码实现:</p><pre><code>public ListNode FindKthToTail(ListNode head,int k) { if (head == null || k &lt;= 0) {      return null;  }ListNode fast = head; ListNode slow = head;while(k-- &gt; 1) {if (fast.next != null)fast = fast.next; elsereturn null;}while (fast.next != null) {fast = fast.next;slow = slow.next; }  return slow;}</code></pre><p>16.输入一个链表，反转链表后，输出链表的所有元素。 扩展题:输出反转后链表的头节点，定义三个指针反向输出。</p><p>思路:</p><ul><li>定义两个指针，反向输出</li></ul><p>代码实现:</p><pre><code>public ListNode ReverseList(ListNode head) { if (head == null) {      return null;  }ListNode temp = null; while(head != null) {ListNode p = head.next; head.next = temp;temp = head;head = p;}  return temp; }</code></pre><p>17.输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>思路:</p><ul><li>递归与非递归求解，小数放在前面。</li></ul><p>代码实现:</p><pre><code>public ListNode Merge(ListNode list1,ListNode list2) { if (list1 == null) {      return list2;  }if (list2 == null) { return list1;}ListNode newHead = null;if (list1.val &lt;= list2.val) {newHead = list1;newHead.next = Merge(list1.next,list2) }else {newHead = list2;newHead.next = Merge(list1,list2.next); }  return newHead;  }</code></pre><p>18.输入两棵二叉树A，B，判断B是不是A的子结构。(ps:我们约定空树不是任意一个树的子结构)</p><p>思路:</p><ul><li>若根节点相等，利用递归比较他们的子树是否相等，若根节点不相等，则利用递归分别在左右子树中查<br>找。</li></ul><p>代码实现:</p><pre><code>public boolean HasSubtree(TreeNode root1,TreeNode root2) { boolean result = false;if (root2 != null &amp;&amp; root1 != null) { if(root1.val == root2.val){result = doesTree1HaveTree2(root1,root2); }if (!result)return HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2);}  return result;}public boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) { if (node2 == null) {      return true;  }if (node1 == null) { return false;}if (node1.val != node2.val) {      return false;  }return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right); }</code></pre><p>19.操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>思路:</p><ul><li>使用递归或非递归方式交换每个节点的左右子树位置。</li></ul><p>代码实现:</p><pre><code>public void Mirror(TreeNode root) { if (root == null) {return; }Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();while (root != null || !stack.isEmpty()) {while (root != null) { TreeNode temp = root.left; root.left = root.right;root.right = temp; stack.push(root);root = root.left; }if (!stack.isEmpty()) {root = stack.pop();root = root.right; }} }</code></pre><p>20.输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p>思路:</p><ul><li>终止行号大于起始行号，终止列号大于起始列号，</li></ul><p>代码实现:</p><pre><code>public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(matrix == null)return list; int start = 0;while(matrix[0].length &gt; start*2 &amp;&amp; matrix.length &gt; start*2) {    printOneCircle(matrix,start,list);start++;}  return list;}private void printOneCircle(int[][] matrix,int start,ArrayList&lt;Integer&gt; list) {int endX = matrix[0].length - 1 - start; // 列int endY = matrix.length - 1 - start; // 行 // 从左往右for (int i = start; i &lt;= endX; i++) list.add(matrix[start][i]);// 从上往下if (start &lt; endY) {for (int i = start + 1; i &lt;= endY; i++) list.add(matrix[i][endX]);}// 从右往左(判断是否会重复打印)if (start &lt; endX &amp;&amp; start &lt; endY) {for (int i = endX - 1; i &gt;= start; i--) list.add(matrix[endY][i]); } // 从下往上(判断是否会重复打印)if (start &lt; endX &amp;&amp; start &lt; endY - 1) {for (int i = endY - 1; i &gt;= start + 1; i--)list.add(matrix[i][start]); } }</code></pre><p>21.定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p><p>思路:</p><ul><li>定义两个栈，一个存放入的值。另一个存最小值。</li></ul><p>代码实现:</p><pre><code>public void push(int node) { stack1.push(node);if (stack2.isEmpty()) {stack2.push(node); }else {if (stack2.peek() &gt; node) { stack2.push(node);} }}public void pop() {if (stack1.pop() == stack2.peek()) {stack2.pop(); }}public int top() {return stack1.peek(); } public int min() { return stack2.peek(); }</code></pre><p>22.输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入 栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出 序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。(注意:这两个序列的长度是相等的)</p><p>思路:</p><ul><li>用栈来压入弹出元素，相等则出栈。</li></ul><p>代码实现:</p><pre><code>public boolean IsPopOrder(int [] pushA,int [] popA) { if (pushA == null || popA == null) {      return false;  }Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();int index = 0;for (int i = 0; i &lt; pushA.length; i++) { stack.push(pushA[i]);while (!stack.isEmpty() &amp;&amp; stack.peek() == popA[index]) {stack.pop();index++; }}return stack.isEmpty(); }</code></pre><p>23.从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路:</p><ul><li>利用队列(链表)辅助实现。</li></ul><p>代码实现:</p><pre><code>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();if (root == null) {      return list;  } LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); list.add(node.val);if (node.left != null) {queue.addLast(node.left); }if (node.right != null) { queue.addLast(node.right);} }  return list; }</code></pre><p>24.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。 假设输入的数组的任意两个数字都互不相同。</p><p>思路:</p><ul><li>先找到右子树的开始位置，然后分别进行左右子树递归处理。</li></ul><p>代码实现:</p><pre><code> public boolean VerifySquenceOfBST(int[] sequence) {  if (sequence == null || sequence.length == 0) return false; int rstart = 0; int length = sequence.length;  for (int i = 0; i &lt; length - 1; i++) { if (sequence[i] &lt; sequence[length - 1]) rstart++; }if (rstart == 0) {VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,length-1)); }else {for (int i = rstart; i &lt; length - 1; i++) {if (sequence[i] &lt;= sequence[length - 1]) { return false;} }VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,rstart));VerifySquenceOfBST(Arrays.copyOfRange(sequence,rstart,length - 1)); }  return true;}</code></pre><p>25.输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结 点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>思路:</p><ul><li>先保存根节点，然后分别递归在左右子树中找目标值，若找到即到达叶子节点，打印路径中的值</li></ul><p>代码实现:</p><pre><code> public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {  if(root == null) return resultList;  list.add(root.val);  target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null){  resultList.add(new ArrayList&lt;&gt;(list)); }else {  FindPath(root.left,target); FindPath(root.right,target);  } //每返回上一层一次就要回退一个节点 list.remove(list.size()-1); return resultList;  }</code></pre><p>26.输入一个复杂链表(每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任 意一个节点)，返回结果为复制后复杂链表的head。(注意，输出结果中请不要返回参数中的节点引用，否则 判题程序会直接返回空)</p><p>思路:</p><ul><li>先复制链表的next节点，将复制后的节点接在原节点后，然后复制其它的节点，最后取偶数位置的节点 (复制后的节点)。</li></ul><p>代码实现:</p><pre><code> public RandomListNode Clone2(RandomListNode pHead) {  if(pHead == null) return null; RandomListNode head = new RandomListNode(pHead.label) ; RandomListNode temp = head ; while(pHead.next != null) {  temp.next = new RandomListNode(pHead.next.label) ;   if(pHead.random != null) {  temp.random = new RandomListNode(pHead.random.label) ; } pHead = pHead.next ; temp = temp.next ; }  return head ; }</code></pre><p>27.输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调 整树中结点指针的指向。</p><p>思路:</p><ul><li>定义一个链表的尾节点，递归处理左右子树，最后返回链表的头节点</li></ul><p>代码实现:</p><pre><code>public TreeNode Convert(TreeNode pRootOfTree) { TreeNode lastlist = covertNode(pRootOfTree,null);TreeNode pHead = lastlist;while (pHead != null &amp;&amp; pHead.left != null) {pHead = pHead.left; }  return pHead;}public TreeNode covertNode(TreeNode root, TreeNode lastlist) { if (root == null)return null; TreeNode cur = root;if (cur.left != null) {lastlist = covertNode(cur.left,lastlist); }cur.left = lastlist;if (lastlist != null) {lastlist.right = cur; }lastlist = cur;if (cur.right != null) {lastlist = covertNode(cur.right,lastlist); }  return lastlist;}</code></pre><p>28.输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所 能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>思路:</p><ul><li>将当前位置的字符和前一个字符位置交换，递归。</li></ul><p>代码实现:</p><pre><code> public ArrayList&lt;String&gt; Permutation(String str) {  ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;() ; if(str == null || str.length() == 0) return result; char[] chars = str.toCharArray() ;  TreeSet&lt;String&gt; temp = new TreeSet&lt;&gt;() ; Permutation(chars, 0, temp); result.addAll(temp) ; return result ;  }public void Permutation(char[] chars, int index, TreeSet&lt;String&gt; result) { if(chars == null || chars.length == 0 ) return ;if (index &lt; 0 || index &gt; chars.length - 1)return;if(index == chars.length-1) {result.add(String.valueOf(chars)) ; }else {for(int i=index ; i&lt;=chars.length-1 ;i++) { swap(chars, index, i) ;Permutation(chars, index+1, result);// 回退          swap(chars, index, i) ;      } } }public void swap(char[] c, int a,int b) { char temp = c[a];c[a] = c[b];c[b] = temp;}</code></pre><p>29.数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p><p>思路:</p><ul><li>将首次出现的数count+1，与之后的数进行比较，相等则+1，否则—1，最后进行校验是否超过长度的一<br>半。</li></ul><p>代码实现:</p><pre><code>public int MoreThanHalfNum_Solution(int [] array) {  int maxCount = array[0]; int number = array[0];  int count = 1;for (int i = 1; i &lt; array.length; i++) { if (number != array[i]) {if (count == 0) { number = array[i]; count = 1;}else { count--;} }else { count++; }if (count == 1) { maxCount = number;} }// 验证int num = 0;for (int j = 0; j &lt; array.length; j++) {if (array[j] == maxCount) { num++;} }if (num * 2 &gt; array.length) { return maxCount;}return 0; }</code></pre><p>30.输入n个整数，找出其中最小的K个数。</p><p>思路:</p><ul><li>先将前K个数放入数组，进行堆排序，若之后的数比它还小，则进行调整</li></ul><p>代码实现:</p><pre><code>public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();if (input == null || k &lt;= 0 || k &gt; input.length) {      return list;  }int[] kArray = Arrays.copyOfRange(input,0,k); // 创建大根堆buildHeap(kArray);for(int i = k; i &lt; input.length; i++) { if(input[i] &lt; kArray[0]) {kArray[0] = input[i];          maxHeap(kArray, 0);      } for (int i = kArray.length - 1; i &gt;= 0; i--) {  list.add(kArray[i]);}  return list; }public void buildHeap(int[] input) {for (int i = input.length/2 - 1; i &gt;= 0; i--) {      maxHeap(input,i);  }}private void maxHeap(int[] array,int i) { int left=2*i+1;int right=left+1; int largest=0;if(left &lt; array.length &amp;&amp; array[left] &gt; array[i]) largest=left; else largest=i; if(right &lt; array.length &amp;&amp; array[right] &gt; array[largest]) largest = right; if(largest != i) { int temp = array[i];  array[i] = array[largest]; array[largest] = temp; maxHeap(array, largest);} }</code></pre><p>31.求连续子数组(包含负数)的最大和</p><p>思路:</p><ul><li>若和小于0，则将最大和置为当前值，否则计算最大和。</li></ul><p>代码实现:</p><pre><code>public int FindGreatestSumOfSubArray(int[] array) { if (array == null || array.length == 0)return 0;int cur = array[0]; int greast = array[0];for (int i = 1; i &lt; array.length; i++) { if (cur &lt; 0) {cur = array[i]; }else {cur += array[i];}if (cur &gt; greast) { greast = cur;} }  return greast; }</code></pre><p>32.从1到整数n中1出现的次数</p><p>思路:</p><ul><li>若百位上数字为0，百位上可能出现1的次数由更高位决定;若百位上数字为1，百位上可能出现1的次数<br>不仅受更高位影响还受低位影响;若百位上数字大于1，则百位上出现1的情况仅由更高位决定</li></ul><p>代码实现:</p><pre><code>public long CountOne2(long n) {long count = 0; // 1的个数longi=1; // 当前位long current = 0,after = 0,before = 0;while((n / i) != 0) { before=n/(i*10);// 高位 current=(n/i)%10;// 当前位 after=n-(n/i)*i; // 低位if (current == 0) //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数 count = count + before * i; else if(current == 1) //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1 count = count + before * i + after + 1;else if (current &gt; 1)// 如果大于1,出现1的次数由高位决定,(高位数字+1)* 当前位数 count = count + (before + 1) * i;//前移一位i = i * 10; }  return count; }</code></pre><p>解法二:公式法</p><pre><code>public int NumberOf1Between1AndN_Solution(int n){ int count=0;for(int i = 1; i &lt;= n; i *= 10){ inta=n/i;// 高位 intb=n%i;// 低位count += (a+8) / 10 * i; if(a % 10 == 1){count += b + 1; } }  return count; }</code></pre><p>33.输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</p><p>思路:</p><ul><li>先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就 是制定排序规则。或使用比较和快排的思想，将前面的数和最后的数比较，若小则放到最前面，最后再递归调 用。</li></ul><p>代码实现:</p><pre><code>public String PrintMinNumber(int [] numbers) { if(numbers == null || numbers.length == 0)return "";int len = numbers.length;String[] str = new String[len]; StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; len; i++){str[i] = String.valueOf(numbers[i]); }Arrays.sort(str,new Comparator&lt;String&gt;(){ @Overridepublic int compare(String s1, String s2) { String c1 = s1 + s2;String c2 = s2 + s1;return c1.compareTo(c2); } });for(int i = 0; i &lt; len; i++){ sb.append(str[i]); } return sb.toString(); }</code></pre><p>34.丑数是只包含因子2、3和5的数，求从小到大的第N个丑数。</p><p>思路:</p><ul><li>乘2或3或5，之后比较取最小值。</li></ul><p>代码实现:</p><pre><code>public int GetUglyNumber_Solution(int index) { if (index &lt;= 0) return 0;int[] arr = new int[index]; arr[0] = 1;int multiply2 = 0; int multiply3 = 0;int multiply5 = 0; for (int i = 1; i &lt; index; i++) {int min = Math.min(arr[multiply2] * 2,Math.min(arr[multiply3] * 3,arr[multiply5] * 5)); arr[i] = min; if (arr[multiply2] * 2 == min) multiply2++; if (arr[multiply3] * 3 == min)  multiply3++;  if (arr[multiply5] * 5 == min)          multiply5++; } return arr[index - 1]; }</code></pre><p>35.在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p><p>思路:</p><ul><li>利用LinkedHashMap保存字符和出现次数。</li></ul><p>代码实现:</p><pre><code> public int FirstNotRepeatingChar(String str) { if (str == null || str.length() == 0) return -1; char[] c = str.toCharArray();  LinkedHashMap&lt;Character,Integer&gt; hash=new LinkedHashMap&lt;Character,Integer&gt;(); for(char item : c) { if(hash.containsKey(item))  hash.put(item, hash.get(item)+1); else  hash.put(item, 1);   }   for(int i = 0;i &lt; str.length(); i++){ if (hash.get(str.charAt(i)) == 1) { return i; }   } return -1; }</code></pre><p>36.在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组, 求出这个数组中的逆序对的总数P</p><p>思路:</p><ul><li>本质是归并排序，在比较时加入全局变量count进行记录逆序对的个数，若data[start] &gt;= data[index] ， 则count值为mid+1-start</li></ul><p>代码实现:</p><pre><code>int count = 0;public int InversePairs(int [] array) {if(array==null)return 0; mergeSort(array,0,array.length-1); return count; }private void mergeSort(int[] data,int start,int end) { int mid = (start + end) / 2;if (start &lt; end) {      mergeSort(data, start, mid);      mergeSort(data, mid + 1, end);      merge(data, start, mid, end); } }public void merge(int[] data,int start,int mid,int end) { int arr[] = new int[end - start + 1]; int c = 0; int s = start;int index = mid + 1;while (start &lt;= mid &amp;&amp; index &lt;= end) {if (data[start] &lt; data[index]) { arr[c++] = data[start++];} else { arr[c++] = data[index++]; count += mid +1 - start; count %= 1000000007; } } while (start &lt;= mid) { arr[c++] = data[start++]; }  while (index &lt;= end) { arr[c++] = data[index++];  } for (int d : arr) { data[s++] = d;  } }</code></pre><p>37.输入两个链表，找出它们的第一个公共结点。</p><p>思路:</p><ul><li>先求出链表长度，然后长的链表先走多出的几步，然后两个链表同时向下走去寻找相同的节点，代码量<br>少的方法需要将两个链表遍历两次，然后从头开始相同的节点。</li></ul><p>代码实现:</p><pre><code>  // 不需要遍历链表的解法 public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { ListNode p1 = pHead1; ListNode p2 = pHead2; while (p1 != p2){ p1 = (p1 != null ? p1.nextNode : pHead2); p2 = (p2 != null ? p2.nextNode : pHead1); } return p1; }</code></pre><p>38.统计一个数字在排序数组中出现的次数。</p><p>思路:</p><ul><li><p>利用二分查找+递归思想，进行寻找。当目标值与中间值相等时进行判断 代码实现:</p><pre><code>public int GetNumberOfK(int[] array,int k) { int result=0;int mid = array.length/2;if(array==null || array.length == 0) return 0; if(array.length == 1) { if(array[0] == k)        return 1;    else return 0; } if(k &lt; array[mid])  result += GetNumberOfK(Arrays.copyOfRange(array, 0, mid),k);  else if(k &gt; array[mid])result += GetNumberOfK(Arrays.copyOfRange(array, mid, array.length),k); else {for(int i = mid;i &lt; array.length;i++) { if(array[i] == k) result++; else break;   }  for(int i = mid - 1;i &gt;= 0;i--) { if(array[i] == k)            result++;        elsebreak; }}return result;}</code></pre></li></ul><p>39.输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路 径，最长路径的长度为树的深度。</p><p>思路:</p><ul><li>利用递归遍历分别返回左右子树深度</li></ul><p>代码实现:</p><pre><code>public int TreeDepth(TreeNode root) { if (root == null)  return 0; int left = TreeDepth(root.left);int right = TreeDepth(root.right); return left &gt; right ? left + 1 : right + 1;  }</code></pre><p>39.1输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>思路:</p><ul><li>平衡因子的绝对值&lt;= 1.</li></ul><p>代码实现:</p><pre><code>  public boolean IsBalanced_Solution(TreeNode root) { if (root == null)  return true;    int left = getDepth(root.left);     int right = getDepth(root.right);     int diff = left - right; if (diff &gt;= -1 &amp;&amp; diff &lt;= 1) {      return true;  }  return false;  }  public int getDepth(TreeNode root) { if (root == null)   return 0; int depth = 0;     int leftNode = getDepth(root.left);int rightNode = getDepth(root.right);  depth = leftNode &gt; rightNode ? leftNode : rightNode; return depth + 1;    }</code></pre><p>40.一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>思路:</p><ul><li>两个相同的数异或后为0，将所有数异或后得到一个数，然后求得1在该数最右边出现的index，然后判<br>断每个数右移index后是不是1。</li></ul><p>代码实现:</p><pre><code>  public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) { if (array == null)  return; num1[0] = 0;num2[0] = 0;  int number = array[0];  for (int i = 1; i &lt; array.length; i++)  number ^= array[i];  // 异或后的数1出现在第几位 int index = 0;  while ((number &amp; 1) == 0) {  number = number &gt;&gt; 1;  index++; }  for (int i = 0; i &lt; array.length; i++) {  // 判断第index位是不是0  boolean isBit = ((array[i] &gt;&gt; index) &amp; 1) == 0; if (isBit) {  num1[0] ^= array[i]; } else {  num2[0] ^= array[i]; }  } }</code></pre><p>41.输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><p>思路:</p><ul><li>定义两个指针，分别递增，寻找和为s的序列。</li></ul><p>代码实现:</p><pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) {       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();  if (sum &lt; 3)  return arrayList; int small = 1;  int big = 2;  while (small &lt; (sum + 1) / 2) {  int s = 0;  for (int i = small; i &lt;= big; i++) {  s += i; }  if (s == sum) {  for (int i = small; i &lt;= big; i++) {  list.add(i); }  arrayList.add(new ArrayList&lt;&gt;(list)); list.clear();  small++;          } else {              if (s &gt; sum) {                  small++;              } else {   big++;    } }  }      return arrayList;  }</code></pre><p>41.1输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的 和等于S，输出两个数的乘积最小的。</p><p>思路:</p><ul><li>定义两个指针，分别从前面和后面进行遍历。间隔越远乘积越小，所以是最先出现的两个数乘积最小</li></ul><p>代码实现:</p><pre><code>  public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();  if (array == null )  return list; int left = 0;  int right = array.length - 1;  while (left &lt; right) {  int s = array[left] + array[right]; if (s == sum) {  list.add(array[left]); list.add(array[right]); return list;      }else {          if (s &gt; sum) {  right--; }else {  left++; }  } }  return list;    }</code></pre><p>42.翻转字符串</p><p>思路:</p><ul><li>先将整个字符串翻转，然后将每个单词翻转。</li></ul><p>代码实现:</p><pre><code>  public String ReverseSentence(String str) { if (str == null || str.length() == 0)  return str;  if (str.trim().length() == 0)  return str;  StringBuilder sb = new StringBuilder(); String re = reverse(str);  String[] s = re.split(" ");  for (int i = 0; i &lt; s.length - 1; i++) {     sb.append(reverse(s[i]) + " "); }  sb.append(reverse(s[s.length-1]));  return String.valueOf(sb); }  public String reverse(String str) {  StringBuilder sb = new StringBuilder();  for (int i = str.length() - 1; i &gt;= 0 ; i--) {  sb.append(str.charAt(i)); }  return String.valueOf(sb); }</code></pre><p>42.1对于一个给定的字符序列S，请你把其循环左移K位后的序列输出</p><p>思路:</p><ul><li>拼接或反转三次字符串</li></ul><p>代码实现:</p><pre><code>  public String LeftRotateString(String str,int n) { if (str == null || str.length() == 0)  return str;  String s1 = reverse(str.substring(0,n));  String s2 = reverse(str.substring(n,str.length())); return reverse(s2)+reverse(s1);  }</code></pre><p>43.把n个骰子扔在地上，所有骰子朝上一面的点数之和为s,输入n,打印出s的所有可能出现的概率</p><p>思路:</p><ul><li>递归一般是自顶向下的分析求解，而循环则是自底向上，占用更少的空间和更少的时间，性能较好。定 义一个二维数组，第一次掷骰子有6种可能，第一个骰子投完的结果存到probabilities[0];第二次开始掷骰子， 在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为n-1,n- 2,n-3, n-4,n-5，n-6的次数总和，所以我们把另一个数组的第n个数字设为前一个数组对应n-1,n-2,n-3,n-4,n-5， n-6之和</li></ul><p>代码实现:</p><pre><code>  public void printProbability(int number) {  if(number&lt;1)  return ;  int g_maxValue=6;  int[][] probabilities=new int[2][]; probabilities[0]=new int[g_maxValue*number+1];       probabilities[1]=new int[g_maxValue*number+1]; int flag=0;  // 当第一次抛掷骰子时，有6种可能，每种可能出现一次 for(int i=1;i&lt;=g_maxValue;i++)    probabilities[0][i]=1;     //从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数， for(int k=2;k&lt;=number;++k) {  for(int i=0;i&lt;k;++i)  // 第k次掷骰子，和最小为k，小于k的情况是不可能发生的,令不可能发生的次数设置为0! probabilities[1-flag][i]=0;  // 第k次掷骰子，和最小为k，最大为g_maxValue*k for(int i=k;i&lt;=g_maxValue*k;++i) {  // 初始化，因为这个数组要重复使用，上一次的值要清0 probabilities[1-flag][i]=0;  for(int j=1;j&lt;=i &amp;&amp; j&lt;=g_maxValue;++j)  probabilities[1-flag][i]+=probabilities[flag][i-j];  }  flag=1-flag; }  double total=Math.pow(g_maxValue, number); for(int i=number;i&lt;=g_maxValue*number;i++) {  double ratio=(double) probabilities[flag][i]/total; System.out.println(i);  System.out.println(ratio);  } }</code></pre><p>44.扑克牌的顺子</p><p>思路:</p><ul><li>用数组记录五张扑克牌，将数组调整为有序的，若0出现的次数&gt;=顺子的差值，即为顺子。</li></ul><p>代码实现:</p><pre><code>  public boolean isContinuous(int [] numbers) { if (numbers == null || numbers.length == 0)  return false; int count = 0;  int diff = 0; Arrays.sort(numbers);  for (int i = 0; i &lt; numbers.length - 1; i++) { if (numbers[i] == 0) {  count++;  continue; }  if (numbers[i] != numbers[i+1]) {  diff += numbers[i+1] - numbers[i] - 1;      } else {          return false;  } }  if (diff &lt;= count) return true;    return false;    }</code></pre><p>45.圆圈中最后剩下的数字(约瑟夫环)</p><p>思路:</p><ul><li>利用循环链表实现</li></ul><p>代码实现:</p><pre><code>  public int LastRemaining_Solution(int n, int m) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); int bt = 0;  for (int i = 0; i &lt; n; i ++) { list.add(i);  }  while (list.size() &gt; 1) {  bt = (bt + m - 1) % list.size(); list.remove(bt);  }  return list.size() == 1 ? list.get(0) : -1; }</code></pre><p>46.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A? B:C)。</p><p>思路:</p><ul><li>巧用递归(返回值类型为Boolean)</li></ul><p>代码实现:</p><pre><code>  public int Sum_Solution(int n) { int sum = n;  boolean result = (n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n-1)) &gt; 0);  return sum; }</code></pre><p>47.写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p>思路:</p><ul><li>利用位运算</li></ul><p>代码实现:</p><pre><code>  public int Add(int num1,int num2) { while (num2 != 0) {  // 计算个位  int temp = num1 ^ num2;  // 计算进位(1+1)  num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp;     }      return num1;    }</code></pre><p>48.不能被继承的类</p><p>思路:</p><ul><li>私有构造器的类不能继承<br>49.将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法 的数值则返回0</li></ul><p>思路:</p><ul><li>若为负数，则输出负数，字符0对应48,9对应57，不在范围内则返回false。</li></ul><p>代码实现:</p><pre><code>  public int StrToInt(String str) {  if (str == null || str.length() == 0)  return 0; int mark = 0;  int number = 0;  char[] chars = str.toCharArray();  if (chars[0] == '-') mark = 1;  for (int i = mark; i &lt; chars.length; i++) { if (chars[i] == '+') {  continue; }      if (chars[i] &lt; 48 || chars[i] &gt; 57) {          return 0;  }  number = number * 10 + chars[i] - 48; }  return mark == 0 ? number : -number; }</code></pre><p>50.求树中两个节点的最低公共祖先<br>(1)树是二叉搜索树</p><p>思路:</p><ul><li>从树的根节点开始遍历，如果根节点的值大于其中一个节点，小于另外一个节点，则根节点就是最低公 共祖先。否则如果根节点的值小于两个节点的值，则递归求根节点的右子树，如果大于两个节点的值则递归求 根的左子树。如果根节点正好是其中的一个节点，那么说明这两个节点在一条路径上，所以最低公共祖先则是 根节点的父节点，时间复杂度是O(logn)，空间复杂度是O(1)</li></ul><p>代码实现:</p><pre><code>    public static BinaryTreeNode getLowestCommonAncestor(BinaryTreeNode rootParent,BinaryTreeNode root,  BinaryTreeNode node1,BinaryTreeNode node2){  if(root == null || node1 == null || node2 == null){ return null;  }   if((root.value - node1.value)*(root.value - node2.value) &lt; 0){ return root;  }else if((root.value - node1.value)*(root.value - node2.value) &gt; 0){  BinaryTreeNode newRoot = ((root.value &gt; node1.value) &amp;&amp; (root.value &gt; node2.value))  ? root.leftNode : root.rightNode;  return getLowestCommonAncestor(root,newRoot, node1, node2);  }else{      return rootParent;  } }</code></pre><ul><li>(2)若树是普通树，但有指向父节点的指针 思路:两个节点如果在两条路径上，类似于求两个链表的第一个公共节点。由于每个节点的深度最多为logn，<br>所以时间复杂度为O(logn),空间复杂度O(1)</li></ul><p>代码实现:</p><pre><code>  public static BinaryTreeNode  getLowestCommonAncestor1(BinaryTreeNode root,BinaryTreeNode node1,                                                     BinaryTreeNode node2){  if(root == null || node1 == null || node2 == null){ return null;  }  int depth1 = findTheDepthOfTheNode(root, node1, node2); if(depth1 == -1){  return node2.parentNode; }  int depth2 = findTheDepthOfTheNode(root, node2, node1); if(depth2 == -1){  return node1.parentNode; }  //p指向较深的节点q指向较浅的节点  BinaryTreeNode p = depth1 &gt; depth2 ? node1 : node2; BinaryTreeNode q = depth1 &gt; depth2 ? node2 : node1; int depth = Math.abs(depth1 - depth2);  while(depth &gt; 0){  p = p.parentNode; depth --;  }  while(p != q){  p = p.parentNode;  q = q.parentNode; }  return p; }  //求node1的深度，如果node1和node2在一条路径上，则返回-1，否则返回node1的深度  public static int findTheDepthOfTheNode(BinaryTreeNode root,BinaryTreeNode node1,  int depth = 0; while(node1.parentNode != null){   node1 = node1.parentNode; depth ++;  if(node1 == node2){  return -1; }  }  return depth;    }</code></pre><ul><li>(3)若树是普通树，并没有指向父节点的指针 思路:用栈来实现类似于指向父节点指针的功能，获取node节点的路径时间复杂度为O(n),所以总的时间复杂<br>度是O(n),空间复杂度是O(logn)</li></ul><p>代码实现:</p><pre><code>  public static BinaryTreeNode getLowestCommonAncestor2(BinaryTreeNode root, BinaryTreeNode node1,                                                    BinaryTreeNode node2){  if(root == null || node1 == null || node2 == null){ return null;  }  Stack&lt;BinaryTreeNode&gt; path1 = new Stack&lt;BinaryTreeNode&gt;(); boolean flag1 = getThePathOfTheNode(root, node1,path1); if(!flag1){//树上没有node1节点      return null;  }  Stack&lt;BinaryTreeNode&gt; path2 = new Stack&lt;BinaryTreeNode&gt;(); boolean flag2 = getThePathOfTheNode(root, node2,path2); if(!flag2){//树上没有node2节点      return null;  }  if(path1.size() &gt; path2.size()){ //让两个路径等长 while(path1.size() != path2.size()){  path1.pop(); }  }else{  while(path1.size() != path2.size()){  path2.pop(); }  }  if(path1 == path2){//当两个节点在一条路径上时 path1.pop();  return path1.pop(); }else{  BinaryTreeNode p = path1.pop(); BinaryTreeNode q = path2.pop(); while(q != p){  p = path1.pop();  q = path2.pop(); }    return p; }  //获得根节点到node节点的路径  public static boolean getThePathOfTheNode(BinaryTreeNode root,BinaryTreeNode node,  }  path.push(root); if(root == node){return true;  }  boolean found = false; if(root.leftNode != null){  Stack&lt;BinaryTreeNode&gt; path){  found = getThePathOfTheNode(root.leftNode, node, path); }  if(!found &amp;&amp; root.rightNode != null){  found = getThePathOfTheNode(root.rightNode, node, path);  }  if(!found){  path.pop(); }  return found;    }</code></pre><p>51.在一个长度为n的数组里的所有数字都在0到n-1的范围内，找出数组中任意一个重复的数字</p><p>思路:</p><ul><li>若下标大于length，则减去length，最后再加上length，若下标的数组值大于length，则返回true。或使<br>用辅助空间(HashSet)</li></ul><p>代码实现:</p><pre><code>  public boolean duplicate(int numbers[],int length,int [] duplication) { if (numbers == null || length == 0 || length == 1)  return false;  for (int i = 0; i &lt; length; i++) {  int index = numbers[i]; if (index &gt;= length) index -= length;  if (numbers[index] &gt;= length) { duplication[0] = index; return true;  }  numbers[index] += length; }  return false;    }</code></pre><p>52.给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。 其中A[i] = 1。不能使用除法，</p><p>思路:</p><ul><li>使用矩阵法求解，将矩阵分为上三角矩阵和下三角矩阵，分别求乘积</li></ul><p>代码实现:</p><pre><code>  public int[] multiply(int[] A) { int length = A.length;  int[] B = new int[length]; if(length != 0 ){  B[0] = 1;  //计算下三角连乘  for(int i = 1; i &lt; length; i++){  B[i] = B[i-1] * A[i-1]; }  int temp = 1;  //计算上三角连乘  for(int j = length-2; j &gt;= 0; j--){  temp *= A[j+1];  B[j] *= temp; }  }  return B; }</code></pre><p>53.请实现一个函数用来匹配包括’.’和’’ 符可以出现任意次(包含0次)false 2 “”时:如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配;如果字符串第一个<br>字符跟模式第一个字符匹配或是点，可以有3种匹配方式:1 &gt;模式后移2字符，相当于x 2&gt;<br>‘.’ ‘’表示它前面的字</p><p>思路:</p><ul><li>当字符串只有一个字符时，进行判断，否则就有两种递归情况，(1)当模式中的第二个字符不是“”</li></ul><p>1 2 3&gt; 1</p><p>代码实现:</p><pre><code>  public boolean match(char[] str, char[] pattern) { if (str == null || pattern == null)  return false;  // 若字符串的长度为1  if (str.length == 1) {  if (pattern.length == 1){  if (str[0] == pattern[0] || pattern[0] == '.')              return true;          return false;  } }  int sindex = 0;  int pindex = 0;  return matchIndex(str,sindex,pattern,pindex);  }  public boolean matchIndex(char[] str,int sindex, char[] pattern, int pindex) { // str和pattern同时到达末尾，则匹配成功</code></pre><p>可以匹配多位;</p><pre><code>    if (sindex == str.length &amp;&amp; pindex == pattern.length) return true;  // 若pattern先到尾，而str没有到达末尾，则匹配失败  if (sindex != str.length &amp;&amp; pindex == pattern.length)  return false;  // 若pattern第二个字符是*  if (pindex + 1 &lt; pattern.length &amp;&amp; pattern[pindex + 1] == '*') {  if (sindex != str.length &amp;&amp; pattern[pindex] == str[sindex] || sindex != str.length &amp;&amp; pattern[pindex] == '.') {          return matchIndex(str,sindex+1,pattern,pindex+2)                  || matchIndex(str,sindex,pattern,pindex+2)                  || matchIndex(str,sindex+1,pattern,pindex);      } else {          return matchIndex(str,sindex,pattern,pindex+2);  } }  // 若pattern第二个字符不是*  if (sindex != str.length &amp;&amp; pattern[pindex] == str[sindex] ||  sindex != str.length &amp;&amp; pattern[pindex] == '.') return matchIndex(str,sindex+1,pattern,pindex+1);  return false;    }</code></pre><p>54.请实现一个函数用来判断字符串是否表示数值(包括整数和小数)</p><p>思路:</p><ul><li>逐个字符进行判断，e或E和小数点最多出现一次，而e或E的前一个必须是数字，且不能是第一个或最<br>后一个字符，符号的前一个字符不能是e或E。也可用正则表达式判断!</li></ul><p>代码实现:</p><pre><code>  public boolean isNumeric(char[] str) { if (str == null)   return false; int index = 0;  int ecount = 0;  int point = 0;  // 如果第一个字符是符号就跳过 if (str[0] == '-' || str[0]  index++;  == '+')  for (int i = index; i &lt; str.length; i++) { if (str[i] == '-' || str[i] == '+') {  if (str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false;  continue; }  if (str[i] == 'e' || str[i] == 'E') { ecount++;    if (ecount &gt; 1)        return false;  if (i == 0 || str[i-1] &lt; 48 || str[i-1] &gt; 57 || i == str.length-1)    return false;point++;  continue; }  if (str[i] == '.') { point++;if (point &gt; 1)    return false;  continue; }  // 出现非数字且不是e/E则返回false(小数点和符号用continue跳过了)  if ((str[i] &lt; 48 || str[i] &gt; 57) &amp;&amp; (str[i] != 'e') &amp;&amp; (str[i] != 'E'))return false;  return true;    }</code></pre><p>55.请实现一个函数用来找出字符流中第一个只出现一次的字符。</p><p>思路:</p><ul><li>借助辅助空间进行判断，如字符数组。</li></ul><p>代码实现:</p><pre><code>  char[] chars = new char[256]; StringBuilder sb = new StringBuilder();  public void Insert(char ch) { sb.append(ch);  chars[ch]++;    }  public char FirstAppearingOnce() {  char[] str = sb.toString().toCharArray(); for (char c : str) {  if (chars[c] == 1) { return c;  } }  return '#'; }</code></pre><p>56.一个链表中包含环，请找出该链表的环的入口结点。</p><p>思路:</p><ul><li>定义快慢两个指针，相遇后(环中相汇点)将快指针指向pHead 然后一起走，每次往后挪一位，相遇的 节点即为所求。详细分析:相遇即p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2 比p1多走一圈有2x=n+x; n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2 每次走一步直到p1==p2; 此时p1指向环的入口。</li></ul><p>代码实现:</p><pre><code>   public ListNode EntryNodeOfLoop(ListNode pHead) { if (pHead == null || pHead.next == null)  return null; ListNode slow = pHead; ListNode fast = pHead;  while (fast != null &amp;&amp; fast.next != null) { slow = slow.next;  fast = fast.next.next;  if (slow == fast){  fast = pHead;  while (fast != slow) {  fast = fast.next;  slow = slow.next; }  if (fast == slow) return slow;  } }  return null;    }</code></pre><p>57.在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指 针。</p><p>思路:</p><ul><li>先新建一个头节点，然后向后查找值相同的节点，重复查找后删除</li></ul><p>代码实现:</p><pre><code>  public ListNode deleteDuplication(ListNode pHead) { if (pHead == null)  return null;  // 新建一个节点，防止头结点被删除 ListNode first = new ListNode(-1); first.next = pHead;  ListNode p = pHead;  // 指向前一个节点  ListNode preNode = first;  while (p != null &amp;&amp; p.next != null) { if (p.val == p.next.val) {  int val = p.val;  // 向后重复查找  while (p != null &amp;&amp; p.val == val) {  p = p.next; }  // 上个非重复值指向下一个非重复值:即删除重复值  preNode.next = p; }else {  // 如果当前节点和下一个节点值不等，则向后移动一位 preNode = p;    p = p.next; }  }  return first.next; }</code></pre><p>58.给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅 包含左右子结点，同时包含指向父结点的指针。</p><p>思路:</p><ul><li>若节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子 节点即为下一个节点;若节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点;否则继续向上遍 历其父节点的父节点，重复之前的判断，返回结果</li></ul><p>代码实现:</p><pre><code>  public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null)  return null;  if (pNode.right != null) {  pNode = pNode.right;  while (pNode.left != null) {  pNode = pNode.left; }      return pNode;  }  while (pNode.next != null) {  // 找第一个当前节点是父节点左孩子的节点 if (pNode.next.left == pNode)  return pNode.next; pNode = pNode.next;  }  return null;    }</code></pre><p>59.请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样 的，定义其为对称的。</p><p>思路:</p><ul><li>利用递归进行判断，若左子树的左孩子等于右子树的右孩子且左子树的右孩子等于右子树的左孩子，并 且左右子树节点的值相等，则是对称的。</li></ul><p>代码实现:</p><pre><code>  public boolean isSymmetrical(TreeNode pRoot){ if (pRoot == null)  return true;  return isCommon(pRoot.left, pRoot.right);  }  public boolean isCommon(TreeNode leftNode, TreeNode rightNode) { if (leftNode == null &amp;&amp; rightNode == null)     return true;  if (leftNode != null &amp;&amp; rightNode != null) return leftNode.val == rightNode.val &amp;&amp;  isCommon(leftNode.left,rightNode.right) &amp;&amp;  isCommon(leftNode.right,rightNode.left); return false;  }</code></pre><p>60.请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序 打印，第三行按照从左到右的顺序打印，依此类推。</p><p>思路:</p><ul><li>利用两个栈的辅助空间分别存储奇数偶数层的节点，然后打印输出。或使用链表的辅助空间来实现，利 用链表的反向迭实现逆序输出。</li></ul><p>代码实现:</p><pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null)  return res;  Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); // s1表示奇数，从右向左输出 Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); // s2表示偶数，从左向右输出 s1.push(pRoot);  int level = 1;  while (!s1.empty() || !s2.empty()) {  if (level % 2 != 0) {  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!s1.empty()) {  TreeNode node = s1.pop(); if (node != null) {  list.add(node.val); s2.push(node.left); s2.push(node.right);  } }  if (!list.isEmpty()) { res.add(list);  level++; }  } else {  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!s2.empty()) {  TreeNode node = s2.pop(); if (node != null) {  list.add(node.val); s1.push(node.right); s1.push(node.left);  } }    if (!list.isEmpty()) { res.add(list);  level++; }  } }  return res; }</code></pre><p>61.从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><p>思路:</p><ul><li>利用辅助空间链表或队列来存储节点，每层输出。</li></ul><p>代码实现:</p><pre><code>  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null)  return res;  LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot);  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();  int start = 0;  int end = 1;  while (!queue.isEmpty()) { TreeNode node = queue.pop(); list.add(node.val);  start++;  if (node.left != null) queue.offer(node.left);  if (node.right != null) queue.offer(node.right);  if (start == end) { start = 0;  end = queue.size();  res.add(new ArrayList&lt;&gt;(list)); list.clear();  } }  return res; }  62.请实现两个函数，分别用来序列化和反序列化二叉树 思路:序列化:前序遍历二叉树存入字符串中;反序列化:根据前序遍历重建二叉树。 代码实现:  public String Serialize(TreeNode root) { StringBuffer sb = new StringBuffer();  if (root == null){ sb.append("#,");  return sb.toString(); }  sb.append(root.val + ","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString();  }  public int index = -1;  public TreeNode Deserialize(String str) {  index++;  int len = str.length(); String[] strr = str.split(","); TreeNode node = null;  if (index &gt;= len) return null;  if (!strr[index].equals("#")){  node = new TreeNode(Integer.valueOf(strr[index])); node.left = Deserialize(str);  node.right = Deserialize(str);  }  return node;    }</code></pre><p>63.给定一颗二叉搜索树，请找出其中的第k大的结点</p><p>思路:</p><ul><li>二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序，第k个结点就是第K大的节点，分别递<br>归查找左右子树的第K个节点，或使用非递归借用栈的方式查找，当count=k时返回根节点。</li></ul><p>代码实现:</p><pre><code>  int count = 0;  public TreeNode KthNode(TreeNode pRoot, int k) {  if (pRoot == null || k &lt; 1) return null;  count++;  if (count == k) {      return pRoot;  }  TreeNode leftNode = KthNode(pRoot.left,k); if (leftNode != null)      return leftNode;  TreeNode rightNode = KthNode(pRoot.right,k); if (rightNode != null)   return rightNode;    return null;    }</code></pre><p>64.如何得到一个数据流中的中位数?如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位 于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>思路:</p><ul><li>创建优先级队列维护大顶堆和小顶堆两个堆，并且小顶堆的值都大于大顶堆的值，2个堆个数的差值小 于等于1，所以当插入个数为奇数时:大顶堆个数就比小顶堆多1，中位数就是大顶堆堆头;当插入个数为偶数 时，使大顶堆个数跟小顶堆个数一样，中位数就是 2个堆堆头平均数。也可使用集合类的排序方法。</li></ul><p>代码实现:</p><pre><code>  int count = 0;  PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();  PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(16, new Comparator&lt;Integer&gt;() {  @Override  public int compare(Integer o1, Integer o2) {  return o2.compareTo(o1); }  });    public void Insert(Integer num) {  count++;  // 当数据的个数为奇数时，进入大根堆 if ((count &amp; 1) == 1) {  minHeap.offer(num);  maxHeap.offer(minHeap.poll()); } else {  maxHeap.offer(num);  minHeap.offer(maxHeap.poll()); }  }  public Double GetMedian() { if (count == 0)  return null;  // 当数据个数是奇数时，中位数就是大根堆的顶点 if ((count &amp; 1) == 1) {  return Double.valueOf(maxHeap.peek()); } else {  return Double.valueOf((minHeap.peek() + maxHeap.peek())) / 2; }  }</code></pre><p>65.给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值</p><p>思路:</p><ul><li>两个for循环，第一个for循环滑动窗口，第二个for循环滑动窗口中的值，寻找最大值。还可以使用时间<br>复杂度更低的双端队列求解。</li></ul><p>代码实现:</p><pre><code>   public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();  if (num == null || size &lt; 1 || num.length &lt; size)  return list;  int length = num.length - size + 1;  for (int i = 0; i &lt; length; i++) {  int current = size + i;  int max = num[i];  for (int j = i; j &lt; current; j++) {  if (max &lt; num[j]) { max = num[j];  } }  list.add(max); }  return list;    }</code></pre><p>66.请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中 的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵 中的某一个格子，则该路径不能再进入该格子。</p><p>思路:</p><ul><li>回溯法，双层for循环，判断每一个点，每次递归调用上下左右四个点，用flag标志是否已经匹配 (return)，进行判断点的位置是否越界，是否已经正确匹配，判断矩阵的路径与模式串的第index个字符是否 匹配。</li></ul><p>代码实现:</p><pre><code>  public boolean hasPath(char[] matrix, int rows, int cols, char[] str) { int flag[] = new int[matrix.length];  for (int i = 0; i &lt; rows; i++) {  for (int j = 0; j &lt; cols; j++) {  if (helper(matrix, rows, cols, i, j, str, 0, flag))  return true;  } }  return false;    }  private boolean helper(char[] matrix,int rows,int cols,int i,int j,char[] str,int k,int[] flag) { int index = i * cols + j;  if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1)      return false;  if(k == str.length - 1) return true;  flag[index] = 1;  if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)  || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)    || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)          || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) {      return true;  }  flag[index] = 0; return false;  }</code></pre><p>67.地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方 向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。</p><p>思路:</p><ul><li>利用递归实现，每次只能走上下左右四个点，进行判断点的位置是否越界，点数之和是否大于K，是否 已经走过了。</li></ul><p>代码实现:</p><pre><code>  public int movingCount(int threshold, int rows, int cols) { int flag[][] = new int[rows][cols]; //记录是否已经走过 return helper(0, 0, rows, cols, flag, threshold);  }  private int helper(int i, int j, int rows, int cols, int[][] flag, int threshold) { if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols ||  numSum(i) + numSum(j) &gt; threshold || flag[i][j] == 1) return 0;  flag[i][j] = 1;  return helper(i - 1, j, rows, cols, flag, threshold)  + helper(i + 1, j, rows, cols, flag, threshold)  + helper(i, j - 1, rows, cols, flag, threshold)  + helper(i, j + 1, rows, cols, flag, threshold) + 1;  }  private int numSum(int i) { int sum = 0;  while (i &gt; 0) { sum += i % 10;  i = i / 10; }  return sum; }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《将博客搬至CSDN》</title>
      <link href="/2019/12/09/jiang-bo-ke-ban-zhi-csdn/"/>
      <url>/2019/12/09/jiang-bo-ke-ban-zhi-csdn/</url>
      
        <content type="html"><![CDATA[<p>《将博客搬至CSDN》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>救出被困四只猫</title>
      <link href="/2019/12/09/jiu-chu-bei-kun-si-zhi-mao/"/>
      <url>/2019/12/09/jiu-chu-bei-kun-si-zhi-mao/</url>
      
        <content type="html"><![CDATA[<iframe src="http://disk.lichongbing.com:8888/quickview/video.html?fileId=d2c5eb79-1684-4ea7-8eaf-be5444627e9a" height="510" width="890" style="border:0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen=""></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ipmitool使用报错处理  Could not open device at /dev/ipmi0 or /dev/ipmi/0 or /dev/ipmidev/0: No such file or directory</title>
      <link href="/2019/12/08/ipmitool-shi-yong-bao-cuo-chu-li-could-not-open-device-at-dev-ipmi0-or-dev-ipmi-0-or-dev-ipmidev-0-no-such-file-or-directory/"/>
      <url>/2019/12/08/ipmitool-shi-yong-bao-cuo-chu-li-could-not-open-device-at-dev-ipmi0-or-dev-ipmi-0-or-dev-ipmidev-0-no-such-file-or-directory/</url>
      
        <content type="html"><![CDATA[<p>解决办法：需要加载相关模块</p><p>查看先关模块是否加载（可以看出模块未加载）</p><p><code>#lsmod |grep ^ipmi</code></p><p>加载以下模块</p><p><code># modprobe ipmi_watchdog</code></p><p><code># modprobe ipmi_poweroff</code></p><p><code># modprobe ipmi_devintf</code></p><p><code># modprobe ipmi_si  加载该模块如果没有不影响ipmi的使用（与系统版本有关）</code></p><p><code># modprobe ipmi_msghandler  加载该模块如果没有不影响ipmi的使用</code></p><p>之后就可以正常使用了：</p><p><code>ipmitool lan print </code>  查看本机IPMI地址等信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat开机自启动shell脚本</title>
      <link href="/2019/12/06/tomcat-kai-ji-zi-qi-dong-shell-jiao-ben/"/>
      <url>/2019/12/06/tomcat-kai-ji-zi-qi-dong-shell-jiao-ben/</url>
      
        <content type="html"><![CDATA[<p>1.你电脑必须安装成功tomcat<br>①编写tomcat.service文件</p><p>在/usr/lib/systemd/system路径下添加tomcat.service文件，内容如下：</p><p><code>[Unit]</code></p><p><code>Description=Tomcat</code><br><code>After=syslog.target network.target remote-fs.target nss-lookup.target</code></p><p><code>[Service]</code></p><p><code>Type=forking</code></p><p><code>PIDFile=/opt/tomcat/tomcat.pid</code></p><p><code>ExecStart=/opt/tomcat/bin/startup.sh</code></p><p><code>ExecReload=/bin/kill -s HUP $MAINPID</code></p><p><code>ExecStop=/bin/kill -s QUIT $MAINPID</code></p><p><code>PrivateTmp=true</code></p><p><code>[Install]</code></p><p><code>WantedBy=multi-user.target</code></p><p><code>[unit]配置了服务的描述，规定了在network启动之后执行</code></p><p><code>[service]配置服务的pid，服务的启动，停止，重启</code></p><p><code>[install]配置了使用用户</code></p><p>②然后保存退出 赋权限</p><p><code>chmod 754 tomcat.service</code></p><p>③重载系统服务列表</p><p><code>systemctl daemon-reload</code></p><p>④在第99行加入如下代码</p><p><code>export JAVA_HOME=/data/server/jdk1.8.0_144</code></p><p><code>export JRE_HOME=/data/serverjdk1.8.0_144/jre</code></p><p>⑤保存退出后，通过下面命令将tomcat.service加入到开机自启动</p><p><code>systemctl enable tomcat.service </code></p><p>⑥启动tomcat8服务</p><p><code>systemctl start tomcat8</code></p><p>然后再重启</p><p><code>reboot </code></p><p>重启好了<br><code>ps aux | grep tomcat </code></p><p>有服务的话就代表成功了 没有的话就是你有地方出错了<br>好好研究吧 ！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04 ssh 开机自动启动的设置方法</title>
      <link href="/2019/12/06/ubuntu18-04-ssh-kai-ji-zi-dong-qi-dong-de-she-zhi-fang-fa/"/>
      <url>/2019/12/06/ubuntu18-04-ssh-kai-ji-zi-dong-qi-dong-de-she-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu18.04 ssh 开机自动启动的设置方法如下：</p><p><code># 开机自动启动ssh命令</code></p><p><code>sudo systemctl enable ssh</code></p><p><code># 关闭ssh开机自动启动命令</code></p><p><code>sudo systemctl disable ssh</code></p><p><code># 单次开启ssh</code></p><p><code>sudo systemctl start ssh</code></p><p><code># 单次关闭ssh</code></p><p><code>sudo systemctl stop ssh</code></p><p><code># 设置好后重启系统</code></p><p><code>reboot</code></p><p>#查看ssh是否启动，看到Active: active (running)即表示成功</p><p><code>sudo systemctl status ssh</code></p><p>资料参考<a href="https://linuxize.com/post/how-to-enable-ssh-on-ubuntu-18-04/">https://linuxize.com/post/how-to-enable-ssh-on-ubuntu-18-04/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】显示you are in emergency mode解决方法</title>
      <link href="/2019/12/06/linux-xian-shi-you-are-in-emergency-mode-jie-jue-fang-fa/"/>
      <url>/2019/12/06/linux-xian-shi-you-are-in-emergency-mode-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>物理机Ubuntu开机显示有一个fail to mount，然后下面显示you are in emergency mode……</p><p>原因是因为磁盘挂载时，显示物理坏道，没法使用，于是我取下来，结果每次开机都自动挂载，挂载不上，所以报错<br>解决方法：<br>输入vim /etc/fstab ，删除未被mount上的磁盘（即删掉.host:/dev/sdd1 /home/disksdd1  defaults 0 0这句话），然后reboot重启即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu-server-18.04 设置开机启动dhcp自动配置内部网络IP脚本</title>
      <link href="/2019/12/06/ubuntu-server-18-04-she-zhi-kai-ji-qi-dong-dhcp-zi-dong-pei-zhi-nei-bu-wang-luo-ip-jiao-ben/"/>
      <url>/2019/12/06/ubuntu-server-18-04-she-zhi-kai-ji-qi-dong-dhcp-zi-dong-pei-zhi-nei-bu-wang-luo-ip-jiao-ben/</url>
      
        <content type="html"><![CDATA[<p>systemd 默认读取 /etc/systemd/system 下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。执行 ls /lib/systemd/system 你可以看到有很多启动脚本，其中就有我们需要的 rc.local.service<br>打开脚本内容</p><p><code>cat /lib/systemd/system/rc.local.service</code></p><p><code>#  This file is part of systemd.</code></p><p><code>#</code></p><p><code>#  systemd is free software; you can redistribute it and/or modify it</code></p><p><code>#  under the terms of the GNU Lesser General Public License as published by</code></p><p><code>#  the Free Software Foundation; either version 2.1 of the License, or</code></p><p><code>#  (at your option) any later version.</code></p><p><code># This unit gets pulled automatically into multi-user.target by</code></p><p><code># systemd-rc-local-generator if /etc/rc.local is executable.</code></p><p><code>[Unit]</code></p><p><code>Description=/etc/rc.local Compatibility</code></p><p><code>ConditionFileIsExecutable=/etc/rc.local</code></p><p><code>After=network.target</code></p><p><code>[Service]</code></p><p><code>Type=forking</code></p><p><code>ExecStart=/etc/rc.local start</code></p><p><code>TimeoutSec=0</code></p><p><code>RemainAfterExit=yes</code></p><p>一般正常的启动文件主要分成三部分<br><code>[Unit]</code> 段: 启动顺序与依赖关系<br><code>[Service] </code>段: 启动行为,如何启动，启动类型<br><code>[Install]</code> 段: 定义如何安装这个配置文件，即怎样做到开机启动<br>可以看出，/etc/rc.local 的启动顺序是在网络后面，但是显然它少了 Install 段，也就没有定义如何做到开机启动，所以显然这样配置是无效的。 因此我们就需要在后面帮他加上 <code>[Install]</code> 段:</p><p><code>[Install]  </code></p><p><code>WantedBy=multi-user.target</code></p><p><code>Alias=rc-local.service</code><br>`<br>这里需要注意一下，ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建，并且给该文件赋予可执行权限（否则文件不能执行，即开机不能运行，即开机自动启动会不成功）</p><p><code>sudo touch /etc/rc.local</code></p><p><code>chmod 755 /etc/rc.local </code></p><p>编辑rc.local，添加需要开机启动的任务（这里需要注意，一定要有#!/bin/bash，即指定解释此脚本的解释器shell的路径，否则未指定解释器会执行不成功）</p><p>#! /bin/sh</p><p>OUTGOING=<code>ping -c1 192.168.0.1 |grep 192.168.0.1 |grep -c ttl</code></p><p><code>if [ $OUTGOING -eq 0 ]</code></p><p><code>then</code></p><p><code>dhclient enp3s0f0 &gt;/tmp/enp3s0f0.log 2&gt;&amp;1</code></p><p><code>dhclient enp4s0f1 &gt;/tmp/enp4s0f1.log 2&gt;&amp;1</code></p><p><code>fi</code></p><p>PS:惠普服务器有四个网卡，我只用了两个，于是启动两个。网卡名称用ifconfig便可以查询，/tmp/enp4s0f1.log 2&gt;&amp;1 是记录运行日志，以便分析问题。<br>以下方法不推荐不靠谱。</p><p>1,新建个脚本文件new_service.sh</p><p><code>#!/bin/bash</code></p><p><code># command content</code></p><p><code>exit 0</code></p><p>2,设置权限</p><p><code>sudo chmod 755 new_service.sh</code></p><p>3,把脚本放置到启动目录下</p><p><code>sudo mv new_service.sh /etc/init.d/</code></p><p>4,将脚本添加到启动脚本</p><p>执行如下指令，在这里90表明一个优先级，越高表示执行的越晚</p><p><code>cd /etc/init.d/</code></p><p><code>sudo update-rc.d new_service.sh defaults 90</code></p><p>移除Ubuntu开机脚本</p><p><code>sudo update-rc.d -f new_service.sh remove</code></p><p>参考技术资料链接<br><a href="http://bbs.chinaunix.net/thread-1442726-1-1.html">http://bbs.chinaunix.net/thread-1442726-1-1.html</a><br><a href="https://www.jianshu.com/p/ba6d38ce9c1e">https://www.jianshu.com/p/ba6d38ce9c1e</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装sysv-rc-conf时，报了如下的错： E: Unable to locate package sysv-rc-conf</title>
      <link href="/2019/12/06/an-zhuang-sysv-rc-conf-shi-bao-liao-ru-xia-de-cuo-e-unable-to-locate-package-sysv-rc-conf/"/>
      <url>/2019/12/06/an-zhuang-sysv-rc-conf-shi-bao-liao-ru-xia-de-cuo-e-unable-to-locate-package-sysv-rc-conf/</url>
      
        <content type="html"><![CDATA[<p>这里我使用的是ubuntu-18.04.1版本，当我安装sysv-rc-conf时，报了如下的错：<br>E: Unable to locate package sysv-rc-conf（无法定位sysv-rc-conf包）<br><img src="http://image.lichongbing.com/static/d8df428d5ccc41e2c1a411e972a7eca0.png" alt="截屏2019-12-0612.24.43.png"><br>提供一个解决办法，如下：<br>第一步在软件源列表sources.list（该文本的位置在/etc/apt/sources.list）文件中的末尾添加如下内容：</p><p><code>deb http://cn.archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse</code></p><p><code>sudo vi /etc/apt/sources.list</code></p><p><img src="http://image.lichongbing.com/static/ee75213ec051a4462fa4ffcf748479a9.png" alt="截屏2019-12-0612.28.40.png"><br>第二步更新 apt-get update</p><p><code>sudo apt-get update</code></p><p>第三步更新 apt-get install sysv-rc-conf</p><p><code>apt-get install sysv-rc-conf</code></p><p><img src="http://image.lichongbing.com/static/4aa85d4f9ed41eeaa21b79a5d4ca7d65.png" alt="截屏2019-12-0612.33.11.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IPMI之Ipmitool工具</title>
      <link href="/2019/12/05/ipmi-zhi-ipmitool-gong-ju/"/>
      <url>/2019/12/05/ipmi-zhi-ipmitool-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>IPMI（Intelligent Platform Management Interface）</p><p>智能平台管理接口 (IPMI) 是一种开放标准的硬件管理接口规格，定义了嵌入式管理子系统进行通信的特定方法。IPMI 信息通过基板管理控制器 (BMC)（位于 IPMI 规格的硬件组件上）进行交流。使用低级硬件智能管理而不使用操作系统进行管理，具有两个主要优点： 首先，此配置允许进行带外服务器管理；其次，操作系统不必负担传输系统状态数据的任务。IPMI的核心是一个专用芯片/控制器(叫做服务器处理器或基板管理控制器(BMC))，其并不依赖于服务器的处理器、BIOS或操作系统来工作，可谓非常地独立，是一个单独在系统内运行的无代理管理子系统，</p><p>IPMI功能：</p><p>监控服务器的物理健康特征，如温度、电压、风扇工作状态、电源状态等；</p><p>可以通过串口、Modem以及Lan等远程环境管理服务器系统，如远程开关机；<br>IPMITOOL</p><p>ipmitool 是一种可用在 linux 系统下的命令行方式的 ipmi 平台管理工具，它支持 ipmi 1.5 规范（最新的规范为 ipmi 2.0），通过它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。使用：</p><p><code>ipmitool –I open sensor list #命令可以获取传感器中的各种监测值和该值的监测阈值，包括（CPU温度，电压，风扇转速，电源调制模块温度，电源电压等信息。</code></p><p><code>ipmitool –I open sensor thresh #设置ID值等于id的监测项的各种限制值。</code></p><p><code>ipmitool –I open chassis status #查看底盘状态，其中包括了底盘电源信息，底盘工作状态等</code></p><p><code>ipmitool –I open chassis restart_cause #查看上次系统重启的原因</code></p><p>#远程电源管理</p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 power off (硬关机，直接切断电源)</code></p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 power soft (软关机，即如同轻按一下开机按钮)</code></p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 power on (硬开机)</code></p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 power reset (硬重启)</code></p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 power status (获取当前电源状态)</code></p><p><code>ipmitool -I lanplus -H $oob_ip -U root -P 密码 chassis power cycle (注意power cycle 和power reset的区别在于前者从掉电到上电有１秒钟的间隔，而后者是很快上电)</code></p><p>#远程引导（当次生效）</p><p><code>ipmitool -I lan -H 服务器地址 -U root -P passwd chassis bootdev pxe (网络引导)</code></p><p><code>ipmitool -I lan -H 服务器地址 -U root -P passwd chassis bootdev disk （硬盘引导）</code></p><p><code>ipmitool -I lan -H 服务器地址 -U root -P passwd chassis bootdev cdrom （光驱引导）</code></p><p>#读取系统状态类</p><p><code>ipmitool sensor list  　#显示系统所有传感器列表</code></p><p><code>ipmitool fru list　　　#显示系统所有现场可替代器件的列表</code></p><p><code>ipmitool sdr list　　　#显示系统所有SDRRepository设备列表</code></p><p><code>ipmitool  pef list      #显示系统平台时间过滤的列表</code></p><p>#系统日志类</p><p><code>ipmitool sel elist　　　#显示所有系统事件日志</code></p><p><code>ipmitool sel clear　　　#删除所有系统时间日志</code></p><p><code>ipmitool sel delete ID     #删除第ID条SEL</code></p><p><code>ipmitool sel time get     　#显示当前BMC的时间</code></p><p><code>ipmitool sel time set  XXX  #设置当前BMC的时间</code></p><p>#启动设置类</p><p><code>ipmitool chassis bootdev bios  #重启后停在BIOS 菜单</code></p><p><code>ipmitool chassis bootdev pxe　#重启后从PXE启动</code></p><p>#系统相关的命令</p><p><code>ipmitool mc info       #显示BMC版本信息</code></p><p><code>ipmitool bmc reset cold      #BMC 热启动</code></p><p><code>ipmitool bmc reset warmBMC    #冷启动</code></p><p>#网络接口相关命令</p><p><code>ipmitool lan print 1    #显示channel1的网络配置信息</code></p><p><code>ipmitool lan set  1ipaddr 10.32.2.2    #设置channel1的IP地址</code></p><p><code>ipmitool lan  set 1 netmask 255.255.0.0   #设置channel1的netmask</code></p><p><code>ipmitool lan set 4 defgw ipaddr255.255.0.254    #设置channel4的网关</code></p><p><code>ipmitool lan set  2 defgw macaddr  &lt;macaddr&gt;　#设置channel2的网关mac address</code></p><p><code>ipmitool lan set 2 ipsrc dhcp         #设置channel2的ip 源在DHCP</code></p><p><code>ipmitool lan set 3 ipsrc static        #设置channel2的ip是静态获得的</code></p><p>#通道相关命令</p><p><code>ipmitool channel info　#显示系统默认channel</code></p><p><code>ipmitool channel  authcap channel-number privilege 　#修改通道的优先级别</code></p><p><code>ipmitool channel  getaccess channel-number user-id　#读取用户在通道上的权限</code></p><p><code>ipmitool channel setacccess channel-number  user-id callin=on ipmi=on link=onprivilege=5   #设置用户在通道上的权限</code></p><p>#看门狗相关命令</p><p><code>ipmitool  mc watchdog get　#读取当前看门狗的设置</code></p><p><code>ipmitool watchdog  off   #关掉看门狗</code></p><p><code>ipmitool watchdog reset 　#在最近设置的计数器的基础上重启看门狗</code></p><p>#用户管理相关命令</p><p><code>ipmitool user list chan-id   #显示某通道上的所有用户</code></p><p><code>ipmitool set password &lt;user id&gt;[&lt;password&gt;] #修改某用户的密码</code></p><p><code>ipmitool disable      &lt;user id&gt;　　#禁止掉某用户</code></p><p><code>ipmitool enable       &lt;user id&gt;　　#使能某用户</code></p><p><code>ipmitool priv         &lt;user id&gt; &lt;privilegelevel&gt; [&lt;channel number&gt;]　#修改某用户在某通道上的权限</code></p><p><code>ipmitool test         &lt;user id&gt; &lt;16|20&gt;[&lt;password]&gt;　#测试用户</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hp服务器利用iLO3 和ipmi 开启远程监控主机</title>
      <link href="/2019/12/05/hp-fu-wu-qi-li-yong-ilo3-he-ipmi-kai-qi-yuan-cheng-jian-kong-zhu-ji/"/>
      <url>/2019/12/05/hp-fu-wu-qi-li-yong-ilo3-he-ipmi-kai-qi-yuan-cheng-jian-kong-zhu-ji/</url>
      
        <content type="html"><![CDATA[<p>1） 首先，需要用一条网线连接iLO 网口和路由器，链接方式有两种：共享和专用，如下图。<br><img src="http://image.lichongbing.com/static/3dbc81b99c539bfe71dac6a93ef13271.png" alt="337661-20160524162913709-411927696.png"><br>2）其次，连好之后网口灯会变亮。然后进入bios配置ip地址，可以配成静态的，也可以配成dhcp动态分配的。配置后查看ip地址方法有：<br>(a)如果是用dhcp可以到服务器查看ip   (b)在开机启动窗口看到    (c)进入操作系统使用ipmitool查看<br>这里说一下方法(c)的操作步骤：<br>我的服务器安装是ubuntu</p><p><code>#apt-get install openipmi</code></p><p>加载ipmi驱动模块</p><p><code> modprobe ipmi_msghandler</code><br><code> modprobe ipmi_devintf</code><br><code> modprobe ipmi_si</code><br><code> modprobe ipmi_poweroff</code><br><code>modprobe ipmi_watchdog</code><br><code>linux下载ipmitool工具</code><br><code>wget https://downloads.sourceforge.net/project/ipmitool/ipmitool/1.8.18/ipmitool-1.8.18.tar.bz2</code></p><p><code>tar -jxf ipmitool-1.8.18.tar.bz2 </code></p><p><code>cd ipmitool-1.8.18</code></p><p><code>./configure --prefix=/usr/local/ipmi</code></p><p><code>make</code></p><p><code>make install</code></p><p><code>ln -sf /usr/local/ipmi/bin/ipmitool /usr/sbin/ipmitool</code></p><p>然后查看ip等信息，使用如下命令即会显示出来。<br><code>ipmitool lan print</code></p><p><img src="http://image.lichongbing.com/static/42a3206ad247240537da3fa0e1d9ce32.png" alt="截屏2019-12-0513.20.24.png"></p><p>3） 上述准备后，就可以远程访问服务器了。HP服务器默认用户名是Administrator,密码在服务器侧边的吊牌上有。如果看不到，也可以进入bios重新设置，位置在 User-&gt;Edit下。服务端配置好后以后，在远程电脑客户端也要安装ipmitool命令。<br>如果在局域网<br><code>ipmitool -I lanplus -U Administrator -H 192.168.0.104 chassis status</code></p><p><code>password:pxxxx</code></p><p><img src="http://image.lichongbing.com/static/2d03fbc2d73c34c930fda67af33687b3.png" alt="截屏2019-12-0513.17.33.png"></p><p>如果在外网，要在路由器开启DMZ主机</p><p><img src="http://image.lichongbing.com/static/153e8febe0c10c2b78ff83f704634cf1.png" alt="截屏2019-12-0513.13.57.png"></p><p><code>ipmitool -I lanplus -U UXxxx -H 182.138.155.139 chassis status</code></p><p><code>password:pxxxx</code></p><p><img src="http://image.lichongbing.com/static/b5a1e207579ab6b422a8b30a312c361c.png" alt="截屏2019-12-0513.15.25.png"></p><p>另外，除了用ipmitool命令行的方式外，还有如下远程访问方式：</p><pre><code>(a) ssh访问：ssh User@{YOUR DESIRED IP}(b) web访问： https://{YOUR DESIRED IP}/   (c) 手机app远程控制： hp.com/go/ilo/mobileapp</code></pre><p>经过实际使用，ipmitool命令最好用，推荐。    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac使用brew update无反应,更新慢解决办法</title>
      <link href="/2019/12/05/mac-shi-yong-brew-update-wu-fan-ying-geng-xin-man-jie-jue-ban-fa/"/>
      <url>/2019/12/05/mac-shi-yong-brew-update-wu-fan-ying-geng-xin-man-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<p>主要是资源访问太慢的原因造成的，替换一下镜像就可以了</p><p>有点耐心，大概5分钟就可以了，刚开始的时候terminal 只有顶部的title栏会变化，最后才会出现更新结果</p><p>使用中科大的镜像<br>替换默认源<br>第一步，替换brew.git</p><p><code>cd "$(brew --repo)"</code></p><p><code>git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></p><p>第二步：替换homebrew-core.git</p><p><code>cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</code></p><p><code>git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></p><p>最后使用</p><p><code>  brew update</code></p><p>进行更新，发现速度变的很快。替换镜像完成。<br><img src="http://image.lichongbing.com/static/a8c162d939b4e0943f11d02daa9d8f68.png" alt="2742735-fa6955d07c555130.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh 登录报错 packet_write_wait: Connection to x port 22: Broken pipe</title>
      <link href="/2019/12/04/ssh-deng-lu-bao-cuo-packet-write-wait-connection-to-x-port-22-broken-pipe/"/>
      <url>/2019/12/04/ssh-deng-lu-bao-cuo-packet-write-wait-connection-to-x-port-22-broken-pipe/</url>
      
        <content type="html"><![CDATA[<p>问题现象：</p><p>用 ssh 命令连接服务器之后，如果一段时间不操作，再次进入 Terminal 时会有一段时间没有响应，然后就出现错误提示：</p><p><code>Write failed: Broken pipe</code></p><p>只能重新用 ssh 命令进行连接。</p><p>解决方法</p><p>方法一：如果您有多台服务器，不想在每台服务器上设置，只需在客户端的 ~/.ssh/ 文件夹中添加 config 文件，并添加下面的配置：</p><p><code>ServerAliveInterval 60</code></p><p>方法二：如果您有多台个人管理服务器，不想在每个客户端进行设置，只需在服务器的 /etc/ssh/sshd_config 中添加如下的配置：</p><p><code>ClientAliveInterval 60</code></p><p>方法三：如果您只想让当前的 ssh 保持连接，可以使用以下的命令：</p><p><code>$ ssh -o ServerAliveInterval=60 user@sshserver</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu 18.04系统中启用SSH登录的方法</title>
      <link href="/2019/12/04/zai-ubuntu-18-04-xi-tong-zhong-qi-yong-ssh-deng-lu-de-fang-fa/"/>
      <url>/2019/12/04/zai-ubuntu-18-04-xi-tong-zhong-qi-yong-ssh-deng-lu-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>Secure Shell（SSH）是Linux系统管理中的经常要用到的一种远程访问技术。在Ubuntu 18.04系统仓库中，已经收录了同为开源的OpenSSH，我们可以用它来为系统开启SSH访问功能。</p><p><strong>一、打开终端，输入以下命令安装OpenSSH服务</strong>：</p><p>sudo apt-get install openssh-server</p><p><strong>二、步骤一是在当前系统增加SSH服务</strong>，<br>如果需要对SSH服务修改设置，可以用字处理工具编辑其配置文件，位于“ <code>/etc/ssh/sshd_config</code>”，比如用vim修改的命令就是：</p><p><code>sudo vim /etc/ssh/sshd_config</code></p><p>三、安装后，查看SSH有没有运行；</p><p><code>ps -ef|grep sshd</code></p><p><code>sudo service ssh status</code></p><p>如果有运行，如果上述结果中没有sshd出现，那么可能就是你的server端程序没有安装（Ubuntu 18.04 默认没有安装ssh server，只安装了ssh client），或者sshd服务没有启动<br>可以用server命令来启动</p><p><code>sudo service ssh start</code></p><p><strong>四、安装完成之后，就可以在客户端用系统用户来远程登录了。</strong></p><p>如果出现ssh无法远程连接ubuntu系统，提示</p><p><code>System is booting up. See pam_nologin(8)</code></p><p><code>Connection closing... Socket close.</code></p><p>无法远程登录！但是本地可以正常登录。</p><p>修改文件： /etc/pam.d/sshd</p><p>本地登陆<br><code>vim /etc/pam.d/sshd</code><br>注释account  required pam_nologin.so。即在这一行前边加#。保存即可</p><p>或者本地登录后，注释掉 pam_nologin.so 行，命令如下：</p><p><code>sudo sed -i -r 's/^(.*pam_nologin.so)/#\1/' /etc/pam.d/sshd</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频</title>
      <link href="/2019/12/03/shi-pin/"/>
      <url>/2019/12/03/shi-pin/</url>
      
        <content type="html"><![CDATA[<iframe style="width: 600px;height: 338px" frameborder="no" allowfullscreen="" mozallowfullscreen="" webkitallowfullscreen="" src="https://share.polyv.net/front/video/preview?vid=8f706f7188722ed5312b381facb4ebba_8"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu程序开机自启动</title>
      <link href="/2019/12/03/ubuntu-cheng-xu-kai-ji-zi-qi-dong/"/>
      <url>/2019/12/03/ubuntu-cheng-xu-kai-ji-zi-qi-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu程序开机自启动，嵌入到系统启动导引中"><a href="#ubuntu程序开机自启动，嵌入到系统启动导引中" class="headerlink" title="ubuntu程序开机自启动，嵌入到系统启动导引中"></a>ubuntu程序开机自启动，嵌入到系统启动导引中</h2><p><strong>ubuntu开机自启动思路</strong><br>ubuntu操作系统有很多运行级别，默认情况下runlevel为2，进入runlevel2时，会按照优先级执行/etc/rc2.d/目录下的所有可执行文件。操作系统的运行级别可以用过命令runlevel查看。如下：<br><code>li@li:~$ runlevel</code></p><p><code>N 2</code></p><h1 id="开机自启动的具体解决方法为："><a href="#开机自启动的具体解决方法为：" class="headerlink" title="开机自启动的具体解决方法为："></a>开机自启动的具体解决方法为：</h1><p><strong>1. 创建固定格式的的启动脚本并修改权限；</strong><br><code>your_bash.sh格式如下,其中，setsid ./your_bin &amp;中的setsid 和&amp; 符号是打开一个窗口让程序后台运行。</code></p><p><code>#!/bin/sh</code></p><p><code>### BEGIN INIT INFO</code></p><p><code># Provides:          HMI.sh</code></p><p><code># Required-start:    $local_fs $remote_fs $network $syslog</code></p><p><code># Required-Stop:     $local_fs $remote_fs $network $syslog</code></p><p><code># Default-Start:     2 3 4 5</code></p><p><code># Default-Stop:      0 1 6</code></p><p><code># Short-Description: starts the HMI.sh daemon</code></p><p><code># Description:       starts HMI.sh using start-stop-daemon</code></p><p><code>### END INIT INFO</code></p><p><code>#this is the command that you write to start your app</code></p><p><code>cd /home/your_file/</code></p><p><code>setsid ./your_bin &amp;</code></p><p><code>exit 0</code></p><p><strong>修改your_bash.sh的权限：</strong></p><p><code>chmod a+x your_bash.sh</code></p><p><strong>2. 将脚本移动到/etc/init.d/目录下</strong>；</p><p><code>sudo cp your_bash /etc/init.d/</code></p><p><strong>3. 运行runlevel查看系统运行级别，默认情况下为2;</strong></p><p><code>$ runlevel</code></p><p><code>N 2</code></p><p><strong>4. 进入对应的 /etc/rcx.d/文件夹</strong></p><p><code>$ cd /etc/rc2.d/</code></p><p><strong>5. 创建软连接，使进入这一runlevel时，自动运行脚本。</strong><br><code>sudo ln -vsf /etc/init.d/your_bash S90your_binStart</code><br><strong>6. 查看是否创建成功.</strong><br>若有返回则正常，可以sudo reboot，查看启动系统时程序是否自动运行。</p><p><code>ls -alh | grep S90your_binStart</code></p><p>软连接的命令有特定的要求，开头必须时’S’,后接2位数字，其值为5-99,表示程序的启动优先级，99为最后启动；最后是命令的字符串，可任意。<br><strong>7. 重启后，使用以下命令查看可执行文件是否正在运行。若有打印出进程信息，则OK 。</strong></p><p><code>ps -aux | grep your_bin | grep -v grep</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04三分钟设置开机启动服务</title>
      <link href="/2019/12/03/ubuntu18-04-san-fen-zhong-she-zhi-kai-ji-qi-dong-fu-wu/"/>
      <url>/2019/12/03/ubuntu18-04-san-fen-zhong-she-zhi-kai-ji-qi-dong-fu-wu/</url>
      
        <content type="html"><![CDATA[<p>本文链接：<a href="https://blog.csdn.net/idiot_qi/article/details/86527052">https://blog.csdn.net/idiot_qi/article/details/86527052</a><br>之前没接触过ubuntu，设置开机启动服务找了n多例子，都达到想要实现的效果，后来才发现是入了坑</p><p>先直接来一波标准的操作</p><p>**1. 复制命令（设置启动参数)&nbsp;**</p><p><code>vi /lib/systemd/system/rc.local.service&nbsp;</code></p><p>1.1.&nbsp;复制代码（下面代码按ESC再 :wq 回车）</p><p><code>[Unit]</code></p><p><code>Description=/etc/rc.local Compatibility</code></p><p><code>Documentation=man:systemd-rc-local-generator(8)</code></p><p><code>ConditionFileIsExecutable=/etc/rc.local</code></p><p><code>After=syslog.target network.target remote-fs.target nss-lookup.target</code></p><p><code>[Service]</code></p><p><code>Type=forking</code></p><p><code>ExecStart=/etc/rc.local start</code></p><p><code>TimeoutSec=0</code></p><p><code>RemainAfterExit=no</code></p><p><code>GuessMainPID=no</code></p><p><code>#这一段原文件没有，需要自己添加</code></p><p><code>[Install]</code></p><p><code>WantedBy=multi-user.target</code></p><p><code>Alias=rc-local.service</code></p><p><strong>2. 复制命令（设置软连接，开机启动回去/etc/……这个目录下去找文件）</strong></p><p><code>ln -s&nbsp;/lib/systemd/system/rc.local.service&nbsp;/etc/systemd/system/rc.local.service</code></p><p><strong>3.&nbsp; 复制命令（本身是没有rc.local文件的，后来上帝说要有它，就有了</strong>）</p><p><code>vi /etc/rc.local</code></p><p>3.1.&nbsp;复制代码（要开机启动的脚本、服务或者其他的操作都把命令写入这个脚本）</p><p><code>#!/bin/bash echo "hello" &gt; /etc/test.log /etc/init.d/webserver start exit 0 4. reboot</code></p><p>以上就是ubuntu18.04三分钟速成开机自启动，暂无其他详解，想知道更多详细的步骤请点此链接</p><p>开头说掉坑是关于ubuntu18.04图形界面的，ubuntu18.04开机需要使用非root用户登录，然而部署环境的时候全都是用root装的，登录的用户毛都没有，服务需要用到一些插件命令，然后死活都启动不了（这和不仔细真的一点关系都没有），当时被这个开机启动服务搞的晕头转向，才知道是每个用户之间有区别，这个坑掉的两辈子都难忘，以后</p><p>弃坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu添加开机自动启动程序的方法</title>
      <link href="/2019/12/03/ubuntu-tian-jia-kai-ji-zi-dong-qi-dong-cheng-xu-de-fang-fa/"/>
      <url>/2019/12/03/ubuntu-tian-jia-kai-ji-zi-dong-qi-dong-cheng-xu-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 开机启动时自动运行程序</strong></p><p>Linux加载后, 它将初始化硬件和设备驱动, 然后运行第一个进程init。init根据配置文件继续引导过程，启动其它进程。通常情况下，修改放置在</p><p><code>/etc/rc或</code></p><p><code>/etc/rc.d 或</code></p><p><code>/etc/rc?.d</code></p><p>目录下的脚本文件，可以使init自动启动其它程序。例如：编辑/etc/rc.d/rc.local 文件(该文件通常是系统最后启动的脚本)，在文件最末加上一行“xinit”或“startx”，可以在开机启动后直接进入X－Window。</p><p><strong>2. 登录时自动运行程序</strong></p><p>用户登录时，bash先自动执行系统管理员建立的全局登录script ：</p><p><code>/ect/profile</code></p><p>然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：</p><p><code>/.bash_profile、</code></p><p><code>/.bash_login、</code></p><p><code>/.profile，</code></p><p>但只执行最先找到的一个。因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat）。</p><p><strong>3. 退出登录时自动运行程序</strong></p><p>退出登录时，bash自动执行个人的退出登录脚本</p><p><code>/.bash_logout</code>。</p><p>例如，在/.bash_logout中加入命令“tar －cvzf c.source.tgz ＊.c”，则在每次退出登录时自动执行 “tar” 命令备份 ＊.c 文件。</p><p><strong>4. 定期自动运行程序</strong></p><p>Linux有一个称为crond的守护程序，主要功能是周期性地检查 /var/spool/cron目录下的一组命令文件的内容，并在设定的时间执行这些文件中的命令。用户可以通过crontab 命令来建立、修改、删除这些命令文件。</p><p>例如，建立文件crondFile，内容为“00 9 23 Jan ＊ HappyBirthday”，运行“crontabcronFile”命令后，每当元月23日上午9:00系统自动执行“HappyBirthday”的程序（“＊”表示不管当天是星期几）。</p><p><strong>5. 定时自动运行程序一次</strong></p><p>定时执行命令at 与crond 类似（但它只执行一次）：命令在给定的时间执行，但不自动重复。at命令的一般格式为：<code>at [ －f file ] time</code> ，在指定的时间执行file文件中所给出的所有命令。也可直接从键盘输入命令：</p><p><code>＄ at 12:00</code></p><p><code>at&gt;mailto Roger －s ″Have a lunch″ &lt; plan.txt</code></p><p><code>at&gt;Ctr－D</code></p><p><code>Job 1 at 2000－11－09 12:00</code></p><p>2000－11－09 12:00时候自动发一标题为“Have a lunch”，内容为plan.txt文件内容的邮件给Roger.</p><p>#Ubuntu下添加开机启动脚本</p><p>Ubuntu开机之后会执行/etc/rc.local文件中的脚本，所以我们可以直接在/etc/rc.local中添加启动脚本。</p><p>当然要添加到语句：exit 0 前面才行。</p><p>如：</p><p><code>sudo vi /etc/rc.local</code></p><p>然后在 exit 0 前面添加好脚本代码。</p><p>后续有空再研究下添加一个Ubuntu的开机启动服务看看。</p><p>如果要添加为开机启动执行的脚本文件，可先将脚本复制或者软连接到/etc/init.d/目录下，然后用：<code>update-rc.d xxx defaults NN</code>命令(NN为启动顺序)，将脚本添加到初始化执行的队列中去。</p><p>注意如果脚本需要用到网络，则NN需设置一个比较大的数字，如98 。</p><p><strong>二、ubuntu下设置程序开机自启动的几种方法</strong></p><p>1、方法一：</p><p>这种也是最常用的一种 rcconf：</p><p><code>sudo apt-get install rcconf</code></p><p>root下运行: <code>rcconf</code></p><p>功能更全的：<code>sysv-rc-conf</code></p><p><code>sudo apt-get install sysv-rc-conf</code></p><p>运行：<code>sysv-rc-conf</code></p><p>这个改起来很简单，自己试一下就知道了.</p><p>2、方法二：</p><p>直接改/etc/rc0.d ~ /etc/rc6.d和/etc/rcS.d下的东西，S开头的表示启动，K开头的表示不启动，例如：想关闭vsftpd的开机自动启动，只需sudo mv /etc/rc2.d/S20vsftpd /etc/rc2.d/K20vsftpd就可以了。</p><p>这条命令的用意就是利用mv的重命名功能。</p><p>3、方法三：</p><p>chkconfig,这种方法在redhat,Debian里面比较常用,在fedora和ubuntu里面用方法1比较简单,但是学习一下这种方法也是不错的。</p><p>但在ubuntu下这个命令没有redhat好用,老是出错.</p><p>算了,还是直接看一下redhat里面chkconfig的用法吧.</p><p>（1）<code>chkconfig --level [0123456] [service name] [on|off]</code></p><p>chkconfig –level 23 dhcp3-server off —-设定dhcp server服务在level2,3下关闭.</p><p>（2）chkconfig –list 查看服务的自动开启状态</p><p>（3）chkconfig –add 增加一个服务给chkconfig来管理,但是该服务必须在/etc/init.d内。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu eth0不能自动获取地址 无法上网 临时解决</title>
      <link href="/2019/12/03/ubuntu-eth0-bu-neng-zi-dong-huo-qu-di-zhi-wu-fa-shang-wang-lin-shi-jie-jue/"/>
      <url>/2019/12/03/ubuntu-eth0-bu-neng-zi-dong-huo-qu-di-zhi-wu-fa-shang-wang-lin-shi-jie-jue/</url>
      
        <content type="html"><![CDATA[<p><code>ifconfig之后显示eth0，但是没有显示静态IP地址，即无inet、地址、广播、掩码。</code><br>解决办法临时<br>` 1. 先用sudo dhclient eth0更新IP地址</p><ol start="2"><li>然后运行sudo ifconfig eth0</li></ol><p>3.reboot<br>`</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu环境下挂载新硬盘</title>
      <link href="/2019/12/03/ubuntu-huan-jing-xia-gua-zai-xin-ying-pan/"/>
      <url>/2019/12/03/ubuntu-huan-jing-xia-gua-zai-xin-ying-pan/</url>
      
        <content type="html"><![CDATA[<p><strong>一、硬盘分区 | Hard disk add new partition</strong></p><p>1、显示硬盘及所属分区情况。在终端窗口中输入如下命令：</p><p><code>sudo fdisk -l</code></p><p>显示当前的硬盘及所属分区的情况。如下图所示：<br>系统提示：DIsk /dev/sdb doesn’t contain a valid partition table。</p><p><img src="http://image.lichongbing.com/static/137dc9e6b4c186bdaea45cbba0cf3236.jpeg" alt="1522291142953258.gif.jpeg"></p><p>２、对硬盘进行分区。在终端窗口中输入如下命令：</p><p><code>sudo fdisk /dev/sdb</code></p><p>如下图所示：<br>在Command (m for help)提示符后面输入m显示一个帮助菜单。</p><p><img src="http://image.lichongbing.com/static/537abe5a42c7d259452e0d8784504bc2.jpeg" alt="1522291150631562.gif.jpeg"></p><p>在Command (m for help)提示符后面输入n，执行 add a new partition 指令给硬盘增加一个新分区。<br>出现Command action时，输入e，指定分区为扩展分区（extended）。<br>出现Partition number(1-4)时，输入１表示只分一个区。<br>后续指定起启柱面（cylinder）号完成分区。</p><p><img src="http://image.lichongbing.com/static/e3a77b51a7baa6b1ed39592e8539f8db.jpeg" alt="1522291159502739.gif.jpeg"></p><p>在Command (m for help)提示符后面输入p，显示分区表。<br>系统提示如下：<br><code>Device Boot                 Start                End                   Blocks          Id             System /dev/sdb1                           1            26108           209712478+           5          Extended</code></p><p><img src="http://image.lichongbing.com/static/77514de8b947bc61afe9b482d895828c.jpeg" alt="1522291166220638.gif.jpeg"></p><p>在Command (m for help)提示符后面输入w，保存分区表。<br>系统提示：The partition table has been altered!</p><p><img src="http://image.lichongbing.com/static/9fa7f55a36d671e3f5aab55b4838a32c.jpeg" alt="1522291175167083.gif.jpeg"></p><p>在终端窗口中输入如下命令：</p><p><code>sudo fdisk -l</code></p><p>如下图所示：<br>系统已经识别了硬盘 /dev/sdb 的分区。</p><p><img src="http://image.lichongbing.com/static/e0e7bf6c99b2d4e5850ae8fed6aec18d.jpeg" alt="1522291184648789.gif.jpeg"></p><p><strong>二、硬盘格式化 | Format hard disk</strong></p><p>1、显示硬盘及所属分区情况。在终端窗口中输入如下命令：</p><p><code>sudo mkfs -t ext4 /dev/sdb</code></p><p>说明：<br>-t ext4 表示将分区格式化成ext4文件系统类型。</p><p><img src="http://image.lichongbing.com/static/54abf081c9aee474c625f89c35f510ef.jpeg" alt="1522284674305157.png.jpeg"></p><p><strong>三、挂载硬盘分区 | Mount hard disk partition</strong></p><p>1、显示硬盘挂载情况。在终端窗口中输入如下命令：</p><p><code>df -l</code></p><p>新硬盘分区没有挂载，无法进入和查看。</p><p>在终端窗口中输入如下命令：</p><p><code>sudo mount -t ext4 /dev/sdb /devdata</code></p><p>再次在终端窗口中输入如下命令：</p><p><code>df -l</code></p><p>新硬盘分区已经挂载，如下图最下面的红色方框内容。</p><p><img src="http://image.lichongbing.com/static/c8fedd9dae230f52be8bc11c01acc26f.jpeg" alt="1522284851211104.png.jpeg"><br>２、配置硬盘在系统启动自动挂载。在文件 /etc/fstab 中加入如下配置：</p><p>/dev/sdb     /devdata    ext4     defaults       0 0</p><p><img src="http://image.lichongbing.com/static/89239a3695713ff977e1051bd62d06d6.png" alt="1522306284208399.png"></p><p>至此ubuntu硬盘的挂载就完成了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>惠普proliant服务器raid卡配置过程详解</title>
      <link href="/2019/12/03/hui-pu-proliant-fu-wu-qi-raid-qia-pei-zhi-guo-cheng-xiang-jie/"/>
      <url>/2019/12/03/hui-pu-proliant-fu-wu-qi-raid-qia-pei-zhi-guo-cheng-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#惠普ProLiant服务器Raid卡配置过程详解<br>Raid(Redundant Array of Independent Disk)独立冗余磁盘阵列，就是将多个硬盘通过Raid控制器整合成虚拟的单个大容量的硬盘。Raid是服务器数据容错模式中采用最普遍的一种，通常都是通过外加Raid卡的方式来实现。Raid的级别有很多种，而各种级别所涉及的原理也不尽相同，在此不再赘述，本文将以惠普642 raid卡为例，详细介绍阵列卡的配置过程。<br>1.开机自检，我们可以读到Raid卡的相关信息:Smart Array 642 Controller，缓存为64MB<br><img src="http://image.lichongbing.com/static/7c6faeb5d74af464c55ee3736aea62fb.png" alt="截屏2019-12-0316.57.15.png"><br>2.上面提示信息说明，需要按 F8 进入阵列卡的配置程序。可以看到机器阵列卡的配置程序有4个初始选项:<br><img src="http://image.lichongbing.com/static/68a3041f2c12f46380307892875bf2b1.png" alt="截屏2019-12-0316.57.27.png"><br>Create Logical Drive 创建阵列<br>View Logical Driver 查看阵列<br>Delete Logical Driver 删除阵列<br>Select as Boot Controller 将阵列卡设置为机器的第一个引导设备<br>注意:最后一个选项将阵列卡设置为机器的第一个引导设备。这样设置后，重新启动机器，就会没有该选项。<br>3. 选择”Select as Boot Controller”,出现红色的警告信息。若选择此选项，服务器的第一个引导设备就会变为阵列卡(SmartArray 642)，按”F8”进行确认。<br>   <img src="http://image.lichongbing.com/static/482a6e4dcfc9b79646e41b1cc943db7f.png" alt="截屏2019-12-0316.57.39.png"><br>4. 按完”F8”，确认之后，提示:必须重新启动服务器，才会生效。<br>   <img src="http://image.lichongbing.com/static/810e9ec6c028108b1ed15235a98faa8a.png" alt="截屏2019-12-0316.57.48.png"><br>5. 按”ESC”之后，返回到主界面，只有三个选项。<br>   <img src="http://image.lichongbing.com/static/36ab1c425975a9ef67b6da81cfe9a5bc.png" alt="截屏2019-12-0316.57.59.png"><br>6. 进入”Create Logical Drive”的界面,可以看到4部分的信息。<br>   Available Physical Drives 列出来连接在此阵列卡上的硬盘。图示的硬盘在SCSI PORT 2， ID为0，硬盘的容量为 36.4 GB。<br>   Raid Configurations 有3种选择 RAID 5，RAID 1 (1+0)，RAID 0。图示的机器只有一个硬盘，默认为RAID 0。<br>   Spare 把所选择的硬盘作为热备的硬盘(占用一个硬盘的空间)<br>   Maximum Boot partition 最大引导分区的设置，可以有两个选项，Disable (4G maximum) 默认和 Enable (8G maxiumu)。(现在一般选8G)<br>   <img src="http://image.lichongbing.com/static/f647baace2f0a0d181be14f07c890af2.png" alt="截屏2019-12-0317.06.35.png"><br>7. 按回车进行确认，提示已经创建一个RAID 0的阵列，逻辑盘的大小为<br>   33.9GB，按 F8 进行保存即可。<br>   <img src="http://image.lichongbing.com/static/4ecf0b0fc1ebb710e36a17a23ef3ede2.png" alt="截屏2019-12-0316.58.25.png"><br>8. 按”F8”进行保存。<br>   <img src="http://image.lichongbing.com/static/4a171d48eeef759706dacb3787ccd4a2.png" alt="截屏2019-12-0316.58.35.png"><br>9. 提示配置已经保存，按回车。<br>   <img src="http://image.lichongbing.com/static/f757a2504368ff12a51935a5a2e12049.png" alt="截屏2019-12-0316.58.46.png"><br>10. 进入”View Logical Drive” 界面，可以看到刚才配置的阵列,状态是<br>    “OK”，RAID 的级别是 RAID 0 ，大小为 33.9 GB。<br>    <img src="http://image.lichongbing.com/static/740a99731b97c83e4f59f520ab631233.png" alt="截屏2019-12-0316.58.57.png"><br>11. 按回车，查看详细信息。<br>    <img src="http://image.lichongbing.com/static/1a8d64481810f32d2f986ad7fb67fce6.png" alt="截屏2019-12-0316.59.12.png"><br>    12.选择第三个选项”Delete Logical Drive”，进入删除阵列的界面。<br>    <img src="http://image.lichongbing.com/static/b0f41cf274b60e8cd48b3ea67b93b03e.png" alt="截屏2019-12-0316.59.23.png"><br>13. 按”F8”，把刚才设置的阵列删除掉。出现红色警告提示信息，提示: 删除该阵列，将把阵列上的所有数据都删掉。<br>    注意:如果有数据，一定要先备份数据，再去删掉阵列。<br>    <img src="http://image.lichongbing.com/static/9a96bdbe22e20868433b4280b960102c.png" alt="截屏2019-12-0317.07.10.png"><br>14. 按”F3”，进行确认即可，提示保存配置。<br>    <img src="http://image.lichongbing.com/static/512c886e35f33f87978de0eb6629190b.png" alt="截屏2019-12-0316.59.41.png"><br>15. 提示已经保存。<br>    <img src="http://image.lichongbing.com/static/12ea5a4c88d833a4fe4aaa1cfb7f39a6.png" alt="截屏2019-12-0316.59.49.png"><br>16. 再次进入”View Logical Drive” ,提示没有可用的逻辑盘。<br>    <img src="http://image.lichongbing.com/static/0324d9a672a16356f03b500541862089.png" alt="截屏2019-12-0316.59.57.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat多域名配置(多个项目共用80端口)</title>
      <link href="/2019/12/03/tomcat-duo-yu-ming-pei-zhi-duo-ge-xiang-mu-gong-yong-80-duan-kou/"/>
      <url>/2019/12/03/tomcat-duo-yu-ming-pei-zhi-duo-ge-xiang-mu-gong-yong-80-duan-kou/</url>
      
        <content type="html"><![CDATA[<p>#Tomcat多域名配置(多个项目共用80端口)</p><p>准备四个已经备案的域名<br>首先保证三个项目正常部署在同一个tomcat里，默认端口号是都是80，这时候访问的url均为<a href="http://ip地址/%E5%90%84%E8%87%AA%E9%A1%B9%E7%9B%AE%E5%90%8D/XXX%EF%BC%8C%E9%A1%B9%E7%9B%AE%E5%85%A8%E9%83%A8%E4%BD%8D%E4%BA%8Ewebapps%E4%B8%8B%E9%9D%A2%E3%80%82">http://IP地址/各自项目名/XXX，项目全部位于webapps下面。</a><br>然后修改tomcat配置，将原本的host配置注释掉，新增四个host，<br><code>&lt;Host name="域名" &nbsp;appBase="webapps" &nbsp;unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;Context path="" docBase="项目名" debug="0" reloadable="true"/&gt;&nbsp; &nbsp; &nbsp; &nbsp; &lt;/Host&gt;</code></p><p>配置如下：<br><code>   &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;Host name="www.mfskjyx.com"  appBase="webapps" unpackWARs="true" autoDeploy="true" debug="0" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="" docBase="jingrong" /&gt; &lt;/Host&gt; &lt;Host name="www.cdmfskj.com"  appBase="webapps" unpackWARs="true" autoDeploy="true" debug="0" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="" docBase="mofa" /&gt; &lt;/Host&gt; &lt;Host name="www.cdqbsw.com"  appBase="webapps" unpackWARs="true" autoDeploy="true" debug="0" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="" docBase="qibugongshi" /&gt; &lt;/Host&gt; &lt;Host name="www.cdnxzh.com"  appBase="webapps" unpackWARs="true" autoDeploy="true" debug="0" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="" docBase="zhuangxiu" /&gt; &lt;/Host&gt;</code></p><p>三个host配置的name对应三个域名，下面的context节点的docBase分别对应三个项目路径，lilux下直接对应项目名即可。<br>最后重启tomcat。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat多项目共用80端口，不同域名映射不同项目</title>
      <link href="/2019/12/03/tomcat-duo-xiang-mu-gong-yong-80-duan-kou-bu-tong-yu-ming-ying-she-bu-tong-xiang-mu/"/>
      <url>/2019/12/03/tomcat-duo-xiang-mu-gong-yong-80-duan-kou-bu-tong-yu-ming-ying-she-bu-tong-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>#tomcat多项目共用80端口，不同域名映射不同项目<br>准备工作：</p><ul><li>jdk1.8（配好环境变量）</li><li>tomcat8<br>在tomcat中添加项目</li></ul><p>在webapps中添加3个项目，这3个都是很简单的项目，只有index.html和web.xml。</p><p>index.html只有一个h1标签，里面写了web1、web2和web3用于区分3个项目</p><p><img src="http://image.lichongbing.com/static/2438a33a80233c4984e0e7cb1ff4e830.png" alt="20180509111548344.png"></p><p><strong>index.html</strong><br>`</p>    <meta charset="UTF-8">    <title>ok</title><h1>web1</h1><p><code>**web.xml**</code><!--?xml version="1.0" encoding="UTF-8"?--><br><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaeehttp://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"></web-app></p><p>`<br><strong>配置tomcat</strong></p><p>打开tomcat_home/conf/server.xml，修改端口为80，添加3个host映射。</p><p>这里需要注意的是，tomcat原来有一个host，新添加host要放在该host的前面。为方便查看，已删除掉无用注释。<br>`<!--?xml version="1.0" encoding="UTF-8"?--><br><server port="8005" shutdown="SHUTDOWN"><br><listener classname="org.apache.catalina.startup.VersionLoggerListener"><br><listener classname="org.apache.catalina.core.AprLifecycleListener" sslengine="on"><br><listener classname="org.apache.catalina.core.JreMemoryLeakPreventionListener"><br><listener classname="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"><br><listener classname="org.apache.catalina.core.ThreadLocalLeakPreventionListener"><br><globalnamingresources><br><resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml"><br></resource></globalnamingresources><br><service name="Catalina"></service></listener></listener></listener></listener></listener></server></p><!-- 修改端口 --><p><connector port="80" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"></connector></p><pre><code>&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;    &lt;Engine name="Catalina" defaultHost="localhost"&gt;  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"           resourceName="UserDatabase"/&gt;  &lt;/Realm&gt;    &lt;!--  添加3个域名映射 --&gt;    &lt;Host name="web1.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;        &lt;Context path="" docBase="web1" /&gt;    &lt;/Host&gt;    &lt;Host name="web2.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;        &lt;Context path="" docBase="web2" /&gt;    &lt;/Host&gt;    &lt;Host name="web3.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;        &lt;Context path="" docBase="web3" /&gt;    &lt;/Host&gt;    &lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"           prefix="localhost_access_log" suffix=".txt"           pattern="%h %l %u %t "%r" %s %b" /&gt;  &lt;/Host&gt;&lt;/Engine&gt;</code></pre>  <p>`<br><strong>配置host</strong><br>##本地测时配置</p><p><code>vi /etc/hosts</code></p><p>在后面添加3个域名<br><code>127.0.0.1 web1.com 127.0.0.1 web2.com 127.0.0.1 web3.com</code><br>启动项目后测试<br><img src="http://image.lichongbing.com/static/e312a6018dd952237f1e7c4e506b5ca8.png" alt="20180509113611431.png"></p><p><img src="http://image.lichongbing.com/static/88b695c8f2c4ddd9a16b020d3340e0d3.png" alt="20180509113553425.png"></p><p><img src="http://image.lichongbing.com/static/7561e3df4c4d65d81a3a70348c7b6428.png" alt="2018050911363035.png"><br>##服务器时配置</p><p><code>127.0.0.1 xxxx</code></p><p>xxx是服务器名称</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot项目独立部署到tomcat</title>
      <link href="/2019/12/03/springboot-xiang-mu-du-li-bu-shu-dao-tomcat/"/>
      <url>/2019/12/03/springboot-xiang-mu-du-li-bu-shu-dao-tomcat/</url>
      
        <content type="html"><![CDATA[<p>springboot内置了tomcat，所以springboot项目在开发环境中一般直接以jar包的形式进行运行，但在生产环境中还是建议使用tomcat来进行部署，独立部署到tomcat中需要注意以下几个事项：</p><ul><li>1.设置打包形式为war包：</li></ul><p><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p><ul><li>2.配置springboot内嵌tomcat的scope属性为provide：</li></ul><p><code>&lt;dependency&gt;</code></p><p><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code></p><p><code>&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</code></p><p><code>&lt;scope&gt;provided&lt;/scope&gt;</code></p><p><code>&lt;/dependency&gt;</code></p><ul><li>3.添加tomcat依赖：</li></ul><p><code>&lt;dependency&gt;</code></p><p><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</code></p><p><code>&lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;</code></p><p><code>&lt;/dependency&gt;</code><br>`</p><ul><li>4.改造启动类：</li></ul><p>主要继承SpringBootServletInitializer且覆写configure方法，如下：</p><p>`@SpringBootApplication</p><p>public class SpringbootApplcation extends SpringBootServletInitializer {</p><p>public static void main(String[] args) {</p><p>SpringApplication.run(SpringbootApplcation.class,args) ;</p><p>}`</p><p>`@Override</p><p>protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {</p><p>// 注意这里要指向原先用main方法执行的Application启动类</p><p>return builder.sources(SpringbootApplcation.class);</p><p>}`</p><p>}</p><ul><li>5.打包发布，在项目根目录执行maven命令：</li></ul><p><code>mvn clean package</code></p><ul><li><p>6.将war包发布到tomcat即可。</p></li><li><p>7.tomcat多个springboot项目启动失败<br>信息报错<br><code>Caused by: org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean [com.alibaba.druid.filter.stat.StatFilter@4178572] with key 'statFilter</code></p></li></ul><p>解决办法</p><p>除了第一个springboot项目以外，需要在其他springboot项目的application.properties配置文件中 加上下面这句配置</p><p><code>spring.jmx.enabled=false</code></p><ul><li>8.建议在本地部署调试完，删除webapps下war包，tomcat整个文件传输到服务器发布。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat热加载的配置方式</title>
      <link href="/2019/12/03/tomcat-re-jia-zai-de-pei-zhi-fang-shi/"/>
      <url>/2019/12/03/tomcat-re-jia-zai-de-pei-zhi-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Tomcat热加载配置"><a href="#一、Tomcat热加载配置" class="headerlink" title="一、Tomcat热加载配置"></a>一、Tomcat热加载配置</h1><p>在工程管理目录找到自己的server下的server.xml修改部署项目<br><code>&lt;Context docBase="XXAPP" path="/XXAPP" reloadable="false" crossContext="true" source="org.eclipse.jst.jee.server:XXAPP"/&gt;&lt;/Host&gt; </code><br>如上代码，设置reloadable=”false” crossContext=”true”，那么就可实现每次保存文件的时候，自动部署到服务器中，并且不会重新启动。</p><p>热加载的方式必须保证eclipse以debug模式启动项目才可以用！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>心语20191121</title>
      <link href="/2019/11/21/xin-yu-20191121/"/>
      <url>/2019/11/21/xin-yu-20191121/</url>
      
        <content type="html"><![CDATA[<h2 id="一天恍若短暂的一生，一生好比漫长的一天。用一生的觉悟认真过好每一天，用一天的心境洒脱度过这一生。"><a href="#一天恍若短暂的一生，一生好比漫长的一天。用一生的觉悟认真过好每一天，用一天的心境洒脱度过这一生。" class="headerlink" title="一天恍若短暂的一生，一生好比漫长的一天。用一生的觉悟认真过好每一天，用一天的心境洒脱度过这一生。"></a>一天恍若短暂的一生，一生好比漫长的一天。用一生的觉悟认真过好每一天，用一天的心境洒脱度过这一生。</h2><h2 id="温暖人心的话，就算是简单的言辞，也会一直一直在心中回响。"><a href="#温暖人心的话，就算是简单的言辞，也会一直一直在心中回响。" class="headerlink" title="温暖人心的话，就算是简单的言辞，也会一直一直在心中回响。"></a>温暖人心的话，就算是简单的言辞，也会一直一直在心中回响。</h2><h2 id="要得到幸福，就得反复尝试失败。"><a href="#要得到幸福，就得反复尝试失败。" class="headerlink" title="要得到幸福，就得反复尝试失败。"></a>要得到幸福，就得反复尝试失败。</h2><h2 id="认真是什么呢？认真就是不会让人后悔的东西。"><a href="#认真是什么呢？认真就是不会让人后悔的东西。" class="headerlink" title="认真是什么呢？认真就是不会让人后悔的东西。"></a>认真是什么呢？认真就是不会让人后悔的东西。</h2><h2 id="明天的我要战胜今天的自己。"><a href="#明天的我要战胜今天的自己。" class="headerlink" title="明天的我要战胜今天的自己。"></a>明天的我要战胜今天的自己。</h2><h2 id="想要实现梦想，就要始终保持热爱。"><a href="#想要实现梦想，就要始终保持热爱。" class="headerlink" title="想要实现梦想，就要始终保持热爱。"></a>想要实现梦想，就要始终保持热爱。</h2><h2 id="比起成为花，请成为让花盛开的土壤。"><a href="#比起成为花，请成为让花盛开的土壤。" class="headerlink" title="比起成为花，请成为让花盛开的土壤。"></a>比起成为花，请成为让花盛开的土壤。</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算命广告</title>
      <link href="/2019/11/21/suan-ming-guang-gao/"/>
      <url>/2019/11/21/suan-ming-guang-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="看相"><a href="#看相" class="headerlink" title="看相"></a>看相</h1><h1 id="算命"><a href="#算命" class="headerlink" title="算命"></a>算命</h1><h1 id="奇门遁甲"><a href="#奇门遁甲" class="headerlink" title="奇门遁甲"></a>奇门遁甲</h1><h1 id="易断天机"><a href="#易断天机" class="headerlink" title="易断天机"></a>易断天机</h1><h1 id="断吉断凶"><a href="#断吉断凶" class="headerlink" title="断吉断凶"></a>断吉断凶</h1><h1 id="事事有准"><a href="#事事有准" class="headerlink" title="事事有准"></a>事事有准</h1><h1 id="算卦传奇"><a href="#算卦传奇" class="headerlink" title="算卦传奇"></a>算卦传奇</h1><h1 id="风水布局"><a href="#风水布局" class="headerlink" title="风水布局"></a>风水布局</h1><h1 id="八字合婚"><a href="#八字合婚" class="headerlink" title="八字合婚"></a>八字合婚</h1><h1 id="迁房吉日"><a href="#迁房吉日" class="headerlink" title="迁房吉日"></a>迁房吉日</h1><h1 id="结婚择期"><a href="#结婚择期" class="headerlink" title="结婚择期"></a>结婚择期</h1><h1 id="生男生女"><a href="#生男生女" class="headerlink" title="生男生女"></a>生男生女</h1><h1 id="牌运输赢"><a href="#牌运输赢" class="headerlink" title="牌运输赢"></a>牌运输赢</h1><h1 id="官司输赢"><a href="#官司输赢" class="headerlink" title="官司输赢"></a>官司输赢</h1><h1 id="升学考试"><a href="#升学考试" class="headerlink" title="升学考试"></a>升学考试</h1><p>一 请顾客先在甲方找出定位姓氏<br>二 然后在乙方找出定位姓氏</p><p>不用开口，我可以算出你贵姓和你人生</p><p>走过路过，不要错过，错过后会有期</p><p>微信   电话    李兴余<br>网址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2017年视频整理</title>
      <link href="/2019/11/20/2017-nian-shi-pin-zheng-li/"/>
      <url>/2019/11/20/2017-nian-shi-pin-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="地铁2号线拍摄于2017年元旦"><a href="#地铁2号线拍摄于2017年元旦" class="headerlink" title="地铁2号线拍摄于2017年元旦"></a>地铁2号线拍摄于2017年元旦</h1><iframe src="https://1253926329.vod2.myqcloud.com/vod-player/1253926329/5285890796668115625/tcplayer/console/vod-player.html?autoplay=true&amp;width=1280&amp;height=720" frameborder="0" scrolling="no" width="670" height="428" allowfullscreen=""> </iframe><h1 id="郫县百伦爱达乐蛋糕店2017年4月"><a href="#郫县百伦爱达乐蛋糕店2017年4月" class="headerlink" title="郫县百伦爱达乐蛋糕店2017年4月"></a>郫县百伦爱达乐蛋糕店2017年4月</h1><iframe src="https://1253926329.vod2.myqcloud.com/vod-player/1253926329/5285890796668116693/tcplayer/console/vod-player.html?autoplay=true&amp;width=1280&amp;height=720" frameborder="0" scrolling="no" width="670" height="428" allowfullscreen=""> </iframe><h1 id="2017年6月视频记录的一天"><a href="#2017年6月视频记录的一天" class="headerlink" title="2017年6月视频记录的一天"></a>2017年6月视频记录的一天</h1><iframe src="https://1253926329.vod2.myqcloud.com/vod-player/1253926329/5285890796667623029/tcplayer/console/vod-player.html?autoplay=false&amp;width=1280&amp;height=720" frameborder="0" scrolling="no" width="670" height="428" allowfullscreen=""> </iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Earthsong</title>
      <link href="/2019/11/16/earthsong/"/>
      <url>/2019/11/16/earthsong/</url>
      
        <content type="html"><![CDATA[<p>Earthsong<br>Karunesh<br>从辽远璀璨的太古星空走来 穿越广袤而神秘的原始丛林 淌过万古奔流永不止息的长河 每一个月落日升 每一次栉风沐雨 每一幕生死一线 眼前又是一片烈日炙烤下的金色沙海 连绵不尽的沙浪如有生命般翻滚波荡 脚步停顿了一瞬 又继续前进 向那海天交接处 向未知的远方 向着某种超越了生命的意义 义无反顾原始部落的人声，淳朴、简单，发出了对生命的渴望。这曲将地球村的远山丛林江河湖海、小溪瀑布海市蜃楼 、飞禽走兽和人声鼎沸，用惊天动地的天音好似万丈清泉直泻而来，杀手鼓&amp;地震式的低频， 天与地共鸣振幅和悠扬的笛声传遍太空，Earthsong 地球灵韵 Ancient Secrets 远古的秘密在这里飘逸 …震撼的音乐给人们的心灵带来的激动伴随旋律翱翔。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&amp;id=18941339&amp;auto=1&amp;height=32"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大学时期视频珍贵大全</title>
      <link href="/2019/11/15/da-xue-shi-qi-shi-pin-zhen-gui-da-quan/"/>
      <url>/2019/11/15/da-xue-shi-qi-shi-pin-zhen-gui-da-quan/</url>
      
        <content type="html"><![CDATA[<p>今天我一个大学朋友给我来电话，问我有没有大学时期的视频，于是我借个机会整理出来。这些资源均可以下载。</p><p>大学里那些人和事<br>电子相册，用中兴手机拍摄</p><iframe height="288" width="510" src="https://v.qq.com/txp/iframe/player.html?vid=l1016lw62c5" allowfullscreen="true"></iframe><p>这是老罗炒菜的视频</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjIyODMzNjA2NA==" frameborder="0" 'allowfullscreen'=""></iframe><p>采访陈凯学长的视频-最纠结的事情</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjIxMzU1MTAxNg==" frameborder="0" 'allowfullscreen'=""></iframe><p>2013年元旦，我们聚餐吃饭</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjIwMzE4NDE1Ng==" frameborder="0" 'allowfullscreen'=""></iframe><p>2012年互联网电商打价格战，那年京东还叫360buy。</p><iframe height="288" width="510" src="https://player.youku.com/embed/XNDg4MzA3OTg0" frameborder="0" 'allowfullscreen'=""></iframe><p>假装认真读英语的女生</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjE5MTgyNjIwOA==" frameborder="0" 'allowfullscreen'=""></iframe><p>锦江学院初秋细雨夜漫步<br>这是我省吃俭用买的iPad拍摄，记录大学校园夜景。</p><iframe height="288" width="510" src="https://player.youku.com/embed/XNDU1NDg0ODg0" frameborder="0" 'allowfullscreen'=""></iframe><p>川大锦江学子疯狂读英语<br>手机像素本来很差，上传更差。</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjA1NzAyMzM5Mg==" frameborder="0" 'allowfullscreen'=""></iframe><p>川大锦江学子睡前夜晚大喊英语<br>那时候我用的是诺基亚5230 像素非常高。</p><iframe height="288" width="510" src="https://player.youku.com/embed/XMjA1NzAyMzE3Mg==" frameborder="0" 'allowfullscreen'=""></iframe><p>10级机械设计5班野炊记录<br>那时候是诺基亚手机时代，很多同学用老年机呢</p><iframe height="288" width="510" src="http://player.youku.com/embed/XMjAzNjAyNzA4NA==" frameborder="0" 'allowfullscreen'=""></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动听歌曲-Scarborough Fair (斯卡布罗集市)心得感悟</title>
      <link href="/2018/12/15/dong-ting-ge-qu-scarborough-fair-si-qia-bu-luo-ji-shi-xin-de-gan-wu/"/>
      <url>/2018/12/15/dong-ting-ge-qu-scarborough-fair-si-qia-bu-luo-ji-shi-xin-de-gan-wu/</url>
      
        <content type="html"><![CDATA[<p>这是世界上最动听的歌曲之一，也是最具争议的歌曲。拥有400多年的历史，也不知道创造者是谁？可以确定的是这歌讲述一个爱情的故事。故事的主人公被心爱的人抛弃，主人公从此落魄潦倒失魂，每天向周围的人说“你要去万灵集市吗，请给那里的人悄个口信，她曾经是我心爱的恋人”相隔12年在听，天籁之音，百听不厌，这首歌仿佛在倾诉着什么——如醉如痴的天籁之声陪伴我们的心灵一起悲欢、一同祈祷。走进这歌曲中，就会忘记世俗和庸杂，仿佛灵魂与世界都被静化了，那么悠远，那么空灵，那么静谧……音乐无国界，经典咏流传！<br><a href="https://c.y.qq.com/base/fcgi-bin/u?__=1L8nf11">Sarah Brightman《Scarborough Fair》</a></p><iframe src="http://47.106.100.28:8080/quickview/video.html?fileId=fa1d74f0-4e7d-41c7-861b-280008ebc5fb" height="320" width="480" style="border:0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen=""></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/30/hello-world/"/>
      <url>/2018/09/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token class-name">SwiftUI</span><span class="token keyword">import</span> <span class="token class-name">Intents</span><span class="token keyword">import</span> <span class="token class-name">Alamofire</span><span class="token keyword">import</span> <span class="token class-name">SwiftyJSON</span><span class="token keyword">import</span> <span class="token class-name">Foundation</span><span class="token keyword">import</span> <span class="token class-name">Charts</span><span class="token keyword">extension</span> <span class="token class-name">CredentialsOrError</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> isSuccess<span class="token punctuation">:</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token punctuation">.</span>credentials<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token keyword">case</span> <span class="token punctuation">.</span>error<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> values<span class="token punctuation">:</span> <span class="token punctuation">(</span>user<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> givenName<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span><span class="token punctuation">,</span> familyName<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span><span class="token punctuation">,</span> email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span><span class="token punctuation">,</span>identityToken<span class="token punctuation">:</span> <span class="token class-name">Data</span><span class="token operator">?</span><span class="token punctuation">,</span>authorizationCode<span class="token punctuation">:</span> <span class="token class-name">Data</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">credentials</span><span class="token punctuation">(</span>user<span class="token punctuation">:</span> user<span class="token punctuation">,</span>                          givenName<span class="token punctuation">:</span> givenName<span class="token punctuation">,</span>                          familyName<span class="token punctuation">:</span> familyName<span class="token punctuation">,</span>                          email<span class="token punctuation">:</span> email<span class="token punctuation">,</span>                          identityToken<span class="token punctuation">:</span> identityToken<span class="token punctuation">,</span>                          authorizationCode<span class="token punctuation">:</span> authorizationCode    <span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>user<span class="token punctuation">:</span> user<span class="token punctuation">,</span>               givenName<span class="token punctuation">:</span> givenName<span class="token punctuation">,</span>               familyName<span class="token punctuation">:</span> familyName<span class="token punctuation">,</span>               email<span class="token punctuation">:</span> email<span class="token punctuation">,</span>               identityToken<span class="token punctuation">:</span> identityToken<span class="token punctuation">,</span>               authorizationCode<span class="token punctuation">:</span> authorizationCode    <span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token punctuation">.</span>error<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token nil constant">nil</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token punctuation">.</span>credentials<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token nil constant">nil</span>    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">let</span> error<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> error    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">ContentView</span> <span class="token punctuation">:</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>    <span class="token attribute atrule">@State</span> <span class="token keyword">var</span> credentials<span class="token punctuation">:</span> <span class="token class-name">CredentialsOrError</span><span class="token operator">?</span>    <span class="token attribute atrule">@State</span>   <span class="token keyword">private</span>  <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">let</span> imgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"house.circle"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"timer"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"timer"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"clock.arrow.circlepath"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"clock.arrow.2.circlepath"</span></span><span class="token punctuation">]</span>    <span class="token keyword">let</span> tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"主页"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"定时"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"统计"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"分析"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"复盘"</span></span><span class="token punctuation">]</span>       <span class="token keyword">var</span> weeks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">var</span>  days <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">var</span>  today <span class="token punctuation">:</span> <span class="token class-name">Int32</span> <span class="token operator">=</span> <span class="token number">20</span>      <span class="token keyword">func</span> <span class="token function-definition function">startOfThisWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>       <span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">let</span> calendar <span class="token operator">=</span> <span class="token class-name">NSCalendar</span><span class="token punctuation">.</span>current       <span class="token keyword">let</span> components <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">dateComponents</span><span class="token punctuation">(</span>           <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token class-name">Component</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span>yearForWeekOfYear<span class="token punctuation">,</span> <span class="token punctuation">.</span>weekOfYear<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> from<span class="token punctuation">:</span> date<span class="token punctuation">)</span>       <span class="token keyword">let</span> startOfWeek <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> components<span class="token punctuation">)</span><span class="token operator">!</span>       <span class="token keyword">return</span> startOfWeek   <span class="token punctuation">}</span>             <span class="token comment">//本周结束日期（星期六）</span>   <span class="token keyword">func</span> <span class="token function-definition function">endOfThisWeek</span><span class="token punctuation">(</span>returnEndTime<span class="token punctuation">:</span><span class="token class-name">Bool</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>       <span class="token keyword">let</span> calendar <span class="token operator">=</span> <span class="token class-name">NSCalendar</span><span class="token punctuation">.</span>current       <span class="token keyword">var</span> components <span class="token operator">=</span> <span class="token class-name">DateComponents</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">if</span> returnEndTime <span class="token punctuation">{</span>           components<span class="token punctuation">.</span>day <span class="token operator">=</span> <span class="token number">7</span>           components<span class="token punctuation">.</span>second <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           components<span class="token punctuation">.</span>day <span class="token operator">=</span> <span class="token number">6</span>       <span class="token punctuation">}</span>               <span class="token keyword">let</span> endOfMonth <span class="token operator">=</span>  calendar<span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span>byAdding<span class="token punctuation">:</span> components<span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token function">startOfThisWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!</span>       <span class="token keyword">return</span> endOfMonth   <span class="token punctuation">}</span>      <span class="token keyword">func</span> <span class="token function-definition function">getDay</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span><span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token punctuation">{</span>              <span class="token comment">//格式化日期时间</span>       <span class="token keyword">let</span> dateFormatter <span class="token operator">=</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//设置时间格式</span>       dateFormatter<span class="token punctuation">.</span>dateFormat <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"dd"</span></span>       <span class="token keyword">let</span> day <span class="token operator">=</span>  <span class="token punctuation">(</span>dateFormatter<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> date<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">NSString</span><span class="token punctuation">)</span><span class="token punctuation">.</span>intValue       <span class="token keyword">return</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>   <span class="token punctuation">}</span>      <span class="token keyword">func</span> <span class="token function-definition function">getYear</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span><span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token punctuation">{</span>              <span class="token comment">//格式化日期时间</span>       <span class="token keyword">let</span> dateFormatter <span class="token operator">=</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//设置时间格式</span>       dateFormatter<span class="token punctuation">.</span>dateFormat <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"YYYY"</span></span>       <span class="token keyword">let</span> year <span class="token operator">=</span>  <span class="token punctuation">(</span>dateFormatter<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> date<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">NSString</span><span class="token punctuation">)</span><span class="token punctuation">.</span>intValue       <span class="token keyword">return</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>   <span class="token punctuation">}</span>      <span class="token keyword">func</span> <span class="token function-definition function">getMonth</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span><span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token punctuation">{</span>              <span class="token comment">//格式化日期时间</span>       <span class="token keyword">let</span> dateFormatter <span class="token operator">=</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//设置时间格式</span>       dateFormatter<span class="token punctuation">.</span>dateFormat <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"MM"</span></span>       <span class="token keyword">let</span> month <span class="token operator">=</span>  <span class="token punctuation">(</span>dateFormatter<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> date<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">NSString</span><span class="token punctuation">)</span><span class="token punctuation">.</span>integerValue       <span class="token keyword">return</span> month   <span class="token punctuation">}</span>      <span class="token keyword">func</span> <span class="token function-definition function">daysCount</span><span class="token punctuation">(</span>year<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> month<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>       <span class="token keyword">switch</span> month <span class="token punctuation">{</span>       <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">:</span>           <span class="token keyword">return</span> <span class="token number">31</span>       <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">:</span>           <span class="token keyword">return</span> <span class="token number">30</span>       <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>           <span class="token keyword">let</span> isLeapYear <span class="token operator">=</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> isLeapYear <span class="token operator">?</span> <span class="token number">29</span> <span class="token punctuation">:</span> <span class="token number">28</span>       <span class="token keyword">default</span><span class="token punctuation">:</span>           <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"非法的月份:</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">month</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function-definition function">getweekdays</span><span class="token punctuation">(</span>firstweekday<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> totaldays<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>       <span class="token keyword">var</span> dayss <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>firstweekday<span class="token operator">&lt;</span>totaldays<span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">...</span><span class="token number">7</span> <span class="token punctuation">{</span> <span class="token comment">//正序</span>           dayss<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>firstweekday<span class="token operator">+</span>i<span class="token punctuation">)</span>       <span class="token punctuation">}</span>           <span class="token keyword">return</span> dayss       <span class="token punctuation">}</span>       <span class="token keyword">else</span><span class="token punctuation">{</span>           <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">...</span><span class="token punctuation">(</span>totaldays<span class="token operator">-</span>firstweekday<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//正序</span>               dayss<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>firstweekday<span class="token operator">+</span>i<span class="token punctuation">)</span>           <span class="token punctuation">}</span>                      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">...</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">-</span><span class="token punctuation">(</span>totaldays<span class="token operator">-</span>firstweekday<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//正序</span>               dayss<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>i<span class="token punctuation">)</span>           <span class="token punctuation">}</span>           <span class="token keyword">return</span> dayss       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>      <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">(</span>identifier<span class="token punctuation">:</span> <span class="token punctuation">.</span>gregorian<span class="token punctuation">)</span>       <span class="token comment">// 日历本地化</span>       c<span class="token punctuation">.</span>locale <span class="token operator">=</span> <span class="token class-name">Locale</span><span class="token punctuation">(</span>identifier<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"zh_CN"</span></span><span class="token punctuation">)</span>       <span class="token comment">// 获取星期标识</span>       <span class="token keyword">self</span><span class="token punctuation">.</span>weeks <span class="token operator">=</span>  c<span class="token punctuation">.</span>veryShortWeekdaySymbols              <span class="token keyword">let</span>  firstweekdayss  <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">startOfThisWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">let</span>  firstweekday  <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span> firstweekdayss<span class="token punctuation">)</span>       <span class="token keyword">let</span>  year  <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span> firstweekdayss<span class="token punctuation">)</span>       <span class="token keyword">let</span>  month  <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span>date<span class="token punctuation">:</span> firstweekdayss<span class="token punctuation">)</span>       <span class="token keyword">let</span>  totaldays  <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">daysCount</span><span class="token punctuation">(</span>year<span class="token punctuation">:</span> year<span class="token punctuation">,</span> month<span class="token punctuation">:</span> month<span class="token punctuation">)</span>       <span class="token keyword">self</span><span class="token punctuation">.</span>days <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getweekdays</span><span class="token punctuation">(</span>firstweekday<span class="token punctuation">:</span> firstweekday<span class="token punctuation">,</span> totaldays<span class="token punctuation">:</span> totaldays<span class="token punctuation">)</span>       <span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">let</span> dateFormatter <span class="token operator">=</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       dateFormatter<span class="token punctuation">.</span>dateFormat <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"dd"</span></span>       <span class="token keyword">self</span><span class="token punctuation">.</span>today <span class="token operator">=</span> <span class="token punctuation">(</span>dateFormatter<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> date<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">NSString</span><span class="token punctuation">)</span><span class="token punctuation">.</span>intValue<span class="token punctuation">}</span>      <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>          <span class="token class-name">VStack</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> $credentials<span class="token punctuation">.</span>wrappedValue <span class="token operator">==</span> <span class="token nil constant">nil</span> <span class="token punctuation">{</span>          <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"lyoggl"</span></span><span class="token punctuation">)</span>          <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"一个时间记录的软件"</span></span><span class="token punctuation">)</span>        <span class="token class-name">SignInWithAppleButton</span><span class="token punctuation">(</span>credentials<span class="token punctuation">:</span> $credentials<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> $credentials<span class="token punctuation">.</span>wrappedValue<span class="token operator">!</span><span class="token punctuation">.</span>isSuccess      <span class="token punctuation">{</span>                                <span class="token class-name">TabView</span><span class="token punctuation">(</span>selection<span class="token punctuation">:</span> $index<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token class-name">ForEach</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">..&lt;</span>imgs<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>item <span class="token keyword">in</span>                  <span class="token class-name">HomeView</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> item<span class="token punctuation">,</span>weeks<span class="token punctuation">:</span>weeks<span class="token punctuation">,</span>days<span class="token punctuation">:</span>days<span class="token punctuation">,</span>today<span class="token punctuation">:</span> today<span class="token punctuation">)</span><span class="token punctuation">.</span>tabItem<span class="token punctuation">{</span><span class="token class-name">Image</span><span class="token punctuation">(</span>systemName<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imgs<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span>                      <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>tags<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>                                                              <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token class-name">Text</span><span class="token punctuation">(</span>$credentials<span class="token punctuation">.</span>wrappedValue<span class="token operator">!</span><span class="token punctuation">.</span>error<span class="token operator">!</span><span class="token punctuation">.</span>localizedDescription<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foregroundColor</span><span class="token punctuation">(</span><span class="token punctuation">.</span>red<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fileprivate</span> <span class="token keyword">struct</span> <span class="token class-name">HomeView</span><span class="token punctuation">:</span><span class="token class-name">View</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> index<span class="token punctuation">:</span><span class="token class-name">Int</span>    <span class="token keyword">var</span>  weeks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> days<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> today<span class="token punctuation">:</span> <span class="token class-name">Int32</span>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">View</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> index<span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token class-name">SwiftUIView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">{</span>                        <span class="token class-name">CalanderView</span><span class="token punctuation">(</span>weeks<span class="token punctuation">:</span> weeks<span class="token punctuation">,</span> days<span class="token punctuation">:</span> days<span class="token punctuation">,</span>today<span class="token punctuation">:</span> today<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> index<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">{</span>                     <span class="token class-name">BarChartUIView</span><span class="token punctuation">(</span>entries<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token class-name">BarChartDataEntry</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      <span class="token class-name">BarChartDataEntry</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      <span class="token class-name">BarChartDataEntry</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      <span class="token class-name">BarChartDataEntry</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      <span class="token class-name">BarChartDataEntry</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> index<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">{</span>                        <span class="token class-name">PieChartUIView</span><span class="token punctuation">(</span>entries<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token class-name">PieChartDataEntry</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      <span class="token class-name">PieChartDataEntry</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2017/06/17/she-ji-mo-shi/"/>
      <url>/2017/06/17/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。本节主要介绍中介模式、代理模式、责任模式。</p><h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><p>简介</p><p>定义了一个对象，该对象封装了一组对象的交互方式。对象之间的通信将封装在中介对象中。对象不再直接相互通信，而是通过中介进行通信。这减少了通信对象之间的依赖性，从而减少了耦合。<br>优点</p><ul><li>避免一组交互对象之间的紧密耦合</li><li>可以独立地改变一组对象之间的交互</li></ul><p>类图</p><p>对应中介对象来说，互相交互的对象叫做同事类，中介者对象维护同事类之间的关系，中介对象需要知道所有同事对象，所以也会带来一个问题，当同事类过多时，中介者类将异常复杂。<br><img src="http://image.lichongbing.com/static/a1a004d2bcbe8954a4ec14604faf0bcb.png" alt="wm-29.png"><br>Mediator：抽象中介类，用于与各同事对象之间进行通信<br>ConcreteMediator：具体中介类，协调各同事类<br>Colleague：抽象同事类<br>ConcreteColleague：具体同事类</p><h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2><p>比如我们要实现一个聊天室的功能，聊天室就是中介，而聊天的人就是一个同事类，发送的每个消息都由聊天室转发给其他人。</p><p>在/home/project目录下新建一下文件</p><p>AbstractChatRoom.java（Mediator）</p><pre><code>public abstract class AbstractChatRoom {public abstract void notice(String message, User user);}</code></pre><p>ChatRoom.java(ConcreteMediator)</p><pre><code>import java.util.ArrayList;import java.util.List;public class ChatRoom extends AbstractChatRoom {private List&lt;User&gt; users = new ArrayList&lt;&gt;();public void register(User user) {    users.add(user);}@Overridepublic void notice(String message, User user) {    for (User u : users) {        if (u != user) {            u.getMessage(message);        }    }}}</code></pre><p>User.java(Colleague)</p><pre><code>public abstract class User {protected AbstractChatRoom chatRoom;public User(AbstractChatRoom chatRoom) {    this.chatRoom = chatRoom;}/** * 发送消息 * * @param msg */public abstract void sendMessage(String msg);/** * 接受消息 * * @param msg */public abstract void getMessage(String msg);}</code></pre><p>UserA.java(ConcreteColleague)</p><pre><code>public class UserA extends User {public UserA(AbstractChatRoom chatRoom) {    super(chatRoom);}@Overridepublic void sendMessage(String msg) {    System.out.println("用户A发送 " + msg);    chatRoom.notice(msg, this);}@Overridepublic void getMessage(String msg) {    System.out.println("用户A收到 " + msg);}}</code></pre><p>UserB.java(ConcreteColleague)</p><pre><code>public class UserB extends User {public UserB(AbstractChatRoom chatRoom) {    super(chatRoom);}@Overridepublic void sendMessage(String msg) {    System.out.println("用户B发送 " + msg);    chatRoom.notice(msg, this);}@Overridepublic void getMessage(String msg) {    System.out.println("用户B收到 " + msg);}}</code></pre><p>Client.java</p><pre><code>public class Client {public static void main(String[] args) {    ChatRoom chatRoom = new ChatRoom();    UserA userA = new UserA(chatRoom);    UserB userB = new UserB(chatRoom);    chatRoom.register(userA);    chatRoom.register(userB);    userA.sendMessage("你好！");    userB.sendMessage("再见！");}}</code></pre><p>编译运行</p><pre><code>javac Client.java java Clent用户A发送 你好！用户B收到 你好！用户B发送 再见！用户A收到 再见！</code></pre><p>。。。。</p><pre><code>- name: 检查是否存在 Client  script: |#!/bin/bashls /home/project/Client.java error: |没有找到 /home/project/Client.java 文件- name: 检查是否存在 User  script: |#!/bin/bashls /home/project/User.java error: |没有找到 /home/project/User.java 文件- name: 检查是否存在 UserA script: |#!/bin/bashls /home/project/UserA.java error: |没有找到 /home/project/UserA.java 文件- name: 检查是否存在 UserB  script: |#!/bin/bashls /home/project/UserB.java error: |没有找到 /home/project/UserB.java 文件- name: 检查是否存在 AbstractChatRoom  script: |#!/bin/bashls /home/project/AbstractChatRoom.java error: |没有找到 /home/project/AbstractChatRoom.java 文件- name: 检查是否存在 ChatRoom  script: |#!/bin/bashls /home/project/ChatRoom.java error: |没有找到 /home/project/ChatRoom.java 文件</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。<br>优点</p><ul><li>隐藏原始对象并控制对象的访问</li><li>访问对象时提供其他的功能<br>类图<br><img src="http://image.lichongbing.com/static/93e83b1de3006ec8639cf02b9f729b73.png" alt="wm-30.png"><br>说明：</li></ul><p>Subject: 一个客户端可用的公开的功能接口<br>RealSubject：实现Subject接口的类，提供了接口方法的具体实现<br>Proxy：实现Subject接口的代理类，通过RealSubject类的业务逻辑方法来实现抽象方法，可以附加自己的操作。</p><h2 id="编程实战-1"><a href="#编程实战-1" class="headerlink" title="编程实战"></a>编程实战</h2><p>假设我们需要建设一栋楼房，但是建设之前我们需要购买原材料（如水泥…)，接着才可以开始建设，楼房主体建设完成后，还需要封顶操作。</p><p>在/home/project/目录下新建以下文件</p><p>LouSubject.java</p><pre><code>public interface LouSubject{void build();}</code></pre><p>LouRealSubject.java</p><pre><code>public class LouRealSubject implements LouSubject{@Overridepublic void build(){    System.out.println("建设实验楼");}}</code></pre><p>LouProxy.java</p><pre><code>public class LouProxy implements LouSubject{private LouSubject target;public LouProxy(){    this.target = new LouRealSubject();}@Overridepublic void build(){    System.out.println("购买材料");    target.build();    System.out.println("封顶");}}</code></pre><p>LouClient.java</p><pre><code>public class LouClient{public static void main(String[] args){    LouSubject proxy = new LouProxy();    proxy.build();}}</code></pre><p>编译运行：</p><pre><code>javac LouClient.javajava LouClient购买材料建设实验楼封顶</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式是一种由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含定义它可以处理的命令对象类型的逻辑; 其余的传递给链中的下一个处理对象。还存在一种机制，用于将新处理对象添加到该链的末尾。责任链模式在结构上与装饰器模式几乎相同，不同之处在于对于装饰器，所有类都处理请求，而对于责任链，链中的一个类恰好处理请求。</p><p>优点</p><p>避免将请求的发送方与其接收方耦合<br>可以使用多个接收器处理请求<br>类图<br><img src="http://image.lichongbing.com/static/11d3d58c402e7f69781bf14fcc5ae126.png" alt="wm-31.png"><br>handler：抽象处理者</p><p>ConcreteHandler：具体处理者，接受到请求后，可以选择处理请求或者传递给下一个处理者。</p><p>编程实战</p><p>假设我们有一个请假系统，不同的职位可以处理不同的请假请求，比如：</p><p>组长：可以处理两天以内的请求</p><p>厂长：可以处理七天以内的请求</p><p>老板：可以处理十五天以内的请求</p><p>如果组长可以处理，那么就直接处理了，如果组长不可以处理，那么我们再继续往下传递。</p><p>在/home/project目录下新建以下文件</p><p>Handler.java</p><pre><code>public abstract class Handler {/** * 下个处理者 */protected Handler successor;public void setSuccessor(Handler successor) {    this.successor = successor;}public abstract void handlerRequest(int heaven);}</code></pre><p>GroupLeaderHandler.java</p><pre><code>public class GroupLeaderHandler extends Handler {@Overridepublic void handlerRequest(int heaven) {    if (heaven &lt;= 2) {        System.out.println("组长处理");    }else {        if (super.successor != null) {            super.successor.handlerRequest(heaven);        }    }}}</code></pre><p>FactoryManagerHandler.java</p><pre><code>public class FactoryManagerHandler extends Handler{@Overridepublic void handlerRequest(int heaven) {    if (heaven &lt;= 7) {        System.out.println("厂长处理");    }else {        if (super.successor != null) {            super.successor.handlerRequest(heaven);        }    }}}</code></pre><p>BossHandler.java</p><pre><code>public class BossHandler extends Handler {@Overridepublic void handlerRequest(int heaven) {    if (heaven &lt;= 15) {        System.out.println("老板处理");    }else {        if (super.successor != null) {            super.successor.handlerRequest(heaven);        }    }}}</code></pre><p>Client.java</p><pre><code>public class Client {public static void main(String[] args) {    Handler groupLeaderHandler = new GroupLeaderHandler();    Handler factoryManagerHandler = new FactoryManagerHandler();    Handler bossHandler = new BossHandler();    groupLeaderHandler.setSuccessor(factoryManagerHandler);    factoryManagerHandler.setSuccessor(bossHandler);    //请假一天    groupLeaderHandler.handlerRequest(1);    //请假6天    groupLeaderHandler.handlerRequest(6);    //请假10天    groupLeaderHandler.handlerRequest(10);}</code></pre><p>}</p><p>编译运行</p><pre><code>javac Client.javajava Client组长处理厂长处理老板处理</code></pre><p>。。。。。。。。</p><pre><code>- name: 检查是否存在 Client script: |#!/bin/bashls /home/project/Client.javaerror: |没有找到 /home/project/Client.java 文件- name: 检查是否存在 Handler script: |#!/bin/bashls /home/project/Handler.javaerror: |没有找到 /home/project/Handler.java 文件- name: 检查是否存在 GroupLeaderHandler script: |#!/bin/bashls /home/project/GroupLeaderHandler.javaerror: |没有找到 /home/project/GroupLeaderHandler.java 文件- name: 检查是否存在 FactoryManagerHandler script: |#!/bin/bashls /home/project/FactoryManagerHandler.javaerror: |没有找到 /home/project/FactoryManagerHandler.java 文件- name: 检查是否存在 BossHandler script: |#!/bin/bashls /home/project/BossHandler.javaerror: |没有找到 /home/project/BossHandler.java 文件</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要内容是对常用的设计模式进行讲解，主要包含以下知识点：</p><ul><li>中介模式</li><li>代理模式</li><li>责任链模式<br>请大家务必手动完成代码并运行对比结果，这样才能更好的理解并掌握这三种设计模式，如果还想深入学习更多的设计模式，可以继续学习 Java 进阶之设计模式课程</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2017/06/14/zheng-ze-biao-da-shi/"/>
      <url>/2017/06/14/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE ），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。<br>Java 通过java.util.regex包支持正则表达式的的功能。<br>这里只说明如何在 Java 中使用正则表达式，关于表达式的更多内容，请在实验楼搜索相关内容学习。</p><p>Java 使用正则表达式匹配非常简单，这里我们以匹配邮箱地址为例。在/home/project目录下新建一个源代码文件RegexDemo.java。</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexDemo {public static void main(String[] args) {//       Pattern类 正则表达式的编译表示。    Pattern pattern = Pattern.compile("^[a-zA-Z0-9_!#$%&amp;'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$");    String[] emails = {"shiyanlou@shiyanlou.com", "shiyanlou"};    for (String email :            emails) {//Matcher 通过解释Pattern对字符序列执行匹配操作的引擎        Matcher matcher = pattern.matcher(email);        System.out.println(email + "匹配结果：" + matcher.matches());    }}}</code></pre><p>编译运行：</p><pre><code>$ javac RegexDemo.java$ java RegexDemoshiyanlou@shiyanlou.com匹配结果：trueshiyanlou匹配结果：false</code></pre><h2 id="练习题：正则表达式"><a href="#练习题：正则表达式" class="headerlink" title="练习题：正则表达式"></a>练习题：正则表达式</h2><p>在/home/project目录下新建一个源代码文件RegexTest.java。你需要完成以下要求：</p><p>从控制台输入一串字符串，使用正则表达式判断其是不是 11 位手机号码<br>如果是 11 位手机号码，输出 true，如果不是输出 false<br>示例：</p><pre><code>输入：   13408199578输出：   true</code></pre><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code> import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) {    Pattern pattern = Pattern.compile("^1([34578])\\d{9}$");    Scanner in = new Scanner(System.in);    String phone = in.nextLine();    Matcher matcher = pattern.matcher(phone);    System.out.println(matcher.matches());}}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节内容相对简单，仅说明了如何在 Java 中使用正则表达式。主要知识点为：</p><ul><li>java.util.regex<br>到此，Java 语言编程基础我们就学完了。在学完基础知识之后，还请多勤加练习，多写代码巩固相关知识内容</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2017/06/10/fan-she/"/>
      <url>/2017/06/10/fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。本节主要讲解 Java 反射机制中的常用类</p><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射是 Java 编程语言的一个特性，它提供了在运行时检查和动态调用类、方法、属性的能力。</p><h2 id="反射能做什么"><a href="#反射能做什么" class="headerlink" title="反射能做什么"></a>反射能做什么</h2><p>反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。</p><h2 id="反射常用类"><a href="#反射常用类" class="headerlink" title="反射常用类"></a>反射常用类</h2><p><img src="http://image.lichongbing.com/static/6e70078a47635cc23650669d7692d6f7.png" alt="截屏2019-12-1016.36.10.png"><br>更多方法请查阅<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">官方文档</a></p><h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2><p>在/home/project/目录下新建ReflectDemo.java。</p><pre><code>import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectDemo {public int a;private int b;public static void main(String[] args) {    Class&lt;ReflectDemo&gt; reflectDemoClass = ReflectDemo.class;    //输出所有的域名称    for (Field declaredField : reflectDemoClass.getDeclaredFields()) {        //可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值        System.out.println("域：" + declaredField.getName() + " 修饰符：" + Modifier.toString(declaredField.getModifiers()));    }    //输出所有的公有域名称    for (Field field : reflectDemoClass.getFields()) {        System.out.println("公有域：" + field.getName() + " 修饰符：" + Modifier.toString(field.getModifiers()));    }    //输出类的所有方法名    for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) {        System.out.println("方法：" + declaredMethod.getName() + " 修饰符：" + Modifier.toString(declaredMethod.getModifiers()));    }}public void fun1() {}private void fun2() {}}</code></pre><p>编译运行：</p><pre><code>javac ReflectDemo.javajava ReflectDemo</code></pre><p>运行结果：</p><pre><code>域：a 修饰符：public域：b 修饰符：private公有域：a 修饰符：public方法：main 修饰符：public static方法：fun1 修饰符：public方法：fun2 修饰符：private</code></pre><h2 id="反射虽然提供了强大的能力，但是确会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用反射尽量不用。"><a href="#反射虽然提供了强大的能力，但是确会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用反射尽量不用。" class="headerlink" title="反射虽然提供了强大的能力，但是确会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用反射尽量不用。"></a>反射虽然提供了强大的能力，但是确会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用反射尽量不用。</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2017/05/22/jdbc/"/>
      <url>/2017/05/22/jdbc/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC 是连接数据库和 Java 程序的桥梁，通过 JDBC API 可以方便地实现对各种主流数据库的操作。本节将重点讲解 JDBC 的内容。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。</p><p>所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。</p><h3 id="常见的关系型数据库有以下几种："><a href="#常见的关系型数据库有以下几种：" class="headerlink" title="常见的关系型数据库有以下几种："></a>常见的关系型数据库有以下几种：</h3><ul><li>MySQL</li><li>MariaDB</li><li>Percona Server</li><li>PostgreSQL</li><li>Microsoft Access</li><li>Microsoft SQL Server</li><li>Google Fusion Tables</li><li>FileMaker</li><li>Oracle 数据库</li><li>Sybase</li><li>dBASE</li><li>Clipper</li><li>FoxPro</li><li>foshub</li></ul><h2 id="非关系型数据库（NoSql）"><a href="#非关系型数据库（NoSql）" class="headerlink" title="非关系型数据库（NoSql）"></a>非关系型数据库（NoSql）</h2><h3 id="常见非关系数据库："><a href="#常见非关系数据库：" class="headerlink" title="常见非关系数据库："></a>常见非关系数据库：</h3><ul><li>Redis</li><li>BigTable</li><li>Cassandra</li><li>MongoDB</li><li>CouchDB</li></ul><h2 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h2><p>结构化查询语言(Structured Query Language)简称 SQL(发音：/ˈes kjuː ˈel/ “S-Q-L”)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</p><h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><p>对于数据库的操作我们肯定是需要结构化查询语句 SQL</p><p>这里我们就回顾一下 SQL 语句，但不会做过多的详细介绍，如果需要更系统的学习，请参照我们的 MySQL 基础课程。</p><p>创建数据库</p><p>CREATE DATABASE 语句用于创建一个新的数据库。语法是：</p><pre><code>SQL&gt; CREATE DATABASE DATABASE_NAME;</code></pre><p>例子，创建一个名为 EXAMPLE 数据库：</p><pre><code>SQL&gt; CREATE DATABASE EXAMPLE;</code></pre><p>删除数据库</p><p>使用 DROP DATABASE 语句用于删除现有的数据库。语法是：</p><pre><code>SQL&gt; DROP DATABASE DATABASE_NAME;</code></pre><p>注意：要创建或删除，应该有数据库服务器上管理员权限。请注意，删除数据库将损失所有存储在数据库中的数据。</p><p>例子，删除我们刚刚建好的数据库：</p><pre><code>SQL&gt; DROP DATABASE EXAMPLE;</code></pre><p>创建表</p><p>CREATE TABLE 语句用于创建一个新表。语法是：</p><pre><code>SQL&gt; CREATE TABLE table_name(  column_name column_data_type,  column_name column_data_type,  column_name column_data_type  ...);</code></pre><p>例子，下面的 SQL 语句创建一个有四个属性的 Students 表：</p><pre><code>SQL&gt; CREATE TABLE Students(  id INT NOT NULL,  age INT NOT NULL,  name VARCHAR(255),  major VARCHAR(255),  PRIMARY KEY ( id ));</code></pre><p>删除表</p><p>DROP TABLE 语句用于删除现有的表。语法是：</p><pre><code>SQL&gt; DROP TABLE table_name;</code></pre><p>例子，下面的 SQL 语句删除一个名为 Students 表：</p><pre><code>SQL&gt; DROP TABLE Students;</code></pre><p>插入数据</p><p>语法 INSERT 如下，其中 column1, column2 ，依此类推的属性值：</p><pre><code>SQL&gt; INSERT INTO table_name VALUES (column1, column2, ...);</code></pre><p>例子，下面的 INSERT 语句中插入先前创建的 Students 表：</p><pre><code>SQL&gt; INSERT INTO Students VALUES (1, 18, 'Mumu', 'Java');</code></pre><p>查询数据</p><p>SELECT 语句用于从数据库中检索数据。该语法的 SELECT 是：</p><pre><code>SQL&gt; SELECT column_name, column_name, ... FROM table_name WHERE conditions;</code></pre><p>WHERE 子句可以使用比较操作符例如 =, !=, &lt;, &gt;, &lt;=, &gt;=,以及 BETWEEN 和 LIKE 等操作符。</p><p>例子，下面的 SQL 语句从 Students 表选择 id 为1的学生，并将该学生的姓名和年龄显示出来：</p><pre><code>SQL&gt; SELECT name, age      FROM Students      WHERE id = 1;</code></pre><p>下面的 SQL 语句从 Students 表中查询姓名中有 om 字样的学生，并将学生的姓名和专业显示出来:</p><pre><code> SQL&gt; SELECT name, major       FROM Students       WHERE name LIKE '%om%';</code></pre><p>更新数据</p><p>UPDATE 语句用于更新数据。UPDATE 语法为：</p><pre><code>SQL&gt; UPDATE table_name     SET column_name = value, column_name = value, ...     WHERE conditions;</code></pre><p>例子，下面的 SQL 的 UPDATE 语句表示将 ID 为1的学生的 age 改为20：</p><pre><code>SQL&gt; UPDATE Students SET age=20 WHERE id=1;</code></pre><p>删除数据</p><p>DELETE 语句用来删除表中的数据。语法 DELETE 是：</p><pre><code>SQL&gt; DELETE FROM table_name WHERE conditions;</code></pre><p>例子，下面的 SQL DELETE 语句删除 ID 为1的学生的记录：</p><pre><code>SQL&gt; DELETE FROM Students WHERE id=1;</code></pre><h2 id="JDBC-1"><a href="#JDBC-1" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的api，还有与数据库进行通信的驱动程序。</p><p>我们要写涉及到数据库的程序，是通过 C 语言或者 C++ 语言直接访问数据库的接口，如下图所示。</p><p>对于不同的数据库，我们需要知道不同数据库对外提供的系统 API，这就影响了我们程序的扩展和跨平台的实现。<br><img src="http://image.lichongbing.com/static/57c3a7e6831849ff1f701965497be53c.png" alt="wm-25.png"><br>那么有没有一种方法来对不同的数据库接口进行统一呢？当然有。我们只需要和最上层接口进行交互，剩下的部分就交给其他各层去处理，我们的任务就变的轻松简单许多。<br><img src="http://image.lichongbing.com/static/8f0a0c85f18062e3d2e246cbee8b9fa4.png" alt="wm-26.png"><br>JDBC 为数据库开发人员提供了一个标准的 API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯 Java API 编写数据库应用程序。<br><img src="http://image.lichongbing.com/static/5d0d1998e7184f37b930837c271be16e.png" alt="wm-27.png"></p><h2 id="JDBC-连接数据库"><a href="#JDBC-连接数据库" class="headerlink" title="JDBC 连接数据库"></a>JDBC 连接数据库</h2><p>涉及到建立一个 JDBC 连接的编程主要有四个步骤：</p><p>导入 JDBC 驱动： 只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤。<br>注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求。<br>数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库。<br>创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接。<br>接下来我们便详细讲解这四步。</p><p>导入 JDBC 驱动</p><p>需要下载对应数据库的 jdbc 驱动，将其导入到项目中，具体的导入方式根据个人的 IDE 确定，本节课程不使用 IDE，直接使用 javac -cp 命令导入包。</p><p>注册 JDBC 驱动程序</p><p>我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序。</p><p>1、方法1——Class.forName()：</p><p>动态加载一个类最常用的方法是使用 Java 的 Class.forName() 方法，通过使用这个方法来将数据库的驱动类动态加载到内存中，然后我们就可以使用。</p><p>使用 Class.forName() 来注册 Mysql 驱动程序：</p><pre><code> try { Class.forName("com.mysql.jdbc.Driver");}catch(ClassNotFoundException ex) { System.out.println("Error: unable to load driver class!"); System.exit(1);}</code></pre><p>2、方法 2——DriverManager.registerDriver()：</p><pre><code> Driver driver = new com.mysql.jdbc.Driver(); DriverManager.registerDriver(driver);</code></pre><p>指定数据库连接 URL</p><p>当加载了驱动程序，便可以使用 DriverManager.getConnection() 方法连接到数据库了。</p><p>这里给出 DriverManager.getConnection() 三个重载方法：</p><pre><code>getConnection(String url)getConnection(String url, Properties prop)getConnection(String url, String user, String password)</code></pre><p>数据库的 URL 是指向数据库地址。下表列出了下来流行的 JDBC 驱动程序名和数据库的 URL。</p><p><img src="http://image.lichongbing.com/static/f01cc7be067f48546ae9a5e5a1f83539.png" alt="截屏2019-12-1015.42.32.png"><br>创建连接对象</p><p>下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection()最常用形式要求传递一个数据库 URL，用户名 username 和密码 password。</p><p>1、使用数据库 URL 的用户名和密码</p><pre><code>String URL = "jdbc:mysql://localhost/EXAMPLE";String USER = "username";String PASS = "password"Connection conn = DriverManager.getConnection(URL, USER, PASS);</code></pre><p>2、只使用一个数据库 URL</p><p>然而，在这种情况下，数据库的 URL，包括用户名和密码。</p><pre><code>String URL = "jdbc:mysql://localhost/EXAMPLE?user=root&amp;password=0909";//Mysql URL的参数设置详细可以查阅相关资料Connection conn = DriverManager.getConnection(URL);</code></pre><p>3、使用数据库的 URL 和一个 Properties 对象</p><pre><code>import java.util.*;String URL = "jdbc:mysql://localhost/EXAMPLE";Properties pro = new Properties( );//Properties对象，保存一组关键字-值对pro.put( "user", "root" );pro.put( "password", "" );Connection conn = DriverManager.getConnection(URL, pro);</code></pre><p>4、关闭 JDBC 连接</p><pre><code>conn.close();</code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在使用数据库之前第一件事情就是创建数据库，这里我们使用 JDBC 来创建数据库。</p><h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2><p>在/home/project/目录下新建文件CreateDatabase.java。</p><pre><code>import java.sql.*;public class CreateDatabase {   public static void main(String[] args){      Connection connection = null;      try {        //加载数据库驱动        Class.forName("com.mysql.jdbc.Driver");        //打开数据库连接 第一个参数为数据库地址  后面2个参数分别为数据库用户名和密码        connection =    DriverManager.getConnection("jdbc:mysql://localhost:3306/","root","");        //创建Statement        Statement statement = connection.createStatement();        //执行sql        statement.execute("create database EXAMPLE");    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    }finally {        try {            //关闭连接            if (connection != null) {                connection.close();            }        } catch (SQLException e) {            e.printStackTrace();        }    }}}</code></pre><p>启动 mysql：</p><pre><code>$ sudo service mysql start</code></pre><p>编译运行（需要带上 mysql-connector-java-5.1.45.jar）：</p><pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar$ javac -cp mysql-connector-java-5.1.47.jar CreateDatabase.java$ java -cp .:mysql-connector-java-5.1.47.jar CreateDatabase</code></pre><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p><img src="http://image.lichongbing.com/static/e22514256293fad0e11a98eb02058d43.png" alt="wm-28.png"><br>当连接上了数据库后，就需要通过 sql 语句对数据库进行操作。随着 Java 语言应用面的逐步拓宽,Sun 公司开发了一个标准的 SQL 数据库访问接口———JDBC API。它可以使 Java 编程人员通过一个一致的接口,访问多种关系数据库。而今天我们就来学习一下，如何利用 JDBC 的一些核心 API 与数据库进行交互。</p><p>通过使用 JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性，使可以使用 SQL 或 PL/SQL 命令和从数据库接收数据。它们还定义了许多方法，帮助消除 Java 和数据库之间数据类型的差异。<br><img src="http://image.lichongbing.com/static/f7766f7b45b4d239dd1182f2d29c6417.png" alt="截屏2019-12-1015.48.13.png"></p><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>我们要使用 Statement 接口，第一步肯定是创建一个 Statement 对象了。我们需要使用 Connection 对象的 createStatement() 方法进行创建。</p><pre><code>Statement stmt = null;try {stmt = conn.createStatement( );. . .}catch (SQLException e) {. . .}finally {. . .}</code></pre><p>一旦创建了一个 Statement 对象，我们就可以用它来执行 SQL 语句了，首先我们先来看看 Statement 里面有哪些方法吧！</p><p>方法    说明<br>boolean execute(String SQL)    如果 ResultSet 对象可以被检索返回布尔值 true，否则返回 false。使用这个方法来执行 SQL DDL 语句，或当需要使用真正的动态 SQL<br>int executeUpdate(String SQL)    用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQLDDL（数据定义语言）语句。返回值是一个整数，指示受影响的行数（即更新计数）<br>ResultSet executeQuery(String SQL)    返回 ResultSet 对象。用于产生单个结果集的语句，例如 SELECT 语句<br>正如关闭一个 Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭 Statement 对象。</p><pre><code>Statement stmt = null;try {stmt = conn.createStatement( );. . .}catch (SQLException e) {. . .}finally { stmt.close();}</code></pre><p>注：如果关闭了 Connection 对象首先它会关闭 Statement 对象，然而应该始终明确关闭 Statement 对象，以确保正确的清除。</p><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><p>PreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。我们先来创建一个 PreparedStatement 对象。 Statement 为一条 SQL 语句生成执行计划。如果要执行两条 SQL 语句，会生成两个执行计划。一万个查询就生成一万个执行计划！</p><pre><code>select colume from table where colume=1;select colume from table where colume=2;</code></pre><p>PreparedStatement 用于使用绑定变量重用执行计划。</p><pre><code>select colume from table where colume=:x;</code></pre><p>通过 set 不同数据，只需要生成一次执行计划，并且可以重用。</p><pre><code> PreparedStatement pstmt = null; try {/* 在JDBC中所有的参数都被代表？符号，这是已知的参数标记。在执行SQL语句之前，必须提供值的每一个参数。*/ String SQL = "Update Students SET age = ? WHERE id = ?"; pstmt = conn.prepareStatement(SQL);  . . . }/*setXXX()方法将值绑定到参数，其中XXX表示希望绑定到输入参数值的 Java 数据类型。如果忘了提供值，将收到一个 SQLException。*/catch (SQLException e) {. . .}finally {//同理，我们需要关闭 PreparedStatement 对象  pstmt.close();}</code></pre><p>说了这么多，我们手动操作一下吧。</p><p>1、先创建数据库和相应的内容：</p><pre><code>sudo service mysql startmysql -u root create database EXAMPLE;use EXAMPLE</code></pre><p><img src="http://image.lichongbing.com/static/49ed9e01c881f6ce0ecc32ab02fe0bb4.jpeg" alt="wm-6.jpeg"></p><pre><code>create table Students(id int not null,age int not null,name varchar(255),primary key(id));insert into Students values(1,18,'Tom'),(2,20,'Aby'),(4,20,'Tomson');</code></pre><p>在/home/project/目录下创建JdbcTest.java。</p><pre><code>import java.sql.*;public class JdbcTest {   // JDBC 驱动器的名称和数据库地址   static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";     static final String DB_URL = "jdbc:mysql://localhost/EXAMPLE";   static final String USER = "root";   static final String PASS = "";  public static void main(String[] args) {   Connection conn = null;   PreparedStatement stmt = null;   try{       //注册 JDBC 驱动器       Class.forName("com.mysql.jdbc.Driver");       //打开连接       System.out.println("Connecting to database...");       conn = DriverManager.getConnection(DB_URL,USER,PASS);       //执行查询       System.out.println("Creating statement...");       //这里我们要更改一个同学的年龄，参数待定       String sql = "UPDATE Students set age=? WHERE id=?";       stmt = conn.prepareStatement(sql);       //将值绑定到参数，参数从左至右序号为1，2...       stmt.setInt(1, 22);  // 绑定 age 的值(序号为1)       stmt.setInt(2, 1); // 绑定 ID 的值       // 更新 ID 为1的同学的年龄       int rows = stmt.executeUpdate();       System.out.println("被影响的行数 : " + rows );       // 查询所有记录，并显示.       sql = "SELECT id, name, age FROM Students";       ResultSet rs = stmt.executeQuery(sql);       //处理结果集       while(rs.next()){           //检索           int id  = rs.getInt("id");           int age = rs.getInt("age");           String name = rs.getString("name");           //显示           System.out.print("ID: " + id);           System.out.print(", Age: " + age);           System.out.print(", Name: " + name);           System.out.println();       }       //清理       rs.close();       stmt.close();       conn.close();   }catch(SQLException se){       se.printStackTrace();   }catch(Exception e){       e.printStackTrace();   }finally{       try{           if(stmt!=null)               stmt.close();       }catch(SQLException se2){       }try{     if(conn!=null)             conn.close();  }catch(SQLException se){          se.printStackTrace();      }   }       System.out.println("Goodbye!"); }}</code></pre><p>编译运行：</p><pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/110/mysql-connector-java-5.1.47.jar   $ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java     $ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest </code></pre><p>运行结果<br><img src="http://image.lichongbing.com/static/7609cd8460fc7725fae2dc706d7289af.jpeg" alt="wm-7.jpeg"></p><h2 id="CallableStatement"><a href="#CallableStatement" class="headerlink" title="CallableStatement"></a>CallableStatement</h2><p>CallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用IN参数。 CallableStatement 对象可以使用所有三个<br><img src="http://image.lichongbing.com/static/44774b4278fd900888c525bb0f4c0287.png" alt="截屏2019-12-1015.58.31.png"><br>在 JDBC 中调用存储过程的语法如下所示。注意，方括号表示其间的内容是可选项；方括号本身并不是语法的组成部份。</p><pre><code>{call 存储过程名[(?, ?, ...)]} </code></pre><p>返回结果参数的过程的语法为：</p><pre><code>{? = call 存储过程名[(?, ?, ...)]} </code></pre><p>不带参数的存储过程的语法类似：</p><pre><code>{call 存储过程名} </code></pre><p>CallableStatement 对象是用 Connection 方法 prepareCall 创建的。</p><pre><code>CallableStatement cstmt = null;try {     String SQL = "{call getEXAMPLEName (?, ?)}";     cstmt = conn.prepareCall (SQL);     . . .   } catch (SQLException e) {  . . . }finally {  cstmt.close();}</code></pre><p>好了，CallableStatement 接口就不再详细地讲解了，同学们可以自己查阅相关的资料，对 CallableStatement 进行深入学习。</p><h2 id="JDBC-结果集"><a href="#JDBC-结果集" class="headerlink" title="JDBC 结果集"></a>JDBC 结果集</h2><p>结果集通常是通过执行查询数据库的语句生成，表示数据库查询结果的数据表。</p><h2 id="ResultSet-介绍"><a href="#ResultSet-介绍" class="headerlink" title="ResultSet 介绍"></a>ResultSet 介绍</h2><p>ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。</p><p>ResultSet 接口的方法可分为三类：</p><ul><li><p>导航方法：用于移动光标</p></li><li><p>获取方法：用于查看当前行的光标所指向的列中的数据</p></li><li><p>更新方法：用于更新当前行的列中的数据<br>JDBC 提供下列连接方法来创建所需的 ResultSet 语句：</p><p>createStatement(int RSType, int RSConcurrency);</p><p>prepareStatement(String SQL, int RSType, int RSConcurrency);</p><p>prepareCall(String sql, int RSType, int RSConcurrency);</p></li></ul><p>RSType 表示 ResultSet 对象的类型，RSConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新。</p><p>ResultSet 的类型，如果不指定 ResultSet 类型，将自动获得一个是 TYPE_FORWARD_ONLY：<br><img src="http://image.lichongbing.com/static/e8258586432a74ebde4f2eeb7b365ec9.png" alt="截屏2019-12-1016.01.48.png"><br>如初始化一个 Statement 对象来创建一个双向、可更新的 ResultSet 对象：</p><pre><code>try { Statement stmt = conn.createStatement(                       ResultSet.TYPE_SCROLL_INSENSITIVE,                       ResultSet.CONCUR_UPDATABLE);   }catch(Exception ex) {  .... }finally {  ....}</code></pre><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>我们在上面已经知道了，导航方法是用于移动光标的。我们先来看一看，在 ResultSet 接口中有哪些方法会涉及光标的移动。<br><img src="http://image.lichongbing.com/static/83d9a1a4b2d1dea77fa23f011369ed06.png" alt="截屏2019-12-1016.03.52.png"><br>什么也不说了，我们还是看代码吧！</p><p>1、先创建数据库和相应的内容：</p><pre><code>sudo service mysql startmysql -u root create database EXAMPLE;use EXAMPLE</code></pre><p><img src="http://image.lichongbing.com/static/49ed9e01c881f6ce0ecc32ab02fe0bb4.jpeg" alt="wm-8.jpeg"></p><pre><code>create table Students(id int not null,age int not null,name varchar(255),primary key(id));insert into Students values(1,18,'Tom'),(2,20,'Aby'),(4,20,'Tomson');</code></pre><p><img src="http://image.lichongbing.com/static/b047f5a977d93e71d9c951a1ee3ab703.jpeg" alt="wm-9.jpeg"><br>在/home/project/目录下创建文件JdbcTest.java。</p><pre><code>import java.sql.*;public class JdbcTest {// JDBC 驱动器名称 和数据库地址static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";//数据库的名称为 EXAMPLEstatic final String DB_URL = "jdbc:mysql://localhost/EXAMPLE";// 数据库用户和密码static final String USER = "root";static final String PASS = "";public static void main(String[] args) {   Connection conn = null;   Statement stmt = null;   try{       //注册JDBC 驱动程序       Class.forName("com.mysql.jdbc.Driver");       //打开连接       System.out.println("Connecting to database...");       conn = DriverManager.getConnection(DB_URL,USER,PASS);       System.out.println("Creating statement...");       //创建所需的ResultSet，双向，只读       stmt = conn.createStatement(                       ResultSet.TYPE_SCROLL_INSENSITIVE,                       ResultSet.CONCUR_READ_ONLY);       String sql;       sql = "SELECT id, name, age FROM Students";       ResultSet rs = stmt.executeQuery(sql);       // 将光标移到最后一行       System.out.println("Moving cursor to the last...");       rs.last();       //处理结果集       System.out.println("Displaying record...");       int id  = rs.getInt("id");       int age = rs.getInt("age");       String name = rs.getString("name");       //显示       System.out.print("ID: " + id);       System.out.print(", Age: " + age);       System.out.print(", Name: " + name);       System.out.println();       // 将光标移到第一行       System.out.println("Moving cursor to the first row...");       rs.first();       System.out.println("Displaying record...");       id  = rs.getInt("id");       age = rs.getInt("age");       name = rs.getString("name");       //显示       System.out.print("ID: " + id);       System.out.print(", Age: " + age);       System.out.print(", Name: " + name);       //将光标移至下一行       System.out.println("Moving cursor to the next row...");       rs.next();       System.out.println("Displaying record...");       id  = rs.getInt("id");       age = rs.getInt("age");       name = rs.getString("name");       // 显示       System.out.print("ID: " + id);       System.out.print(", Age: " + age);       System.out.print(", Name: " + name);       rs.close();       stmt.close();       conn.close();   }catch(SQLException se){       se.printStackTrace();   }catch(Exception e){       e.printStackTrace();   }finally{       try{           if(stmt!=null)               stmt.close();       }catch(SQLException se2){       }       try{           if(conn!=null)               conn.close();       }catch(SQLException se){           se.printStackTrace();       }   }   System.out.println("Goodbye!");}}</code></pre><p>编译运行：</p><pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/110/mysql-connector-java-5.1.47.jar $ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java     $ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest      </code></pre><p>运行结果：<br><img src="http://image.lichongbing.com/static/728e78e362702a87ee5fc3dc0ae27c95.jpeg" alt="wm-10.jpeg"></p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><img src="http://image.lichongbing.com/static/e71e02b51945ef6eddca5dfa53ae85db.png" alt="截屏2019-12-1016.07.39.png"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><img src="http://image.lichongbing.com/static/0e9570386817df706f1136c27ce9f225.png" alt="截屏2019-12-1016.08.30.png"></p><pre><code> Statement stmt = conn.createStatement(                       ResultSet.TYPE_SCROLL_INSENSITIVE,                       ResultSet.CONCUR_UPDATABLE); String sql = "SELECT id, name, age FROM Students";ResultSet rs = stmt.executeQuery(sql);//结果集中插入新行rs.moveToInsertRow();rs.updateInt("id",5);rs.updateString("name","John");rs.updateInt("age",21);//更新数据库rs.insertRow();</code></pre><h2 id="练习题：根据多种条件进行查询"><a href="#练习题：根据多种条件进行查询" class="headerlink" title="练习题：根据多种条件进行查询"></a>练习题：根据多种条件进行查询</h2><p>启动数据库</p><pre><code>$ sudo service mysql start</code></pre><p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下：</p><pre><code>create database test;use test;CREATE TABLE user(id int PRIMARY KEY,name varchar(50),age int,sex varchar(10) );INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (1, 'shi', 20, '男');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (2, 'yan', 13, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (3, 'lou', 22, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (4, 'admin', 50, '男');</code></pre><p>在/home/project目录下创建一个文件QueryDemo.java，使用 jdbc 完成以下查询：</p><ul><li><p>查询 Id 为 1 的用户</p></li><li><p>查询年龄为 12 岁，名字为 yan 的用语</p></li><li><p>查询年龄大于 20 岁的用户<br>JDBC 驱动下载：</p><p>$ wget <a href="http://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar">http://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar</a></p></li></ul><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.sql.*;public class QueryDemo {// JDBC 驱动器的名称和数据库地址private static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";private static final String DB_URL = "jdbc:mysql://localhost/test";private static final String USER = "root";private static final String PASS = "";public static void main(String[] args) {    Connection conn = null;    PreparedStatement stmt = null;    try {        Class.forName(JDBC_DRIVER);        conn = DriverManager.getConnection(DB_URL, USER, PASS);        //id为1的用户        String sql = "select id,name,age,sex from user where id=?";        stmt = conn.prepareStatement(sql);        stmt.setInt(1, 1);        ResultSet resultSet = stmt.executeQuery();        printRS(resultSet);        //年龄为12 名字为yan        stmt = conn.prepareStatement("select id,name,age,sex from user where age=? and name=?");        stmt.setInt(1, 12);        stmt.setString(2, "yan");        resultSet = stmt.executeQuery();        printRS(resultSet);        //年龄为12 名字为yan        stmt = conn.prepareStatement("select id,name,age,sex from user where age&gt;?");        stmt.setInt(1, 20);        resultSet = stmt.executeQuery();        printRS(resultSet);        //清理        resultSet.close();    } catch (Exception e) {        e.printStackTrace();    } finally {        try {            if (stmt != null) {                stmt.close();            }        } catch (SQLException e) {            e.printStackTrace();        }        try {            if (conn != null) {                conn.close();            }        } catch (SQLException se) {            se.printStackTrace();        }    }}private static void printRS(ResultSet resultSet) throws SQLException {    while (resultSet.next()) {        int id = resultSet.getInt("id");        String name = resultSet.getString("name");        int age = resultSet.getInt("age");        String sex = resultSet.getString("sex");        System.out.println("id:" + id + " name:" + name + " age:" + age + " sex:" + sex);    }}}</code></pre><h2 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h2><p>我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务。</p><p>让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败。</p><p>如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开。</p><p>例如:</p><pre><code>Connection conn = null;conn = DriverManager.getConnection(URL);//关闭自动提交conn.setAutoCommit(false);</code></pre><p>我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用 commit() 方法:</p><pre><code>conn.commit();</code></pre><p>尤其不要忘记，在 catch 块内添加回滚事务，表示操作出现异常，撤销事务：</p><pre><code>conn.rollback();</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>JDBC 插入数据使用的频率非常高，接下来说明如何使用 JDBC 插入数据。</p><p>编程实战</p><p>创建数据库(若之前已经创建了 Students 表需提前删除再操作)</p><pre><code>sudo service mysql startmysql -u root create database EXAMPLE;use EXAMPLE;create table Students(    id int not null,    age int not null,    name varchar(255),    primary key(id));</code></pre><p>在/home/project目录下新建一个JdbcInsertTest.java。</p><pre><code>import java.sql.*;public class JdbcInsertTest {public static Connection connection = null;public static void main(String[] args) {    try {        Class.forName("com.mysql.jdbc.Driver");        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/EXAMPLE", "root", "");        Statement statement = connection.createStatement();        //单条插入        boolean execute = statement.execute("insert into Students values (0,1,'shiyanlou')");        if (execute) {            System.out.println("插入失败");        }else {            System.out.println("单条插入成功");        }        // 批量插入  需要关闭自动提交        connection.setAutoCommit(false);        String sql = "insert into Students values (?,?,?)";        PreparedStatement preparedStatement = connection.prepareStatement(sql);        //设置插入的值        for (int i = 1; i &lt;= 10; i++) {            preparedStatement.setInt(1, i);            preparedStatement.setInt(2, i + 10);            preparedStatement.setString(3, "shiyanlou");            preparedStatement.addBatch();        }        //执行批量插入，使用executeBatch 方法        preparedStatement.executeBatch();        //提交到数据库        connection.commit();        System.out.println("提交批量插入完成");    } catch (ClassNotFoundException | SQLException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行：</p><pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar $ javac -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest.java     $ java -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest   单条插入成功 提交批量插入完成 </code></pre><p>如果成功运行，进入数据库查看数据是否有增加</p><pre><code>mysql -u rootuse EXAMPLE;select * from Students;</code></pre><h2 id="练习题：插入数据"><a href="#练习题：插入数据" class="headerlink" title="练习题：插入数据"></a>练习题：插入数据</h2><p>启动数据库</p><pre><code>$ sudo service mysql start</code></pre><p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下：</p><pre><code>create database test;use test;CREATE TABLE user(id int PRIMARY KEY,name varchar(50),age int,sex varchar(10));</code></pre><p>在/home/project目录下创建一个文件InsertDemo.java，使用 jdbc 完成以下操作：</p><p>将用户 id：10，name：shiyanlou，age：22，sex：男 插入到数据库<br>JDBC 驱动下载：</p><pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/110/mysql-connector-java-5.1.47.jar</code></pre><h2 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.sql.*;public class InsertDemo {public static Connection connection = null;public static void main(String[] args) {    try {        Class.forName("com.mysql.jdbc.Driver");        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "");        Statement statement = connection.createStatement();        statement.execute("insert into user values (10,'shiyanlou',22,'男')");        statement.close();        connection.close();    } catch (ClassNotFoundException | SQLException e) {        e.printStackTrace();    }finally {        try {            connection.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要讲解 Java 如何通过 JDBC 对数据库链接以及操作，主要包含以下知识点：</p><ul><li>SQL 简介</li><li>JDBC</li><li>创建数据库</li><li>数据库操作</li><li>JDBC 结果集</li><li>插入数据</li></ul><p>请大家务必手动完成代码并运行对比结果，才能更好的理解掌握 JDBC。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2017/05/19/duo-xian-cheng/"/>
      <url>/2017/05/19/duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。本节主要讲解 Java 多线程的一些概念以及其实现。</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。<br>如同大自然中的万物，线程也有“生老病死”的过程，下图表示了一个线程从创建到消亡的过程，以及过程中的状态。<br><img src="http://image.lichongbing.com/static/7b839a5058a09af7ad61445c2ab78608.jpeg" alt="wm-5.jpeg"></p><p>结合线程的生命周期来看看多线程的定义：</p><p>多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作。<br>在 Java 中，垃圾回收机制就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处。</p><p>从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解。</p><p>对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（Thread）。</p><h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><p>Java 中的Thread类就是专门用来创建线程和操作线程的类。</p><p>创建线程</p><p>创建线程的方法：</p><p>继承 Thread 类并重写它的run()方法，然后用这个子类来创建对象并调用start()方法。<br>定义一个类并实现 Runnable 接口，实现run()方法。<br>总的来说就是线程通过 start()方法启动而不是 run()方法，run()方法的内容为我们要实现的业务逻辑。</p><p>编程实例</p><p>在/home/project/目录下新建一个类CreateThread。</p><p>代码片段如下：</p><pre><code>public class CreateThread {public static void main(String[] args) {    Thread1 thread1 = new Thread1();    //声明一个Thread1对象，这个Thread1类继承自Thread类的    Thread thread2 = new Thread(new Thread2());    //传递一个匿名对象作为参数    thread1.start();    thread2.start();    //启动线程}</code></pre><p>}</p><pre><code>class Thread1 extends Thread {@Overridepublic void run() {    //在run()方法中放入线程要完成的工作    //这里我们把两个线程各自的工作设置为打印100次信息    for (int i = 0; i &lt; 100; ++i) {        System.out.println("Hello! This is " + i);    }    //在这个循环结束后，线程便会自动结束}}class Thread2 implements Runnable {//与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造@Overridepublic void run() {    for (int i = 0; i &lt; 100; ++i) {        System.out.println("Thanks. There is " + i);    }}}</code></pre><p>编译运行</p><pre><code>$ javac CreateThread.java$ java CreateThreadHello! This is 0Hello! This is 1Hello! This is 2Thanks. There is 0Thanks. There is 1Hello! This is 3Hello! This is 4Thanks. There is 2 ........</code></pre><p>你在控制台就可以看到两个线程近似交替地在输出信息。受到系统调度的影响，两个线程输出信息的先后顺序可能不同。</p><h2 id="线程变量"><a href="#线程变量" class="headerlink" title="线程变量"></a>线程变量</h2><p>ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。<br>可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。</p><p><strong>编程实例</strong><br>在/home/project/目录下新建一个源代码文件ThreadLocalDemo.java</p><pre><code>public class ThreadLocalDemo {public static void main(String[] args) {    ThreadDemo threadDemo = new ThreadDemo();    //启动2个线程    new Thread(threadDemo).start();    new Thread(threadDemo).start();}}class ThreadDemo implements Runnable {//使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);@Overridepublic void run() {    for (int i = 0; i &lt; 10; i++) {        //get方法获取线程变量值        Integer integer = threadLocal.get();        integer += 1;        //set方法设置线程变量值        threadLocal.set(integer);        System.out.println(integer);    }}}</code></pre><p>编译运行：</p><pre><code>$ javac ThreadLocalDemo.java$ java ThreadLocalDemo1122334455667788910910</code></pre><p>通过控制台的结果可以看到，两个线程之间的变量互不干涉。</p><p>线程共享变量</p><p>如果我们去掉了 ThreadLocal，其他的流程都不改变，已经使用 2 个线程自增变量会如何呢？</p><p>修改ThreadLocalDemo.java</p><pre><code>public class ThreadLocalDemo {public static void main(String[] args) {    ThreadDemo threadDemo = new ThreadDemo();    new Thread(threadDemo).start();    new Thread(threadDemo).start();}}class ThreadDemo implements Runnable {private Integer integer = 0;@Overridepublic void run() {    for (int i = 0; i &lt; 10; i++) {        integer++;        System.out.println(integer);    }}}</code></pre><p>编译运行：</p><pre><code>$ javac ThreadLocalDemo.java$ java ThreadLocalDemo1345678910112121314151617181920</code></pre><p>在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象threadDemo的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问。</p><p>Synchronized</p><p>关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法：</p><ul><li>对普通方式使用，将会锁住当前实例对象</li><li>对静态方法使用，将会锁住当前类的 Class 对象</li><li>对代码块使用，将会锁住代码块中的对象<br>使用示例</li></ul><p>在下面的代码中，演示了三种加锁方式。</p><pre><code>public class SynchronizedDemo {private static Object lock = new Object();public static void main(String[] args) {    //同步代码块 锁住lock    synchronized (lock) {        //doSomething    }}//静态同步方法  锁住当前类class对象public synchronized static void staticMethod(){}//普通同步方法  锁住当前实例对象public synchronized void memberMethod() {}}</code></pre><h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h2><p>java.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等。</p><h2 id="Lock-与-Unlock"><a href="#Lock-与-Unlock" class="headerlink" title="Lock 与 Unlock"></a>Lock 与 Unlock</h2><p>JUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能。</p><h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2><p>在/home/project/目录下新建一个源代码文件LockDemo.java</p><pre><code>import java.util.concurrent.locks.ReentrantLock;public class LockDemo {private static ReentrantLock lock = new ReentrantLock();public static void main(String[] args) {    Thread thread1 = new Thread(() -&gt; {        lock.lock();        try {            //需要同步的代码块            System.out.println("线程1加锁");        }finally {//          一定要在finally中解锁，否则可能造成死锁            lock.unlock();            System.out.println("线程1解锁");        }    });    thread1.start();    Thread thread2 = new Thread(() -&gt; {        lock.lock();        try {            System.out.println("线程2加锁");        }finally {            lock.unlock();            System.out.println("线程2解锁");        }    });    thread2.start();}}</code></pre><p>编译运行：</p><pre><code>$ javac LockDemo.java$ java LockDemo线程1加锁线程1解锁线程2加锁线程2解锁</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在多线程环境下，锁的使用非常频繁，但是它会带来一下问题，比如死锁。当死锁发生时，系统将会瘫痪。比如两个线程互相等待对方释放锁。</p><p>死锁示例</p><p>在/home/project/目录下新建一个源代码文件DeadLockDemo.java。</p><pre><code>public class DeadLockDemo {private static Object lockA = new Object();private static Object lockB = new Object();public static void main(String[] args) {    //这里使用lambda表达式创建了一个线程      //线程  1    new Thread(() -&gt; {        synchronized (lockA) {            try {                //线程休眠一段时间  确保另外一个线程可以获取到b锁                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("D");            synchronized (lockB) {            }        }    }).start();    //线程 2    new Thread(() -&gt; {        synchronized (lockB) {            System.out.println("死锁...");            synchronized (lockA) {            }        }    }).start();}}</code></pre><p>编译运行：</p><pre><code>$ javac DeadLockDemo.java$ java DeadLockDemo死锁...死锁...</code></pre><p>在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。</p><p>比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程的声明周期共有 6 种状态，分别是：新建New、运行（可运行）Runnable、阻塞Blocked、计时等待Timed Waiting、等待Waiting和终止Terminate。</p><p>当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象。<br>调用start()方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了。<br>调用了sleep()方法、调用wait()方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态。<br>当run()方法执行结束后，线程也就终止了。<br>我们通过一个例子来加深对于这些状态的理解。<br>在/home/project/目录下新建ThreadState类，用于自定义线程的状态。</p><p>主要的代码如下：</p><pre><code>public class ThreadState implements Runnable {public synchronized void waitForAMoment() throws InterruptedException {    wait(500);    //使用wait()方法使当前线程等待500毫秒    //或者等待其他线程调用notify()或notifyAll()方法来唤醒}public synchronized void waitForever() throws InterruptedException {    wait();    //不填入时间就意味着使当前线程永久等待，    //只能等到其他线程调用notify()或notifyAll()方法才能唤醒}public synchronized void notifyNow() throws InterruptedException {    notify();    //使用notify()方法来唤醒那些因为调用了wait()方法而进入等待状态的线程}@Overridepublic void run() {    //这里用异常处理是为了防止可能的中断异常    //如果任何线程中断了当前线程，则抛出该异常    try {        waitForAMoment();        // 在新线程中运行waitMoment()方法        waitForever();        // 在新线程中运行waitForever()方法    } catch (InterruptedException e) {        e.printStackTrace();    }}}</code></pre><p>然后再新建一个测试类ThreadTest，用于输出这些状态。</p><p>接下来会用到sleep()方法，下面给出了这个方法的使用方法。</p><p>sleep()，在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。填入的参数为休眠的时间（单位：毫秒）。</p><pre><code> public class ThreadTest { public static void main(String[] args) throws InterruptedException {    ThreadState state = new ThreadState();    //声明并实例化一个ThreadState对象    Thread thread = new Thread(state);    //利用这个名为state的ThreadState对象来创建Thread对象    System.out.println("Create new thread: " + thread.getState());    //使用getState()方法来获得线程的状态，并进行输出    thread.start();     //使用thread对象的start()方法来启动新的线程    System.out.println("Start the thread: " + thread.getState());    //输出线程的状态    Thread.sleep(100);     //通过调用sleep()方法使当前这个线程休眠100毫秒，从而使新的线程运行waitForAMoment()方法    System.out.println("Waiting for a moment (time): " + thread.getState());    //输出线程的状态    Thread.sleep(1000);     //使当前这个线程休眠1000毫秒，从而使新的线程运行waitForever()方法    System.out.println("Waiting for a moment: " + thread.getState());    //输出线程的状态    state.notifyNow();     // 调用state的notifyNow()方法    System.out.println("Wake up the thread: " + thread.getState());    //输出线程的状态    Thread.sleep(1000);     //使当前线程休眠1000毫秒，使新线程结束    System.out.println("Terminate the thread: " + thread.getState());    //输出线程的状态}}</code></pre><p>检查一下代码，编译并运行</p><pre><code>$ javac ThreadState.java ThreadTest.java$ java ThreadTestCreate new thread: NEWStart the thread: RUNNABLEWaiting for a moment (time): TIMED_WAITINGWaiting for a moment: WAITINGWake up the thread: BLOCKEDTerminate the thread: TERMINATED</code></pre><h2 id="练习题：顺序打印字母"><a href="#练习题：顺序打印字母" class="headerlink" title="练习题：顺序打印字母"></a>练习题：顺序打印字母</h2><p>在/home/project/目录下新建文件ThreadTest.java</p><p>你需要完成以下需求：</p><p>创建三个线程输出 A、B、C 三个字符。<br>要求 A、B、C 必须顺序输出，连续输出三次。<br>结果如下:</p><pre><code>ABCABCABC</code></pre><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ThreadTest {private static ReentrantLock lock = new ReentrantLock();private static int count = 0;private static Condition condition = lock.newCondition();public static void main(String[] args) {    Thread A = new Thread(() -&gt; {    //加锁 一次只有一个线程输出        lock.lock();        try {            while (true) {            //因为只循环3次 所以到9的时候就结束循环                if (count == 9) {                    break;                }                //当余数为0 就输出A                if (count % 3 == 0) {                    count++;                    System.out.println("A");                    //唤醒其他等待线程                    condition.signalAll();                } else {                    try {                    //等待                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        } finally {            lock.unlock();        }    });    Thread B = new Thread(() -&gt; {        lock.lock();        try {            while (true) {                if (count == 9) {                    break;                }                if (count % 3 == 1) {                    count++;                    System.out.println("B");                    condition.signalAll();                } else {                    try {                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        } finally {            lock.unlock();        }    });    Thread C = new Thread(() -&gt; {        lock.lock();        try {            while (true) {                if (count == 9) {                    break;                }                if (count % 3 == 2) {                    count++;                    System.out.println("C");                    condition.signalAll();                } else {                    try {                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        } finally {            lock.unlock();        }    });    A.start();    B.start();    C.start();}}</code></pre><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是由数组支持的有界阻塞队列。位于java.util.concurrent包下。</p><p>首先看看其构造方法:<br><img src="http://image.lichongbing.com/static/1eb4d958dba5f7d8e3704577e25c0761.png" alt="截屏2019-12-1014.19.58.png"></p><h2 id="编程实战-1"><a href="#编程实战-1" class="headerlink" title="编程实战"></a>编程实战</h2><p>在/home/project/目录下新建源代码文件ABQDemo.java</p><pre><code> import java.util.concurrent.ArrayBlockingQueue; public class ABQDemo {//构建大小为10的阻塞队列private static ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(10);public static void main(String[] args) {    Thread thread1 = new Thread(() -&gt; {        for (int i = 1; i &lt;= 10; i++) {            arrayBlockingQueue.add(i);        }    });    thread1.start();    try {        //等待线程1执行完毕        thread1.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    new Thread(() -&gt; {        //如果插入失败        if (!arrayBlockingQueue.offer(11)) {            System.out.println("插入元素11失败");        }        try {            //一直阻塞直到插入元素11，注意这里阻塞的不是主线程，main方法还是继续运行            arrayBlockingQueue.put(11);        } catch (InterruptedException e) {            e.printStackTrace();        }    }).start();    Thread thread2=new Thread(() -&gt; {        Integer element;        System.out.println("开始出队:");        //打印队列中的元素        while ((element = arrayBlockingQueue.poll()) != null) {            System.out.print("\t"+element);        }    });    thread2.start();}}</code></pre><p>编译运行：</p><pre><code> $ javac ABQDemo.java $ java ABQDemo 插入元素11失败 开始出队:      1    2    3    4    5    6    7    8    9    10    11</code></pre><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度。举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待。</p><h2 id="编程实战-2"><a href="#编程实战-2" class="headerlink" title="编程实战"></a>编程实战</h2><p>在/home/project目录下新建一个源代码文件PCModel.java</p><pre><code>import java.util.Random;import java.util.concurrent.LinkedBlockingQueue;public class PCModel {//阻塞队列private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();public static void main(String[] args) {    //生产者    Thread provider = new Thread(() -&gt; {        Random random = new Random();        for (int j = 0; j &lt; 5; j++) {            try {                int i = random.nextInt();                //注释直到插入数据                queue.put(i);                System.out.println("生产数据：" + i);                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    //消费者    Thread consumer = new Thread(() -&gt; {        Integer data;        for (int i = 0; i &lt; 5; i++) {            try {                //阻塞直到取出数据                data = queue.take();                System.out.println("消费数据：" + data);                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    //启动线程    provider.start();    consumer.start();}}</code></pre><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>在/home/project目录下新建一个源代码文件ProviderConsumerTest.java，你需要完成以下需求：</p><ul><li>参照编程实例，启动多个生产者和消费者生成和消费数据<br>注意：不要直接使用上面的编程实例直接使用多个provider.start()或者consumer.start()，会抛出异常报错，应该重新实例化多个生产者和消费者，不能一个实例启动多次</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。<br>由于 Java 创建和销毁线程都会带来资源上的销毁，所以线程池可以帮助我们复用线程，减少资源消耗。</p><h2 id="编程实战-3"><a href="#编程实战-3" class="headerlink" title="编程实战"></a>编程实战</h2><p>Java 线程池可以通过 Executors 工具类创建，Executors 常用方法：</p><ul><li>newFixedThreadPool(int nThreads):创建一个固定大小为 n 的线程池</li><li>newSingleThreadExecutor():创建只有一个线程的线程池</li><li>newCachedThreadPool():创建一个根据需要创建新线程的线程池</li></ul><p>在/home/project/目录下新建源代码文件ThreadPoolDemo.java</p><pre><code>import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo {//使用Executors 创建一个固定大小为5的线程池private static ExecutorService executorService = Executors.newFixedThreadPool(5);public static void main(String[] args) { //        提交任务    executorService.submit(() -&gt; {        for (int i = 0; i &lt; 10; i++) {            System.out.print(i + " ");        }    });    //停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭    executorService.shutdown();}}</code></pre><p>编译运行：</p><pre><code>$ javac ThreadPoolDemo.java$ java ThreadPoolDemo0 1 2 3 4 5 6 7 8 9 </code></pre><p>除了使用 Executors 工具类帮助我们创建之外，也可以直接创建线程池。</p><p>在/home/project/目录下新建源代码文件ThreadPoolDemo2.java</p><pre><code>import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolDemo2 {private static ExecutorService executorService = new ThreadPoolExecutor(        5, //核心线程数为5        10,//最大线程数为10        0L, TimeUnit.MILLISECONDS,//非核心线程存活时间        new LinkedBlockingQueue&lt;&gt;());//任务队列 public static void main(String[] args) {    //提交任务    executorService.submit(() -&gt; {        for (int i = 0; i &lt; 10; i++) {            System.out.print(i + " ");        }    });    //关闭线程池    executorService.shutdown();}}</code></pre><p>编译运行：</p><pre><code>$ javac ThreadPoolDemo2.java$ java ThreadPoolDemo2 0 1 2 3 4 5 6 7 8 9 </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要内容是对 Java 多线程进行讲解，主要包含以下知识点：</p><ul><li>多线程的实现</li><li>线程变量</li><li>线程同步</li><li>Lock 与 Unlock</li><li>死锁</li><li>线程生命周期</li><li>ArrayBlockingQueue</li><li>生产者消费者模式</li><li>线程池<br>请大家务必手动完成代码并运行对比结果，这样才能更好的理解并掌握 Java 网络编程，如果还想深入学习多线程编程，可以继续学习 Java 实现简单的支付平台业务流程课程。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2017/05/18/wang-luo-bian-cheng/"/>
      <url>/2017/05/18/wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。本节重点讲解 Java 网络编程中的常用类，以及计算机网络的一些基础知识。</p><h2 id="Socket-简介"><a href="#Socket-简介" class="headerlink" title="Socket 简介"></a>Socket 简介</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket。 建立网络通信连接至少要一对端口号(socket)。socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。 Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。<br>应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17。<br>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议。<br>与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。</p><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。我们可以使用它来发起网络请求，获取服务器的相关资源。</p><p><strong>编程实战</strong></p><p>HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用 HttpURLConnection 类的基本流程，想要了解更多方法的同学可以查询API 文档<br>在/home/project/目录下新建源代码文件HttpUrlTest.java</p><pre><code>import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpUrlTest {public static void main(String[] args) {    try {        //设置url        URL shiyanlou = new URL("https://www.shiyanlou.com");        //打开连接        HttpURLConnection urlConnection = (HttpURLConnection)shiyanlou.openConnection();        //设置请求方法        urlConnection.setRequestMethod("GET");        //设置连接超时时间        urlConnection.setConnectTimeout(1000);        //获取输入流        InputStream inputStream = urlConnection.getInputStream();        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));        //打印结果        bufferedReader.lines().forEach(System.out::println);        //关闭连接        inputStream.close();        bufferedReader.close();        urlConnection.disconnect();    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行</p><pre><code>  $ javac HttpUrlTest.java  $ java HttpUrlTest  &lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt;.....内容过长省略.....&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果没有问题的话，那么我们将看到实验楼首页的 html 源代码。</p><h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><p>InetAddress类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类。</p><p>InetAddress没有公共构造方法，我们只能使用它提供的静态方法来构建一个InetAddress类实例</p><ul><li>getLocalHost(): 返回本地主机地址</li><li>getAllByName（String host）：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联。</li><li>getByAddress（byte [] addr）：从原始 IP 地址的字节数组中返回一个 InetAddress 对象。</li><li>getByName（String host）：根据提供的主机名创建一个 InetAddress 对象。</li><li>getHostAddress（）：返回文本表示的 IP 地址字符串。</li><li>getHostname（）：获取主机名。<h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2></li></ul><p>在/home/project目录下新建一个InetAddressDemo.java。</p><pre><code> import java.net.InetAddress; import java.net.UnknownHostException; public class InetAddressDemo { public static void main(String[] args) {    try {        InetAddress shiyanlou = InetAddress.getByName("www.shiyanlou.com");        //toString 方法将输出主机名和ip地址        System.out.println(shiyanlou.toString());        //获取ip地址        String ip = shiyanlou.toString().split("/")[1];        //根据IP地址获取主机名        InetAddress byAddress = InetAddress.getByName(ip);        System.out.println("get hostname by IP address:" + byAddress.getHostName());        System.out.println("localhost: "+InetAddress.getLocalHost());    } catch (UnknownHostException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行：</p><pre><code> javac InetAddressDemo.java java InetAddressDemo</code></pre><p>运行结果：</p><pre><code> www.shiyanlou.com/115.29.233.149 get hostname by IP address:www.shiyanlou.comlocalhost: user-441493.weave.local/192.168.42.16</code></pre><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket类代表一个客户端套接字，可以使用该类想服务器发送和接受数据。一般需要通过下面几个步骤：</p><ul><li>建立与服务器的连接</li><li>使用输出流将数据发送到服务器</li><li>使用输入流读取服务器返回的数据</li><li>关闭连接</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>Socket 常用构造方法：</p><ul><li>Socket(InetAddress address, int port)：创建一个套接字，连接到指定 IP 地址和端口的服务器</li><li>Socket(String host, int port)：创建一个套接字，连接到指定的主机名和端口的服务器</li><li>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口。</li></ul><p>在创建 Socket 时，需要捕获异常。</p><h2 id="getOutputStream"><a href="#getOutputStream" class="headerlink" title="getOutputStream()"></a>getOutputStream()</h2><p>该方法可以获取输出流，在建立连接后，可以使用该方法获取输出流，发送数据到服务器。发送数据的方式和使用 IO 流是相同的，使用 write 方法发送指定的数据即可。</p><h2 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream()"></a>getInputStream()</h2><p>用户获取输入流，通过该方法获取输入流之后可以读取服务器发送来的数据。使用方法和 IO 流相同，使用 read 方法即可。</p><h2 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h2><p>关闭 Socket，可能抛出 IO 异常，所以我们同样需要捕获异常。</p><h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>ServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。</p><p>创建一个ServerSocket一般需要以下几个步骤：</p><ul><li><p>创建服务器套接字并将其绑定到特定的接口</p></li><li><p>等待客户端连接</p></li><li><p>通过客户端套接字获取输入流，从客户端读取数据</p></li><li><p>通过客户端套接字获取输出流，发送数据到客户端</p></li><li><p>关闭套接字</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>常见构造方法：</p></li><li><p>ServerSocket()：创建一个未绑定端口的服务器套接字。</p></li><li><p>ServerSocket(int port)：创建绑定到指定端口号的服务器套接字。</p></li><li><p>ServerSocket(int port,int backlog)：创建一个绑定到指定端口号的服务器套接字，并且backlog 参数指定了最大排队连接数。</p></li><li><p>ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址。<br>示例：</p></li></ul><pre><code>ServerSocket serverSocket = new ServerSocket(8888);</code></pre><h2 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h2><p>用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个Socket对象。</p><h2 id="close-）"><a href="#close-）" class="headerlink" title="close(）"></a>close(）</h2><p>用于关闭服务器套接字，服务器停止后，将断开所有连接。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>可以查阅<a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html">官方文档</a></p><h2 id="网络编程实例"><a href="#网络编程实例" class="headerlink" title="网络编程实例"></a>网络编程实例</h2><p>java.net 包提供了两个类Socket和ServerSocket，分别实现 Socket 连接的客户端和服务器端。</p><p>我们编译一个简单的 Socket 应用，实现客户端发送信息给服务端，服务端再将信息发送回客户端的回显的功能。</p><p>在/home/project/目录下新建源代码文件EchoServer.java</p><pre><code> import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; public class EchoServer {    public static void main(String[] args) {    try {        //服务端需要使用ServerSocket类        ServerSocket serverSocket = new ServerSocket(1080);        //阻塞 等待客户端连接        Socket client = serverSocket.accept();        PrintWriter out = new PrintWriter(client.getOutputStream(), true);        BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));        String userIn;        while ((userIn = in.readLine()) != null) {            System.out.println("收到客户端消息：" + userIn);            //发回客户端            out.println(userIn);        }    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>在/home/project/目录下新建源代码文件EchoClient.java</p><pre><code> import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; import java.util.Scanner;public class EchoClient {public static void main(String[] args) {    String hostname = "127.0.0.1";    //socket端口    int port = 1080;    Scanner userIn = new Scanner(System.in);    try {        //建立socket连接        Socket socket = new Socket(hostname, port);        //获取socket输出流        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);        //获取输入流        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));        String userInput;        System.out.println("请输入信息：");        //当用户输入exit时退出        while (!"exit".equals(userInput = userIn.nextLine())) {            out.println(userInput);            System.out.println("收到服务端回应:" + in.readLine());        }        //关闭socket        socket.close();    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行：<br>打开两个 terminal，一个运行服务端，一个运行客户端。 首先启动服务端，不能先启动客户端，否则报错。<br>服务端启动命令：</p><pre><code>$ javac EchoServer.java$ java EchoServer</code></pre><p>接着切换到客户端 terminal。客户端启动命令</p><pre><code>$ javac EchoClient.java$ java EchoClient</code></pre><p>运行结果：</p><p>客户端</p><pre><code>请输入信息：shi收到服务端回应:shiyan收到服务端回应:yanlou收到服务端回应:louexit</code></pre><p>服务端</p><pre><code>收到客户端消息：shi收到客户端消息：yan收到客户端消息：lou</code></pre><h2 id="练习题：多线程服务器"><a href="#练习题：多线程服务器" class="headerlink" title="练习题：多线程服务器"></a>练习题：多线程服务器</h2><p>在/home/project/目录下新建源代码文件Server.java和Client.java</p><p>你需要完成以下要求：</p><ul><li>Server 可以同时接受多个客户端的连接</li><li>每个线程负责一个连接</li><li>客户端发送消息给服务端，服务端再将客户端发送的消息发回客户端</li></ul><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><p>client:</p><pre><code>import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class Client {public static void main(String[] args) {    String hostname = "127.0.0.1";    //socket端口    int port = 1080;    Scanner userIn = new Scanner(System.in);    try {        //建立socket连接        Socket socket = new Socket(hostname, port);        //获取socket输出流        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);        //获取输入流        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));        String userInput;        System.out.println("请输入信息：");        //当用户输入exit时退出        while (!"exit".equals(userInput = userIn.nextLine())) {            out.println(userInput);            System.out.println("收到服务端回应:" + in.readLine());        }        //关闭socket        socket.close();    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>server</p><pre><code> import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket;public class Server {public static void main(String[] args) {    try {        //服务端需要使用ServerSocket类        ServerSocket serverSocket = new ServerSocket(1080);        //阻塞 等待客户端连接        while (true) {            Thread thread = new Thread(new ServerThread(serverSocket.accept()));            thread.start();        }    } catch (IOException e) {        e.printStackTrace();    }}static class ServerThread implements Runnable {    Socket client;    public ServerThread(Socket client) {        this.client = client;    }    @Override    public void run() {        try {            PrintWriter out = new PrintWriter(client.getOutputStream(), true);            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));            String userIn;            while ((userIn = in.readLine()) != null) {                System.out.println("收到客户端消息：" + userIn);                //发回客户端                out.println(userIn);            }        } catch (IOException e) {            e.printStackTrace();        }    }}}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要内容是对 Java 网络编程进行讲解，主要包含以下知识点：</p><ul><li>TCP</li><li>UDP</li><li>HttpURLConnection</li><li>InetAddress 类</li><li>Socket 类</li><li>ServerSocket 类</li></ul><p>请大家务必手动完成代码并运行对比结果，这样才能更好的理解并掌握 Java 网络编程，如果还想深入学习网络编程，可以继续学习 J2SE 网络通信实践课程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2017/05/10/io/"/>
      <url>/2017/05/10/io/</url>
      
        <content type="html"><![CDATA[<p>整个 Java.io 包中最重要的就是 5 个类。指的是 File、OutputStream、InputStream、Writer、Reader；本节将重点讲解 Java.io 的相关内容。<br>Java 使用 File 类来直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它描述了文件本身的属性。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list( )方法检测的文件名列表。</p><p>构造方法</p><p>File 类提供了以下构造方法：</p><pre><code>//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 File(File parent, String child) //通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例       File(String pathname) // 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例File(String parent, String child) //通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例File(URI uri) </code></pre><p>使用示例</p><pre><code>//一个目录路径参数File f1 = new File("/home/project/");//对象有两个参数——路径和文件名File f2 = new File("/home/project/","a.bat");//指向f1文件的路径及文件名File f3 = new File(f1,"a.bat");</code></pre><p>常用方法</p><p>来看看 File 的一些常用方法<br><img src="http://image.lichongbing.com/static/30f56435bf8bb8fc694b5f95bb17d481.png" alt="截屏2019-12-1010.47.04.png"><br><img src="http://image.lichongbing.com/static/233f8f3d0f1f799781fd0301e6139655.png" alt="截屏2019-12-1010.48.03.png"><br><img src="http://image.lichongbing.com/static/487f409b3467a5a9192ef4979bd1d5a0.png" alt="截屏2019-12-1010.48.40.png"><br>编程实例</p><p>在/home/porject/目录下创建源代码文件FileDemo.java</p><pre><code>import java.io.File;import java.io.IOException;public class  FileDemo {public static void main(String[] args){    //同学们可以根据自己的路径进行更改    File f1 =new    File("/home/project/1.txt");    //File(String parent,String child)    File f2 =new File("/home/project","2.txt");    //separator 跨平台分隔符    File f3 =new File("/home"+File.separator+"project");    File f4 =new File(f3,"3.txt");    try {         System.out.println(f1);            //当文件存在时返回 false；不存在时返回 true            System.out.println(f2.createNewFile());            //当文件不存在时返回 false            System.out.println(f3.delete());    }catch(IOException e) {            e.printStackTrace();    }    //列出磁盘下的文件和文件夹    File[] files =File.listRoots();    for(File file:files){        System.out.println(file);        if(file.length()&gt;0){            String[] filenames =file.list();            for(String filename:filenames){                System.out.println(filename);            }        }    }}}</code></pre><p>编译运行：</p><pre><code>$ javac FileDemo.java$ java FileDemo</code></pre><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>java.io 包中提供了文件操作类：</p><p>用于读写本地文件系统中的文件：FileInputStream 和 FileOutputStream<br>描述本地文件系统中的文件或目录：File、FileDescriptor 和 FilenameFilter<br>提供对本地文件系统中文件的随机访问支持：RandomAccessFile<br>接下来将学习文件流的 FileInputStream 和 FileOutputStream 。</p><p>FileInputStream 类用于打开一个输入文件，若要打开的文件不存在，则会产生异常 FileNotFoundException，这是一个非运行时异常，必须捕获或声明抛弃；</p><p>FileOutputStream 类用来打开一个输出文件，若要打开的文件不存在，则会创建一个新的文件，否则原文件的内容会被新写入的内容所覆盖；</p><p>在进行文件的读/写操作时，会产生非运行时异常 IOException，必须捕获或声明抛弃（其他的输入/输出流处理时也同样需要进行输入/输出异常处理）。</p><p>文件流的构造方法</p><pre><code>//打开一个以 f 描述的文件作为输入FileInputStream(File f)//打开一个文件路径名为 name 的文件作为输入FileInputStream(String name)//创建一个以 f 描述的文件作为输出//如果文件存在，则其内容被清空FileOutputStream(File f)//创建一个文件路径名为 name 的文件作为输出//文件如果已经存在，则其内容被清空FileOutputStream(String name)//创建一个文件路径名为 name 的文件作为输出//文件如果已经存在，则在该输出上输出的内容被接到原有内容之后FileOutputStream(String name, boolean append)</code></pre><p>代码示例</p><pre><code>File f1 = new File("file1.txt");File f2 = new File("file2.txt");FileInputStream in = new FileInputStream(f1);FileOutputStream out = new FileOutputStream(f2);</code></pre><p>输入流的参数是用于指定输入的文件名，输出流的参数则是用于指定输出的文件名。</p><p>编程实战</p><p>使用输入流和输出将 file1.txt 的内容复制到 file2.txt。<br>在/home/project/目录下新建Txt文件file1.txt。填入内容比如shiyanlou。 在/home/project/目录下新建源代码文件Test.java</p><pre><code> import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class Test { public static void main(String[] args) {    try {        //inFile 作为输入流的数据文件必须存在，否则抛出异常        File inFile = new File("/home/project/file1.txt");        //file2.txt没有，系统可以创建        File outFile = new File("file2.txt");        FileInputStream fis = new FileInputStream(inFile);        FileOutputStream fos = new FileOutputStream(outFile);        int c;        while((c = fis.read()) != -1){            fos.write(c);        }        //打开了文件一定要记着关，释放系统资源        fis.close();        fos.close();    }catch(FileNotFoundException e) {        System.out.println("FileStreamsTest:" + e);    }catch(IOException e){        System.err.println("FileStreamTest:" + e);    }}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java$ java Test</code></pre><p>运行完成后，打开 file2.txt，可以看到 file2 和 file1 有相同的内容。</p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>如果文件内容保存的是字符信息，如 txt 文件等，还可以使用 FileReader 来读取文件内容。</p><p>代码示例：</p><pre><code>FileReader file = new FileReader("/home/project/shiyanlou.txt");//声明一个文件输入流file，并指明该文件在系统中的路径以方便定位int data = 0;//声明一个整型变量用于存放读取的数据while((data=file.read())!=-1){//在while循环中使用read()方法持续读取file，数据赋到data中//如果读取失败或者结束，则将返回-1，这个特殊的返回值可以作为读取结束的标识System.out.print((char)data);//输出读取到数据}file.close();//一定要记得读取结束后要关闭文件</code></pre><h2 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h2><p>对于 FileInputStream/FileOutputStream、FileReader/FileWriter 来说，它们的实例都是顺序访问流，即只能进行顺序读/写。而类 RandomAccessFile 则允许文件内容同时完成读和写操作，它直接继承 object，并且同时实现了接口 DataInput 和 DataOutput。</p><p>随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。</p><p>RandomAccessFile 提供了支持随机文件操作的方法：</p><ul><li>readXXX()或者 writeXXX():如 ReadInt(),ReadLine(),WriteChar(),WriteDouble()等</li><li>int skipBytes(int n):将指针向下移动若干字节</li><li>length():返回文件长度</li><li>long getFilePointer():返回指针当前位置</li><li>void seek(long pos):将指针调用所需位置<br>在生成一个随机文件对象时，除了要指明文件对象和文件名之外，还需要指明访问文件的模式。</li></ul><p>来看看 RandomAccessFile 的构造方法：</p><pre><code>RandomAccessFile(File file,String mode)RandomAccessFile(String name,String mode)</code></pre><p>mode 的取值：</p><ul><li><p>r:只读，任何写操作都讲抛出 IOException</p></li><li><p>rw:读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容。</p></li><li><p>rws:打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</p></li><li><p>rwd:打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。</p><h2 id="练习题：随机访问文件"><a href="#练习题：随机访问文件" class="headerlink" title="练习题：随机访问文件"></a>练习题：随机访问文件</h2><p>在/home/project/目录下新建源代码文件RandomFile.java，你需要完成以下需求：</p></li><li><p>下载文件 randomAccess.file</p></li><li><p>从偏移量为 10 的位置开始读取文件 randomAccess.file 的内容</p></li><li><p>输出文件内容（以字符串形式，不能直接输出字节内容）</p></li></ul><p>文件下载：</p><pre><code>wget http://labfile.oss.aliyuncs.com/courses/1230/randomAccess.file</code></pre><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code> import java.io.File; import java.io.IOException; import java.io.RandomAccessFile; import java.util.Arrays;public class RandomFile {public static void main(String[] args) {    RandomAccessFile file;    try {        File d = new File("/home/project/randomAccess.file");        file = new RandomAccessFile(d, "rw");        file.seek(10);        byte[] b = new byte[(int) file.length()-10];        file.read(b);        System.out.println(new String(b));    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>在/home/project/目录下新建FileDemo.java</p><pre><code> // FileDemo.javaimport java.io.IOException;import java.io.RandomAccessFile;public class  FileDemo {public static void main(String[] args){        int data_arr[] = {12, 32, 43, 45, 1, 5};        try {            RandomAccessFile randf=new RandomAccessFile("temp.dat","rw");            for(int i = 0; i &lt; data_arr.length; i++){                randf.writeInt(data_arr[i]);            }            for(int i = data_arr.length-1 ; i &gt;= 0; i--){                //int 数据占4个字节                randf.seek(i * 4L);                System.out.println(randf.readInt());            }            randf.close();        }catch(IOException e){            System.out.println("File access error" + e);        }}}</code></pre><p>编译运行：</p><pre><code> $ javac FileDemo.java $ java FileDemo  5  1  45  43  32  12</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>在平时编写程序的时候，经常会对文件进行操作，比如文件的赋值，重命名，删除等。接下来学习使用 Java 操作文件。<br>可以使用 Files 工具类的 copy(Path source,Path target,CopyOption… options)拷贝文件或者目录。如果目标文件存在，那么赋值将失败，除非我们在 options 中指定了REPLACE_EXISTING属性。当该命令复制目录时，如果目录中已经有了文件，目录中的文件将不会被复制。CopyOption 参数支持以下 StandardCopyOption 和 LinkOption 枚举：</p><p>REPLACE_EXISTING - 即使目标文件已存在，也执行复制。如果目标是符号链接，则复制链接本身（而不是链接的目标）。如果目标是非空目录，则复制将失败并显示 FileAlreadyExistsException 异常。<br>COPY_ATTRIBUTES - 将与文件关联的文件属性复制到目标文件。支持的确切- 文件属性是文件系统和平台相关的，但 last-modified-time 跨平台支持并复制到目标文件。 NOFOLLOW_LINKS - 表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）。<br>编程实例</p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>在/home/project/目录下新建文件1.txt 在/home/project/目录下新建源代码文件CopyDemo.java</p><pre><code>import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class CopyDemo {public static void main(String[] args) {    try {        //被拷贝的文件一定要存在 否则会抛出异常  这里的1.txt一定要存在        Files.copy(Paths.get("/home/project/1.txt"), Paths.get("/home/project/2.txt"), StandardCopyOption.REPLACE_EXISTING);    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行：</p><pre><code>$ javac CopyDemo.java$ java CopyDemo</code></pre><p>查看目录，如果没有报错，那么可以看到 1.txt 已经被复制了一份，叫做 2.txt。</p><h2 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h2><p>Files 类的 move(Path, Path, CopyOption… options)方法移动文件或者目录，同样目标目录存在，那么比如使用REPLACE_EXISTING。 options 参数支持 StandardCopyOption 的以下枚举：</p><p>REPLACE_EXISTING - 即使目标文件已存在，也执行移动。如果目标是符号链接，则替换符号链接，但它指向的内容不受影响。<br>ATOMIC_MOVE - 将移动作为原子文件操作执行。如果文件系统不支持原子移动，则抛出异常。使用，ATOMIC_MOVE 您可以将文件移动到目录中，并保证观察目录的任何进程都可以访问完整的文件。<br>move 方法除了可以移动之外，也可以用与重命名。</p><p>编程实例： 在/home/project/目录下新建源代码文件MoveDemo.java</p><pre><code>import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class MoveDemo {public static void main(String[] args) {    try {        //将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可        Files.move(Paths.get("/home/project/1.txt"), Paths.get("/home/project/3.txt"), StandardCopyOption.REPLACE_EXISTING);    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行：</p><pre><code>$ javac MoveDemo.java$ java MoveDemorenameTo移动结果：true</code></pre><p>查看目录结构，可以看到之前的 1.txt 已经变成了 3.txt，2.txt变成了4.txt。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>可以通过 Files 的 delete(Path path)方法或者 deleteIfExists(Path path)方法删除文件。</p><p>编程实例： 在/home/project/目录下新建源代码文件DeleteDemo.java</p><pre><code>import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class DeleteDemo {public static void main(String[] args) {    try {        //删除文件，文件必须存在，否则抛出异常        Files.delete(Paths.get("/home/project/3.txt"));        //删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false        System.out.println(Files.deleteIfExists(Paths.get("/home/project/3.txt")));        //或者使用File类的delete方法        File file = new File("/home/project/4.txt");        System.out.println(file.delete());    } catch (IOException e) {        e.printStackTrace();    }}}$ javac DeleteDemo.java$ java DeleteDemofalsetrue</code></pre><p>再次查看文件目录，3.txt 、4.txt 已经不存在了。</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>Java 使用 File 类表示文件或者目录，可以通过 File 类获取文件或者目录的相关属性。</p><p>编程实例： 在/home/project/目录下新建源代码文件FileInfo.java</p><pre><code>import java.io.File;import java.util.Arrays;public class FileInfo {public static void main(String[] args) {    File file = new File("/home/project");    System.out.println("文件或者目录名：" + file.getName());    System.out.println("绝对路径：" + file.getAbsolutePath());    System.out.println("父目录：" + file.getParent());    System.out.println("文件路径：" + file.getPath());    //判断文件是否是目录    if (file.isDirectory()) {        //打印目录中的文件        Arrays.stream(file.list()).forEach(System.out::println);    }    System.out.println("是否隐藏：" + file.isHidden());    System.out.println("是否存在：" + file.exists());}}$ javac FileInfo.java$ java FileInfo文件或者目录名：project绝对路径：/home/project父目录：/home文件路径：/home/projectFileInfo.classFileInfo.java是否隐藏：false是否存在：true</code></pre><h2 id="目录读取"><a href="#目录读取" class="headerlink" title="目录读取"></a>目录读取</h2><p>Java 中读取目录中的文件可以直接使用 listFiles()方法读取，但是也只能读取当前目录中的文件，如果当前目录中还有二级目录如何解决呢？三级目录呢？接下来将使用 Java 读取当前目录和子目录中的所有文件。</p><p>编程实战</p><p>在/home/project/目录下新建源代码文件ReadDir.java</p><pre><code>import java.io.File;public class ReadDir {public static void main(String[] args) {    readDir(new File("/home"));}static void readDir(File file) {    if (file == null) {        return;    }    //如果当前file是目录    if (file.isDirectory()) {        File[] files;        //如果目录不为空        if ((files = file.listFiles()) != null) {            for (File file1 : files) {                //递归读取目录内容                readDir(file1);            }        }    } else {        //如果不是目录 直接输出文件名        System.out.println(file.getName());    }}}</code></pre><p>编译运行：</p><pre><code>$ javac ReadDir.java$ java ReadDir</code></pre><h2 id="练习题：目录树"><a href="#练习题：目录树" class="headerlink" title="练习题：目录树"></a>练习题：目录树</h2><p>在/home/project/目录下新建源代码文件PrintDirTree.java，你需要完成以下需求：</p><p>任意建立一个至少三层的目录<br>打印该目录以目录树的形式，就像这样</p><pre><code>src   main       java           a.java           b.java           c.java       resources   test      java          d.java          e.java</code></pre><p>提示：</p><ul><li><p>使用递归</p><h2 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><p>  import java.io.File;<br>  import java.io.IOException;</p><p>  public class PrintDirTree {</p><p>  public static void main(String[] args) {</p><pre><code>  printDirTree(new File("/home/"), "");</code></pre><p>  }</p><p>  public static void printDirTree(File file, String s) {</p><pre><code>  if (file.isDirectory()) {      File[] files;      System.out.println(s + file.getName());      if ((files = file.listFiles()) != null) {          s = s + "   ";          for (File file1 : files) {              printDirTree(file1, s);          }      }  } else {      System.out.println(s + file.getName());  }</code></pre><p>  }<br>  }</p><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><p>在大多数程序中，都需要对输入输出进行处理。例如我们中需要获取用户从键盘上的输入，需要在控制台输出结果等等。除此之外还有从文件中读取数据，向文件中写入数据等等。在 Java 中，我们把这些不同类型的输入输出源抽象地称为流，也就是Stream；在里面输入输出的数据则称为数据流（Data Stream），它们通常具有统一的接口。</p></li></ul><p>于是我们得到了数据流的定义：</p><ul><li><p>一个 Java I/O 对象叫做数据流。读取数据到内存的对象叫做输入流，内存写出数据的对象叫做输出流。<br>针对其面向的不同角度，我们大致可以将流分为下面几种类型：</p></li><li><p>按照数据流的方向不同分为输入流和输出流。这种分类不是绝对的，例如在向一个文件写入数据时，它就是输出流；而在读取数据时，它就是输入流。</p></li><li><p>按照处理数据的单位不同分为字节流和字符流。<br>按照功能的不同分为节点流和处理流。<br>需要特别说明，节点流是从特定的数据节点（文件、数据库、内存等）读写数据；处理流是连接在已有的流上，通过对数据的处理为程序提供更多功能。</p></li></ul><p>在 Java 环境中，java.io包提供了大多数的类和接口来实现输入输出管理。一些标准的输入输出则来自java.lang包中的类，但它们都是继承自java.io中的类。我们可以将输入流理解为数据的提供者，而把输出流理解为数据的接收者。在最初的时候，这些派生自抽象类InputStream和OutputStream的输入输出类是面向 8 位的字节流的。但为了支持国际化，又引入了派生自抽象类Reader和Writer的类层次，用于读写一些双字节的Unicode字符。</p><p>因此，在学习 java 的输入输出上，我们希望你以字节流和字符流作为区分来学习。</p><p>如果需要概括一下，则可以得到下面的定义：</p><ul><li>字节流：表示以字节为单位从 stream 中读取或往 stream 中写入信息。通常用来读取二进制数据。</li><li>字符流：以 Unicode 字符为单位从 stream 中读取或往stream 中写入信息。<br>按照这样的定义，Java 中流的层级结构可以通过下图来表示：<br><img src="http://image.lichongbing.com/static/712c8eb327ac29f4569783c0dc001783.jpeg" alt="wm-3.jpeg"><br>图中蓝色的部分均为抽象类，而绿色的部分则为派生类，是可以直接使用的。</li></ul><p>而下图简要说明了字节流和字符流的区别，你也可以进一步了解字节流与字符流的区别。<br><img src="http://image.lichongbing.com/static/2d17abf7c30891197e52dea54b6d0038.jpeg" alt="wm-4.jpeg"><br>我们知道 Java 是一门面向对象的语言，所以为了能够永久地保存对象的状态，java.io包还以字节流为基础，通过实现ObjectInput和ObjectOutput接口提供了对象流。在此仅作引入，你可以通过查阅 API 手册来详细了解它们。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，他们是抽象类，不能直接使用。字节流能处理所有类型的数据（如图片、avi等）。</p><p>InputStream</p><p>InputStream 是所有表示字节输入流的父类，继承它的子类要重新定义其中所定义的抽象方法。InputStream 是从装置来源地读取数据的抽象表示，例如 System 中的标准输入流 in 对象就是一个 InputStream 类型的实例。</p><p>InputStream 类方法<br><img src="http://image.lichongbing.com/static/9447655d6123ed5c48ced088bb66a98d.png" alt="截屏2019-12-1011.39.13.png"><br><img src="http://image.lichongbing.com/static/81ebf0917493a6ce31562813be65770d.png" alt="截屏2019-12-1011.39.55.png"><br>编程实例：</p><p>在/home/project/目录下新建源代码文件Test.java</p><pre><code>import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class Test {/** * 把输入流中的所有内容赋值到输出流中 * @param in * @param out * @throws IOException */public void copy(InputStream in, OutputStream out) throws IOException {    byte[] buf = new  byte[4096];    int len = in.read(buf);    //read 是一个字节一个字节地读，字节流的结尾标志是-1    while (len != -1){        out.write(buf, 0, len);        len = in.read(buf);    }}public static void main(String[] args) throws IOException {    // TODO Auto-generated method stub    Test t = new Test();    System.out.println("输入字符：");    t.copy(System.in, System.out);}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java$ java Test输入字符：abcabc</code></pre><p>一般来说，很少直接实现 InputStream 或 OutputStream 上的方法，因为这些方法比较低级，通常会实现它们的子类。</p><h2 id="练习题：文件分割"><a href="#练习题：文件分割" class="headerlink" title="练习题：文件分割"></a>练习题：文件分割</h2><p>在/home/project/目录下新建FileCut.java，你需要实现以下需求：</p><ul><li><p>从控制台读取一个数值 n。</p></li><li><p>在/home/project目录下新建一个文本文件 cut.txt，填入任意内容，尽量多输入一些字符。</p></li><li><p>将 cut.txt 文件平均分割，每份文件大小为 n 字节。</p></li><li><p>分割后的文件分别命名为 cut1.txt、cut2.txt … cutn.txt 保存在/home/project目录下。<br>提示：</p></li><li><p>获取文件所占字节大小，根据字节平均分割文件</p></li></ul><h2 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h2><p><code>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</code></p><pre><code> import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.Scanner; public class FileCut { public static void main(String[] args) {    Scanner in = new Scanner(System.in);    int n = in.nextInt();    File file = new File("/home/project/file.txt");    //需要分隔的文件份数    int num;    //如果不能整除，那么需要多加一个文件 用于保存剩余的数据    if (file.length() % n == 0) {        num = (int) (file.length() / n);    } else {        num = (int) (file.length() / n) + 1;    }    try {        FileInputStream fileInputStream = new FileInputStream(file);        byte[] bytes = new byte[(int) file.length()];        //读取文件到bytes        fileInputStream.read(bytes);        fileInputStream.close();        for (int i = 1; i &lt;= num; i++) {            //文件名            String fileName = "/home/project/cut" + i + ".txt";            FileOutputStream fileOutputStream = new FileOutputStream(fileName);            //最后一份文件需要特殊处理 因为他的大小不是n            if (i == num) { //   (file.length()-n*(i-1)) 文件的总字节数 再减去前面已经读取的字节数 就是剩余的字节数                fileOutputStream.write(bytes, n * (i - 1), (int) (file.length() - n * (i - 1)));            } else {                fileOutputStream.write(bytes, n * (i - 1), n);            }            fileOutputStream.flush();            fileOutputStream.close();        }    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p><code>字符流以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。</code></p><p>java.io 包中专门用于字符流处理的类，是以 Reader 和 Writer 为基础派生的一系列类。</p><p>同类 InputStream 和 OutputStream 一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法与类 InputStream 和 OutputStream 类似，只不过其中的参数换成字符或字符数组。</p><p>Reader 是所有的输入字符流的父类，它是一个抽象类。</p><p>我们先来看一看基类 Reader 的方法，其用法与作用都与 InputStream 和 OutputStream 类似，就不做过多的说明了。<br><img src="http://image.lichongbing.com/static/014ee0f3e5e2e3aeecbff4bed275d0d7.png" alt="截屏2019-12-1011.46.30.png"><br>在这里我们就列举一下有哪些类。</p><ul><li>对字符数组进行处理： CharArrayReader、CharArrayWrite</li><li>对文本文件进行处理：FileReader、FileWriter</li><li>对字符串进行处理：StringReader、StringWriter</li><li>过滤字符流：FilterReader、FileterWriter</li><li>管道字符流：PipedReader、PipedWriter</li><li>行处理字符流：LineNumberReader</li><li>打印字符流：PrintWriter<br>类有千万，方法更是不计其数，所以没有必要去掌握所有的方法和类，只需要知道常见常用的就行了，而大多数的类和方法，希望大家有一个印象，当我们在实际开发的时间，能够想到，并且借助其他工具去查询我们需要的方法的应用方式就可以了。<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2>InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。</li></ul><pre><code>InputStreamReader(InputStream in); //缺省规范说明//指定规范 encInputStreamReader(InputStream in, String enc);OutputStreamWriter(OutputStream out); //缺省规范说明//指定规范 encOutputStreamWriter(OutputStream out, String enc);</code></pre><p>如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符。</p><pre><code>InputStreamReader ir = new InputStreamReader(is,"8859_1");</code></pre><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率。</p><p>在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用32字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍。</p><p>BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read ()方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据。</p><p>BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作<br><img src="http://image.lichongbing.com/static/0c8d73070ac59eebe9b5cc60a8e20c98.png" alt="wm-23.png"><br>构造方法：</p><pre><code>//[ ]里的内容代表选填BufferedInputStream(InputStream in [, int size])BufferedOutputStream(OutputStream out [, int size])</code></pre><p>举个例子，将缓冲流与文件流相接：</p><pre><code>FileInputStream in = new FileInputStream("file.txt");FileOutputStream out = new FileOutputStream("file2.txt");//设置输入缓冲区大小为256字节BufferedInputStream bin = new BufferedInputStream(in,256)BufferedOutputStream bout = new BufferedOutputStream(out,256)int len;byte bArray[] = new byte[256];len = bin.read(bArray); //len 中得到的是实际读取的长度，bArray 中得到的是数据</code></pre><p><img src="http://image.lichongbing.com/static/801e864dc1b88d99518f578eebb9a350.png" alt="wm-24.png"><br>对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出。</p><p>例如方法 copy():</p><pre><code>public void copy(InputStream in, OutputStream out) throws IOException {out = new BufferedOutputStream(out, 4096);byte[] buf = new byte[4096];int len = in.read(buf);while (len != -1) {out.write(buf, 0, len);len = in.read(buf);}//最后一次读取得数据可能不到4096字节out.flush();}</code></pre><h2 id="BufferedReader-和-BufferedWrite"><a href="#BufferedReader-和-BufferedWrite" class="headerlink" title="BufferedReader 和 BufferedWrite"></a>BufferedReader 和 BufferedWrite</h2><p>同样的，为了提高字符流处理的效率，java.io 中也提供了缓冲流 BufferedReader 和 BufferedWrite。其构造方法与 BufferedInputStream 和 BufferedOutPutStream 相类似。另外，除了 read() 和 write() 方法外，它还提供了整行字符处理方法：</p><p>public String readLine()：BufferedReader 的方法，从输入流中读取一行字符，行结束标志\n、\r或者两者一起（这是根据系统而定的）<br>public void newLine()：BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符\n或\r，而是系统定义的行隔离标志（line separator）。<br>看一看例子吧：</p><pre><code> // FileToUnicode.java import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; public class FileToUnicode { public static void main(String args[]) {    try {        FileInputStream fis = new FileInputStream("file1.txt");        InputStreamReader dis = new InputStreamReader(fis);        BufferedReader reader = new BufferedReader(dis);        String s;        //每次读取一行，当改行为空时结束        while((s = reader.readLine()) != null){            System.out.println("read:" + s);        }        dis.close();    }    catch(IOException e) {        System.out.println(e);    }}}</code></pre><p>如 file1.txt 的内容如下：</p><pre><code> abc efg hij</code></pre><p>编译运行：</p><pre><code>$ javac FileToUnicode.java$ java FileToUnicoderead:abcread:efgread:hij</code></pre><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()…; write(), writeChar(), writeBoolean()…此外，还可以用 readLine()方法读取一行信息。</p><p>常用方法<br><img src="http://image.lichongbing.com/static/492063c8faf368c2e474d6e590c7965f.png" alt="截屏2019-12-1011.57.19.png"><br><img src="http://image.lichongbing.com/static/a63498582a5069b3ae617ce89a1d7b6c.png" alt="截屏2019-12-1011.58.06.png"><br>数据流类 DataInputStream 和 DataOutputStream 的处理对象除了是字节或字节数组外，还可以实现对文件的不同数据类型的读写：</p><p>分别实现了 DataInput 和 DataOutput 接口</p><ul><li><p>在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来。</p></li><li><p>提供了字符串读写的手段</p></li><li><p>数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立：</p><pre><code>FileInputStream fis = new FileInputStream("file1.txt");FileOutputStream fos = new FileOutputStream("file2.txt");DataInputStream dis = new DataInputStream(fis);DataOutputStream dos = new DataOutputStream(fos);</code></pre></li></ul><p>编程实战</p><p>在/home/project/目录下新建源代码文件DataStream.java</p><pre><code> import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class DataStream { public static void main(String[] args) throws IOException{    //向文件 a.txt 写入    FileOutputStream fos = new FileOutputStream("a.txt");    DataOutputStream dos = new DataOutputStream(fos);    try {        dos.writeBoolean(true);        dos.writeByte((byte)123);        dos.writeChar('J');        dos.writeDouble(3.1415926);        dos.writeFloat(2.122f);        dos.writeInt(123);    }    finally {        dos.close();    }    //从文件 a.txt 读出    FileInputStream fis = new FileInputStream("a.txt");    DataInputStream dis = new DataInputStream(fis);    try {        System.out.println("\t" + dis.readBoolean());        System.out.println("\t" + dis.readByte());        System.out.println("\t" + dis.readChar());        System.out.println("\t" + dis.readDouble());        System.out.println("\t" + dis.readFloat());        System.out.println("\t" + dis.readInt());    }    finally {        dis.close();    }}}</code></pre><p>编译运行：</p><pre><code>$ javac DataStream.java$ java DataStream    true    123    J    3.1415926    2.122    123</code></pre><h2 id="读写对象"><a href="#读写对象" class="headerlink" title="读写对象"></a>读写对象</h2><p>我们知道实例化的对象存在于内存中，如果我们想传输实例化的对象怎么办呢？可以通过 ObjectOutputStream 和 ObjectInputStream 将对象输入输出。 将对象的状态信息转换为可以存储或者传输的形式的过程又叫序列化。</p><h3 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h3><p>在/home/project目录下新建一个源代码文件ReadWriteObject.java。</p><pre><code>import java.io.*;public class ReadWriteObject {public static void main(String[] args) {    File file = new File("/home/project/user.file");    try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file))) {        //将匿名对象 写入到file中，注意：被写入的对象必须实现了Serializable接口        objectOutputStream.writeObject(new User("shiyanlou", "password"));        objectOutputStream.flush();    } catch (IOException e) {        e.printStackTrace();    }    //读取文件 打开输入流    try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file))) {//            将信息还原为user实例        User user = (User) objectInputStream.readObject();        //打印user信息  和上面创建的匿名对象的信息一致        System.out.println(user.toString());    } catch (IOException | ClassNotFoundException e) {        e.printStackTrace();    }}//静态内部类 必须实现Serializablestatic class User implements Serializable {    private String username;    private String password;    public User(String username, String password) {        this.username = username;        this.password = password;    }    @Override    public String toString() {        return "User{" +                "username='" + username + '\'' +                ", password='" + password + '\'' +                '}';    }} }</code></pre><p>编译运行：</p><pre><code>$ javac ReadWriteObject.java$ java ReadWriteObject  User{username='shiyanlou', password='password'}</code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO(New IO)发布于 JDK1.4，用于代替 Java 标准 IO 。Java NIO是面向缓存的、非阻塞的IO，而标准IO是面向流的，阻塞的IO。</p><p>首先理解 NIO 的重要概念-Buffer（缓冲区）</p><ul><li>NIO 读取或者写入数据都要通过 Buffer</li><li>通过 allocate()方法分配 Buffer，Buffer 不可实例化，Buffer 是抽象类，需要使用具体的子类，比如 ByteBuffer。</li><li>Buffer 的参数</li><li><ul><li>capacity ：缓冲区的容量</li></ul></li><li><ul><li>position ：当前指针位置，没读取一次缓冲区数据或者写入缓冲区一个数据那么指针将会后移一位</li></ul></li><li><ul><li>limit ：限制指针的移动，指针不能读取 limit 之后的位置 ​ - mark ：如果设置该值，那么指针将移动到 0~position 的位置</li></ul></li><li><ul><li>最后可以这几个参数的关系如下：mark &lt;= position &lt;= limit &lt;= capacity<br>##编程实例<br>学习编程的最好方式当然是通过代码来学习，接下来将使用 NIO 来完成的文件的读取和写入操作，同学们可以对比标准 IO 的基本操作理解其不同。</li></ul></li></ul><p>在/home/project/目录下新建源代码文件NioDemo.java</p><pre><code> import java.io.File; import java.io.IOException; import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import java.util.Scanner; public class NioDemo { public static void main(String[] args) {    try {        File file = new File("/home/project/nio.txt");        if (!file.exists()) {            file.createNewFile();        }        //创建channel  nio通过channel来连接文件 相当于桥梁        FileChannel writeChannel = new RandomAccessFile(file, "rw").getChannel();        //创建一个ByteBuffer 容量为100        ByteBuffer byteBuffer = ByteBuffer.allocate(100);        System.out.println("请输入字符串");        Scanner in = new Scanner(System.in);        String s = in.nextLine();        //将字符串写入到缓冲区        byteBuffer.put(s.getBytes());        System.out.println("写入数据后指针变化-position:" + byteBuffer.position() + " limit：" + byteBuffer.limit() + " capacity :" + byteBuffer.capacity());        //为输出数据做准备 将limit移动到position位置，position置0        byteBuffer.flip();        System.out.println("flip后指针变化-position:" + byteBuffer.position() + " limit：" + byteBuffer.limit() + " capacity :" + byteBuffer.capacity());        //将缓冲区写入channel        writeChannel.write(byteBuffer);        //清除缓冲区 为下次写入或者读取数据做准备 恢复到初始状态 position=0 limit=capacity=100  因为我们这里分配的容量大小为100        byteBuffer.clear();        System.out.println("clear后指针变化-position:" + byteBuffer.position() + " limit：" + byteBuffer.limit() + " capacity :" + byteBuffer.capacity());        //关闭channel        writeChannel.close();        FileChannel readChannel = new RandomAccessFile(file, "r").getChannel();        //从channel中将数据读取到缓冲区        while (readChannel.read(byteBuffer) != -1) {            //为读取数据做准备            byteBuffer.flip();            //输出数据 设置解码器            Charset charset = Charset.forName("UTF-8");            CharsetDecoder decoder = charset.newDecoder();            System.out.println("读取结果：" + decoder.decode(byteBuffer));            //清除缓冲区            byteBuffer.clear();        }        readChannel.close();    } catch (IOException e) {        e.printStackTrace();    }}}</code></pre><p>编译运行</p><pre><code>$ javac NioDemo.java$ java NioDemo请输入字符串shiyanlou写入数据后指针变化-position:9 limit：100 capacity :100flip后指针变化-position:0 limit：9 capacity :100clear后指针变化-position:0 limit：100 capacity :100shiyanlou</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节内容主要讲解 Java.io 的内容，主要包含以下知识点：</p><ul><li>文件</li><li>随机读写</li><li>文件操作</li><li>文件拷贝</li><li>文件属性</li><li>目录读取</li><li>IO 流</li><li>字节流</li><li>字符流<br>请大家务必手动完成代码并运行对比结果，才能更好的理解掌握 IO。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda</title>
      <link href="/2017/04/10/lambda/"/>
      <url>/2017/04/10/lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Lambda 表达式是 Java SE 8 中一个重要的新特性。Lambda 表达式允许你通过表达式来代替功能接口。本节将重点讲解 Lambda 相关知识内容。</p><p><strong>函数式编程</strong>（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>一个 Lambda 表达式具有下面这样的语法特征。它由三个部分组成：第一部分为一个括号内用逗号分隔的参数列表，参数即函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块。语法如下：</p><p>parameter -&gt; expression body<br>copy<br>下面列举了 Lambda 表达式的几个最重要的特征：</p><ul><li><p>可选的类型声明：你不用去声明参数的类型。编译器可以从参数的值来推断它是什么类型。</p></li><li><p>可选的参数周围的括号：你可以不用在括号内声明单个参数。但是对于很多参数的情况，括号是必需的。</p></li><li><p>可选的大括号：如果表达式体里面只有一个语句，那么你不必用大括号括起来。</p></li><li><p>可选的返回关键字：如果表达式体只有单个表达式用于值的返回，那么编译器会自动完成这一步。若要指示表达式来返回某个值，则需要使用大括号。<br>在/home/project/新建一个类LambdaTest.java</p><pre><code>public class LambdaTest {public static void main(String args[]){  LambdaTest tester = new LambdaTest();    // 带有类型声明的表达式    MathOperation addition = (int a, int b) -&gt; a + b;    // 没有类型声明的表达式    MathOperation subtraction = (a, b) -&gt; a - b;    // 带有大括号、带有返回语句的表达式    MathOperation multiplication = (int a, int b) -&gt; { return a * b; };    // 没有大括号和return语句的表达式    MathOperation division = (int a, int b) -&gt; a / b;    // 输出结果    System.out.println("10 + 5 = " + tester.operate(10, 5, addition));    System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));    System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));    System.out.println("10 / 5 = " + tester.operate(10, 5, division));    // 没有括号的表达式                GreetingService greetService1 = message -&gt;    System.out.println("Hello " + message);    // 有括号的表达式                GreetingService greetService2 = (message) -&gt;    System.out.println("Hello " + message);    // 调用sayMessage方法输出结果    greetService1.sayMessage("Shiyanlou");    greetService2.sayMessage("Classmate"); } // 下面是定义的一些接口和方法 interface MathOperation {    int operation(int a, int b); } interface GreetingService {    void sayMessage(String message); } private int operate(int a, int b, MathOperation mathOperation){    return mathOperation.operation(a, b); } }</code></pre></li></ul><p>编译运行</p><pre><code> $ javac LambdaTest.java $ java LambdaTest 10 + 5 = 15 10 - 5 = 510 x 5 = 5010 / 5 = 2 Hello ShiyanlouHello Classmate</code></pre><p>需要注意的是：</p><ul><li><p>Lambda 表达式优先用于定义功能接口在行内的实现，即单个方法只有一个接口。在上面的例子中，我们用了多个类型的 * * Lambda 表达式来定义 MathOperation 接口的操作方法。然后我们定义了 GreetingService 的 sayMessage 的实现。</p></li><li><p>Lambda 表达式让匿名类不再需要，这为 Java 增添了简洁但实用的函数式编程能力。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>我们可以通过下面这段代码来学习 Lambda 的作用域。请将代码修改至如下这些：</p><p>   public class LambdaTest {</p><pre><code>  final static String salutation = "Hello "; //正确，不可再次赋值  //static String salutation = "Hello "; //正确，可再次赋值  //String salutation = "Hello "; //报错  //final String salutation = "Hello "; //报错</code></pre><p>  public static void main(String args[]){</p><pre><code>  //final String salutation = "Hello "; //正确，不可再次赋值  //String salutation = "Hello "; //正确，隐性为 final , 不可再次赋值  // salution = "welcome to "    GreetingService greetService1 = message -&gt;   System.out.println(salutation + message);  greetService1.sayMessage("Shiyanlou");</code></pre><p>  }</p><p>  interface GreetingService {</p><pre><code> void sayMessage(String message);</code></pre><p>  }<br>  }</p></li></ul><p>编译运行</p><pre><code>$ javac LambdaTest.java$ java LambdaTestHello Shiyanlou</code></pre><p>可以得到以下结论：</p><p>可访问 static 修饰的成员变量，如果是 final static 修饰，不可再次赋值，只有 static 修饰可再次赋值；<br>可访问表达式外层的 final 局部变量（不用声明为 final，隐性具有 final 语义），不可再次赋值。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。</p><p>方法引用可以通过方法的名字来引用其本身。方法引用是通过::符号（双冒号）来描述的。</p><p>它可以用来引用下列类型的方法：</p><ul><li><p>构造器引用。语法是 Class::new，或者更一般的 Class&lt; T &gt;::new，要求构造器方法是没有参数；</p></li><li><p>静态方法引用。语法是 Class::static_method。</p></li><li><p>特定类的任意对象方法引用。它的语法是 Class::method。</p></li><li><p>特定对象的方法引用，它的语法是 instance::method。<br>下面是一个简单的方法引用的例子。</p><p>// LambdaTest.java<br>import java.util.List;<br>import java.util.ArrayList;</p><p>public class LambdaTest {</p><p>public static void main(String args[]){<br>List<string> names = new ArrayList&lt;&gt;();</string></p><pre><code>  names.add("Peter");  names.add("Linda");  names.add("Smith");  names.add("Zack");  names.add("Bob");  //     通过System.out::println引用了输出的方法  names.forEach(System.out::println);</code></pre><p>}<br>}</p></li></ul><p>编译并运行:</p><pre><code>$ javac LambdaTest.java$ java LambdaTestPeterLindaSmithZackBob</code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是只包含一个方法的接口。例如，带有单个compareTo方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于 lambda 表达式。</p><h2 id="java-util-function"><a href="#java-util-function" class="headerlink" title="java.util.function"></a>java.util.function</h2><p>java.util.function 包中包含了大量的函数式接口，基本可以满足我们的日常开发需求。</p><h2 id="相关的接口及描述"><a href="#相关的接口及描述" class="headerlink" title="相关的接口及描述"></a>相关的接口及描述</h2><p>下面是部分函数式接口的列表。<br><img src="http://image.lichongbing.com/static/1e7c4cc9a2154806d76c57bae04594f6.png" alt="截屏2019-12-1009.47.03.png"><br>更多的接口可以参考 Java 官方 API 手册：java.lang.Annotation Type FunctionalInterface。在实际使用过程中，加有@FunctionalInterface注解的方法均是此类接口，位于java.util.Funtion包中。<br>下面我们通过一个例子学习如何使用这些函数式编程的接口。<br>在/home/project/目录下新建一个类FunctionTest.java</p><pre><code>import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class FunctionTest {public static void main(String args[]){  List&lt;Integer&gt; list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);  System.out.println("All of the numbers:");  ;  System.out.println("Even numbers:");  ;  System.out.println("Numbers that greater than  5:");  ;}public static void  {  for(Integer n: list) {     if(predicate.test(n)) {        System.out.println(n);     }  }}}</code></pre><p>编辑完成后，编译运行。</p><pre><code>$ javac FunctionTest.java  $ java FunctionTest  All of the numbers:0123456789Even numbers:02468Numbers that greater than  5:6789</code></pre><p>Predicate 是 Java 提供的一个函数式接口，他接受一个参数 t，并执行断言操作返回一个 boolean。接口内容如下（这里没有列出接口中提供的默认方法）：</p><pre><code>@FunctionalInterfacepublic interface Predicate&lt;T&gt; {boolean test(T t);}</code></pre><p>在/home/project/目录下创建一个源代码文件PredicateDemo.java。</p><pre><code>import java.util.Random;import java.util.function.IntPredicate;import java.util.function.Predicate;import java.util.stream.IntStream;public class PredicateDemo {public static void main(String[] args) {    //简单使用  判断a是否大于5    Predicate&lt;Integer&gt; predicate = a -&gt; a &gt; 50;    System.out.println(predicate.test(52));    //如果只断言int类型，可以直接使用 IntPredicate    IntPredicate intPredicate = a -&gt; a &gt; 50; //        System.out.println(intPredicate.test(50));    IntStream.of(10,11,44,59,46,55,99,88,50)            //结合filter过滤数字 小于或等于50的数字被过滤            .filter(intPredicate)            .peek(System.out::println).count();}}</code></pre><p>编译运行：</p><pre><code>$ javac PredicateDemo.java$ java PredicateDemotrue59559988</code></pre><p>练习题：lambda<br>在/home/project/目录下新建一个源代码文件LambdaTest.java，你需要完成以下要求：</p><ul><li>建立一个数组1, 23, 4, 4, 22, 34, 45, 11, 33</li><li>使用 lambda 求出数组中的最小数</li><li>将数组去重，并将去重后数组的每个元素乘以 2，再求出乘以 2 后的数组的和，比如数组1,2,3,3，去重后为1,2,3，乘以 2 后为2,4,6，最后的和为12。<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</li></ul><pre><code>import java.util.Arrays;public class LambdaTest {   public static void main(String[] args) {    int[] arr = {1, 23, 4, 4, 22, 34, 45, 11, 33};    System.out.println("最小数："+Arrays.stream(arr).min());    System.out.println("数组去重乘2求和：" + Arrays.stream(arr).distinct().map((i) -&gt; i *   2).sum());}}</code></pre><h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><p>Stream 是 Java 8 开始的一个新的抽象层。通过使用 Stream，你能以类似于 SQL 语句的声明式方式处理数据。</p><p>例如一个典型的 SQL 语句能够自动地返回某些信息，而不用在开发者这一端做任何的计算工作。同样，通过使用 Java 的集合框架，开发者能够利用循环做重复的检查。另外一个关注点是效率，就像多核处理器能够提升效率一样，开发者也可以通过并行化编程来改进工作流程，但是这样很容易出错。</p><p>因此，Stream 的引入是为了解决上述痛点。开发者可以通行声明式数据处理，以及简单地利用多核处理体系而不用写特定的代码。</p><p>说了这么久，Stream 究竟是什么呢？Stream 代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是 Stream 的一些特性：</p><ul><li><p>元素序列：Stream 以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。</p></li><li><p>源：Stream 可以将集合、数组和 I/O 资源作为输入源。</p></li><li><p>聚集操作：Stream 支持诸如filter、map、limit、reduce等的聚集操作。</p></li><li><p>流水技术：许多 Stream 操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。collect()方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。</p></li><li><p>自动迭代：Stream 的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。</p><h2 id="相关的方法介绍"><a href="#相关的方法介绍" class="headerlink" title="相关的方法介绍"></a>相关的方法介绍</h2><p>集合的接口有两个方法来产生流：</p></li><li><p>stream()：该方法返回一个将集合视为源的连续流。</p></li><li><p>parallelStream()：该方法返回一个将集合视为源的并行流。<br>其他相关方法：</p></li><li><p>forEach：该方法用于对 Stream 中的每个元素进行迭代操作。下面的代码段演示了如何使用 forEach 方法输出 10 个随机数。</p><pre><code>Random random = new Random();random.ints().limit(10).forEach(System.out::println);</code></pre></li><li><p>map：该方法用于将每个元素映射到对应的结果上。下面的代码段演示了怎样用 map 方法输出唯一的某个数的平方。</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);//get list of unique squaresList&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</code></pre></li><li><p>filter：该方法用于过滤满足条件的元素。下面的代码段演示了怎样输出使用了过滤方法的空字符串数量。</p><pre><code>List&lt;String&gt;strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");//get count of empty stringlong count = strings.stream().filter(string -&gt; string.isEmpty()).count();</code></pre></li><li><p>limit：该方法用于减少 Stream 的大小。下面的代码段演示了怎样有限制地输出 10 个随机数。</p><pre><code>Random random = new Random();random.ints().limit(10).forEach(System.out::println);</code></pre></li><li><p>sorted：该方法用于对 Stream 排序。下面的代码段演示了怎样以有序的形式输出 10 个随机数。</p><pre><code>Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println);</code></pre></li></ul><p><strong>并行处理</strong></p><p>ParallelStream 是 Stream 用于并行处理的一种替代方案。下面的代码段演示了如何使用它来输出空字符串的数量。</p><pre><code>List&lt;String&gt; strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");// 获得空字符串的计数long count = strings.parallelStream().filter(String::isEmpty).count();</code></pre><p>当然，在连续的 Stream 与并行的 Stream 之间切换是很容易的。</p><p><strong>Collector</strong></p><p>Collector 用于合并 Stream 的元素处理结果。它可以用于返回一个字符串列表。</p><p>下面的代码段演示了如何使用它。</p><pre><code>List&lt;String&gt;strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());System.out.println("Filtered List: " + filtered);String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", "));System.out.println("Merged String: " + mergedString);</code></pre><p><strong>统计工具</strong></p><p>Stream 处理完成后使用 Collector 来统计数据。</p><p>下面的代码段演示了如何使用它。</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println("Highest number in List : " + stats.getMax());System.out.println("Lowest number in List : " + stats.getMin());System.out.println("Sum of all numbers : " + stats.getSum());System.out.println("Average of all numbers : " + stats.getAverage());</code></pre><p>下面我们通过一个例子来综合应用上面提到的各个技巧。</p><p>在/home/project目录下新建一个类StreamTest.java</p><pre><code> import java.util.ArrayList; import java.util.Arrays; import java.util.IntSummaryStatistics; import java.util.List; import java.util.Random; import java.util.stream.Collectors; import java.util.Map; public class StreamTest { public static void main(String args[]){  System.out.println("Using Java 7: ");  // 统计空字符串的数量  List&lt;String&gt; strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");  System.out.println("List: " +strings);  long count = getCountEmptyStringUsingJava7(strings);  System.out.println("Empty Strings: " + count);  count = getCountLength3UsingJava7(strings);  System.out.println("Strings of length 3: " + count);  // 消除空字符串  List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);  System.out.println("Filtered List: " + filtered);  // 消除空字符串，同时使用逗号来连接  String mergedString = getMergedStringUsingJava7(strings,", ");  System.out.println("Merged String: " + mergedString);  List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);  // 获得不同数字的平方的列表  List&lt;Integer&gt; squaresList = getSquares(numbers);  System.out.println("Squares List: " + squaresList);  List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19);  System.out.println("List: " +integers);  System.out.println("Highest number in List : " + getMax(integers));  System.out.println("Lowest number in List : " + getMin(integers));  System.out.println("Sum of all numbers : " + getSum(integers));  System.out.println("Average of all numbers : " + getAverage(integers));  // 输出10个随机数  System.out.println("Random Numbers: ");  Random random = new Random();  for(int i=0; i &lt; 10; i++){     System.out.println(random.nextInt());  }  // 使用Java 8的新特性  System.out.println("Using Java 8: ");  System.out.println("List: " +strings);  count = strings.stream().filter(string-&gt;string.isEmpty()).count();  System.out.println("Empty Strings: " + count);  count = strings.stream().filter(string -&gt; string.length() == 3).count();  System.out.println("Strings of length 3: " + count);  filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());  System.out.println("Filtered List: " + filtered);  mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(", "));  System.out.println("Merged String: " + mergedString);  squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());  System.out.println("Squares List: " + squaresList);  System.out.println("List: " +integers);  IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();  // 输出结果  System.out.println("Highest number in List : " + stats.getMax());  System.out.println("Lowest number in List : " + stats.getMin());  System.out.println("Sum of all numbers : " + stats.getSum());  System.out.println("Average of all numbers : " + stats.getAverage());  System.out.println("Random Numbers: ");  random.ints().limit(10).sorted().forEach(System.out::println);  // 并行处理  count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();  System.out.println("Empty Strings: " + count);}// 使用Java 7版本就提供的API来计算空串数量    private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings){  int count = 0;  for(String string: strings){     if(string.isEmpty()){        count++;     }  }  return count;}// 使用Java 7版本就提供的API来计算长度为3字符的字符串数量private static int getCountLength3UsingJava7(List&lt;String&gt; strings){  int count = 0;  for(String string: strings){     if(string.length() == 3){        count++;     }  }  return count;}// 使用Java 7版本就提供的API来删除空串private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings){  List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();  for(String string: strings){     if(!string.isEmpty()){         filteredList.add(string);     }  }  return filteredList;}// 使用Java 7版本就提供的API来获取合并后的字符串private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator){  StringBuilder stringBuilder = new StringBuilder();  for(String string: strings){     if(!string.isEmpty()){        stringBuilder.append(string);        stringBuilder.append(separator);     }  }  String mergedString = stringBuilder.toString();  return mergedString.substring(0, mergedString.length()-2);}// 自定义的用于计算数字的平方的方法private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers){  List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();  for(Integer number: numbers){     Integer square = new Integer(number.intValue() * number.intValue());     if(!squaresList.contains(square)){        squaresList.add(square);     }  }  return squaresList;}// 自定义的用于获得List中最大值的方法private static int getMax(List&lt;Integer&gt; numbers){  int max = numbers.get(0);  for(int i=1;i &lt; numbers.size();i++){     Integer number = numbers.get(i);     if(number.intValue() &gt; max){        max = number.intValue();     }  }  return max;}// 自定义的用于获得List中最小值的方法private static int getMin(List&lt;Integer&gt; numbers){   int min = numbers.get(0);  for(int i=1;i &lt; numbers.size();i++){     Integer number = numbers.get(i);     if(number.intValue() &lt; min){        min = number.intValue();     }  }  return min;}// 自定义的用于获得List中各个数字的和的方法private static int getSum(List&lt;Integer&gt; numbers){  int sum = (int)(numbers.get(0));  for(int i=1;i &lt; numbers.size();i++){     sum += (int)numbers.get(i);  }  return sum;}// 自定义的用于获得List中各个数字的平均值的方法private static int getAverage(List&lt;Integer&gt; numbers){  return getSum(numbers) / numbers.size();}}</code></pre><p>编辑完成后，编译运行</p><pre><code>$ javac StreamTest.java$ java StreamTestUsing Java 7: List: [efg, , abc, bc, ghij, , lmn]Empty Strings: 2Strings of length 3: 3Filtered List: [efg, abc, bc, ghij, lmn]Merged String: efg, abc, bc, ghij, lmnSquares List: [4, 9, 25, 49]List: [1, 2, 13, 4, 15, 6, 17, 8, 19]Highest number in List : 19Lowest number in List : 1Sum of all numbers : 85Average of all numbers : 9Random Numbers: 11729826592057597-15915415131855778144395810834661148062231213064-15871367351362511432-940659717Using Java 8: List: [efg, , abc, bc, ghij, , lmn]Empty Strings: 2Strings of length 3: 3Filtered List: [efg, abc, bc, ghij, lmn]Merged String: efg, abc, bc, ghij, lmnSquares List: [4, 9, 25, 49]List: [1, 2, 13, 4, 15, 6, 17, 8, 19]Highest number in List : 19Lowest number in List : 1Sum of all numbers : 85Average of all numbers : 9.444444444444445Random Numbers: -1052491869-695737956105656001824662023100991181211464993241472638998163560924117873080021870383313Empty Strings: 2</code></pre><h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>FlatMap 用于将多个流合并为一个流，使用 FlatMap 时，表达式的返回值必须是 Stream 类型。而 Map 用于将一种流转化为另外一个流。<br>考虑以下场景，有三个字符串(“shi yan”, “shi yan lou”,”lou yan shi”)，我们希望将字符串使用空格分割，提取出单个单词。 在/home/project/目录下新建一个文件FlatMapTest.java。</p><pre><code> import java.util.Arrays; import java.util.stream.Stream;public class FlatMapTest {public static void main(String[] args) {    Stream&lt;String&gt; stringStream1 = Stream.of("shi yan", "shi yan lou","lou yan shi");    Stream&lt;String&gt; stringStream2 = Stream.of("shi yan", "shi yan lou","lou yan shi");    Stream&lt;String[]&gt; mapStream = stringStream1            //map将一种类型的流 转换为另外一个类型的流  这里转换成了String[]流             //这并不是我们想要的，我们想要的是Stream&lt;String&gt;,而不是Stream&lt;String[]&gt;            .map(v -&gt; v.split(" "));    Stream&lt;String&gt; flatMapStream = stringStream2            //Arrays.stream将数组转换成了流 这里将分割后的String[]，转换成了Stream&lt;String&gt;，但是我们前面定义了三个字符串            //所以这里将产生三个Stream&lt;String&gt;，flatMap用于将三个流合并成一个流            .flatMap(v -&gt; Arrays.stream(v.split(" ")));    System.out.println("mapStream打印：");    mapStream.peek(System.out::println).count();    System.out.println("flatMapStream打印：");    flatMapStream.peek(System.out::println).count();}}</code></pre><p>编译运行：</p><pre><code>$ javac FlatMapTest.java$ java FlatMapTest mapStream打印： [Ljava.lang.String;@2d98a335 [Ljava.lang.String;@16b98e56 [Ljava.lang.String;@7ef20235 flatMapStream打印： shi yan shi yan lou lou yan shi</code></pre><h2 id="练习题：合并流"><a href="#练习题：合并流" class="headerlink" title="练习题：合并流"></a>练习题：合并流</h2><p>在/home/project目录下新建一个MergerStream.java，你需要完成以下需求：</p><ul><li><p>新建多个流，如：</p><p>Stream<integer> stream1 = Stream.of(1, 2, 3);</integer></p><p>Stream<integer> stream2 = Stream.of(4, 5, 6);</integer></p><p>Stream<integer> stream3 = Stream.of(7, 8, 9);</integer></p></li><li><p>使用 flatMap 合并多个流为一个流</p></li></ul><p>提示：</p><ul><li>可以使使用 Stream.of()方法，比如 Stream.of(stream1,stream2)，但是返回类型会变成 Stream<stream></stream></li></ul><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code> import java.util.stream.Stream; public class MergerStream { public static void main(String[] args) {    Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3);    Stream&lt;Integer&gt; stream2 = Stream.of(4, 5, 6);    Stream&lt;Integer&gt; stream3 = Stream.of(7, 8, 9);    Stream&lt;Integer&gt; mergerStream = Stream.of(stream1, stream2, stream3).flatMap((i) -&gt; i);    mergerStream.forEach(System.out::print);}}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要内容是对 Java 8 新增的 Lambda 语言特性进行讲解，主要包含以下知识点：</p><ul><li>Lambda 表达式</li><li>函数式接口</li><li>Stream 流</li><li>FlatMap<br>请大家务必手动完成代码并运行对比结果，才能更好的理解掌握 Lambda。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2017/03/10/yi-chang/"/>
      <url>/2017/03/10/yi-chang/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>任何一个程序都有可能发生异常，本节将主要讲解关于 Java 的异常处理。主要内容包含异常的基础理论以及如何捕获异常<br>异常指不期而至的各种状况，它在程序运行的过程中发生。作为开发者，我们都希望自己写的代码永远都不会出现bug，然而现实告诉我们并没有这样的情景。如果用户在程序的使用过程中因为一些原因造成他的数据丢失，这个用户就可能不会再使用该程序了。所以，对于程序的错误以及外部环境能够对用户造成的影响，我们应当及时报告并且以适当的方式来处理这个错误。</p><p>之所以要处理异常，也是为了增强程序的鲁棒性。</p><p>异常都是从Throwable类派生出来的，而Throwable类是直接从Object类继承而来。你可以在 Java SE 官方 API 文档中获取更多关于它们的知识。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常通常有四类：</p><pre><code>Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理Exception：可以处理的异常RuntimeException：可以捕获，也可以不捕获的异常继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常</code></pre><p>平时主要关注的异常是 Exception 下的异常，而 Exception 异常下又主要分为两大类异常，一个是派生于 RuntimeExcption 的异常，一个是除了 RuntimeExcption 体系之外的其他异常。</p><p>RuntimeExcption 异常(运行时异常)通常有以下几种：</p><pre><code>错误的类型转换数组访问越界访问 null 指针算术异常</code></pre><p>一般来说，RuntimeException 都是程序员的问题。</p><p>非 RuntimeException（受查异常）一般有：</p><pre><code>打开一个不存在的文件没有找到具有指定名称的类操作文件异常</code></pre><p>受查异常是编译器要求必须处理的异常，必须使用 try catch 处理，或者向上抛出，给上层处理。</p><h2 id="声明及抛出"><a href="#声明及抛出" class="headerlink" title="声明及抛出"></a>声明及抛出</h2><p>throw 抛出异常</p><p>当程序运行时数据出现错误或者我们不希望发生的情况出现的话，可以通过抛出异常来处理。</p><p>异常抛出语法：</p><pre><code>throw new 异常名();</code></pre><p>在/home/project/目录下新建ThrowTest.java</p><pre><code>public class ThrowTest {public static void main(String[] args) {    Integer a = 1;    Integer b = null;    //当a或者b为null时，抛出异常    if (a == null || b == null) {        throw new NullPointerException();    } else {        System.out.println(a + b);    }}}$ javac ThrowTest.java$ java ThrowTestException in thread "main" java.lang.NullPointerExceptionat ThrowTest.main(ThrowTest.java:8)</code></pre><p>throws 声明异常</p><p>throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受查异常），那么调用者必须处理该异常或者使用 throws 继续向上抛出。throws 位于方法体前，多个异常使用,分割。</p><p>修改/home/project/下的ThrowsTest.java</p><pre><code>import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsTest {public static void main(String[] args) throws FileNotFoundException {    //由方法的调用者捕获异常或者继续向上抛出    throwsTest();}public static void throwsTest() throws FileNotFoundException {    new FileInputStream("/home/project/shiyanlou.file");}}</code></pre><p>编译运行：</p><pre><code>$ javac ThrowsTest.java$ java ThrowsTestException in thread "main" java.io.FileNotFoundException: /home/project/shiyanlou.file (系统找不到指定的路径。)at java.io.FileInputStream.open0(Native Method)at java.io.FileInputStream.open(FileInputStream.java:195)at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)at ThrowsTest.throwsTest(ThrowsTest.java:13)at ThrowsTest.main(ThrowsTest.java:8)</code></pre><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>通常抛出异常后，还需要将异常捕获。使用try和catch语句块来捕获异常，有时候还会用到finally。</p><p>对于上述三个关键词所构成的语句块，try语句块是必不可少的，catch和finally语句块可以根据情况选择其一或者全选。你可以把可能发生错误或出现问题的语句放到try语句块中，将异常发生后要执行的语句放到catch语句块中，而finally语句块里面放置的语句，不管异常是否发生，它们都会被执行。</p><p>你可能想说，那我把所有有关的代码都放到try语句块中不就妥当了吗？可是你需要知道，捕获异常对于系统而言，其开销非常大，所以应尽量减少该语句块中放置的语句。</p><h2 id="捕获异常编程实例"><a href="#捕获异常编程实例" class="headerlink" title="捕获异常编程实例"></a>捕获异常编程实例</h2><p>在/home/project/目录下新建CatchException.java</p><pre><code>public class CatchException {public static void main(String[] args) {    try {        // 下面定义了一个try语句块        System.out.println("I am try block.");        Class&lt;?&gt; tempClass = Class.forName("");            // 声明一个空的Class对象用于引发“类未发现异常”        System.out.println("Bye! Try block.");    } catch (ClassNotFoundException e) {        // 下面定义了一个catch语句块        System.out.println("I am catch block.");        e.printStackTrace();        //printStackTrace()的意义在于在命令行打印异常信息在程序中出错的位置及原因        System.out.println("Goodbye! Catch block.");    } finally {        // 下面定义了一个finally语句块        System.out.println("I am finally block.");    }}}</code></pre><p>编译运行：</p><pre><code>$ javac CatchException.java$ java CatchExceptionI am try block.I am catch block.java.lang.ClassNotFoundException:    at java.lang.Class.forName0(Native Method)    at java.lang.Class.forName(Unknown Source)    at CatchException.main(CatchException.java:8)Goodbye! Catch block.I am finally block.</code></pre><p>请你结合这些输出语句在源代码中的位置，再来体会一下三个语句块的作用。</p><h2 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h2><p>在一段代码中，可能会由于各种原因抛出多种不同的异常，而对于不同的异常，我们希望用不同的方式来处理它们，而不是笼统的使用同一个方式处理，在这种情况下，可以使用异常匹配，当匹配到对应的异常后，后面的异常将不再进行匹配。</p><p>编程实例</p><p>在/home/project/目录下新建源代码文件MultipleCapturesDemo.java</p><pre><code>import java.io.FileInputStream;import java.io.FileNotFoundException;public class MultipleCapturesDemo {public static void main(String[] args) {    try {        new FileInputStream("");    } catch (FileNotFoundException e) {        System.out.println("IO 异常");    } catch (Exception e) {        System.out.println("发生异常");    }}}</code></pre><p>编译运行：</p><pre><code>$ javac MultipleCapturesDemo.java$ java MultipleCapturesDemoIO 异常</code></pre><p>在处理异常时，并不要求抛出的异常同 catch 所声明的异常完全匹配，子类的对象也可以匹配父类的处理程序。比如异常 A 继承于异常 B，那么在处理多个异常时，一定要将异常 A 放在异常 B 之前捕获，如果将异常 B 放在异常 A 之前，那么将永远匹配到异常 B，异常 A 将永远不可能执行，并且编译器将会报错。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>尽管 Java SE 的 API 已经为我们提供了数十种异常类，然而在实际的开发过程中，你仍然可能遇到未知的异常情况。此时，你就需要对异常类进行自定义。</p><p>自定义一个异常类非常简单，只需要让它继承 Exception 或其子类就行。在自定义异常类的时候，建议同时提供无参构造方法和带字符串参数的构造方法，后者可以为你在调试时提供更加详细的信息。</p><p>百闻不如一见，下面我们尝试自定义一个算术异常类。</p><p>在/home/project/目录下创建一个MyAriException类。</p><p>主要的代码如下：</p><p>// MyAriException.java<br>public class MyAriException extends ArithmeticException {<br>//自定义异常类，该类继承自ArithmeticException</p><pre><code>public MyAriException() {}//实现默认的无参构造方法public MyAriException(String msg) {    super(msg);}//实现可以自定义输出信息的构造方法，将待输出信息作为参数传入即可</code></pre><p>}<br>copy<br>添加一个ExceptionTest类作为测试用，在该类的main()方法中，可以尝试使用throw抛出自定义的异常。</p><p>代码片段如下：</p><pre><code>// ExceptionTest.javaimport java.util.Arrays;public class ExceptionTest {public static void main(String[] args) {    int[] array = new int[5];    //声明一个长度为5的数组    Arrays.fill(array, 5);    //将数组中的所有元素赋值为5    for (int i = 4; i &gt; -1; i--) {        //使用for循环逆序遍历整个数组，i每次递减        if (i == 0) {        // 如果i除以了0，就使用带异常信息的构造方法抛出异常            throw new MyAriException("There is an exception occured.");        }        System.out.println("array[" + i + "] / " + i + " = " + array[i] / i);        // 如果i没有除以0，就输出此结果    }}}</code></pre><p>检查一下代码，点击编译并运行，期待中的自定义错误信息就展现在控制台中了：</p><pre><code>$ javac ExceptionTest.java MyAriException.java$ java ExceptionTestarray[4] / 4 = 1array[3] / 3 = 1array[2] / 2 = 2array[1] / 1 = 5Exception in thread "main" MyAriException: There is an exception occured.at ExceptionTest.main(ExceptionTest.java:17)</code></pre><h2 id="异常堆栈"><a href="#异常堆栈" class="headerlink" title="异常堆栈"></a>异常堆栈</h2><p>当异常抛出后，我们可以通过异常堆栈追踪程序的运行轨迹，以便我们更好的DEBUG。<br>在/home/project目录下新建一个ExceptionStackTrace.java</p><pre><code>public class ExceptionStackTrace {private static void method1() {    method2();}private static void method2() {    throw new NullPointerException();}public static void main(String[] args) {    try {        method1();    } catch (Exception e) {        //打印堆栈轨迹        e.printStackTrace();    }}}</code></pre><p>编译运行：</p><pre><code>$ javac ExceptionStackTrace.java$ java ExceptionStackTracejava.lang.NullPointerException     at ExceptionStackTrace.method2(ExceptionStackTrace.java:7)     at ExceptionStackTrace.method1(ExceptionStackTrace.java:3)     at ExceptionStackTrace.main(ExceptionStackTrace.java:11)</code></pre><p>通过上面的异常堆栈轨迹，在对比我们方法的调用过程，可以得出异常信息中首先打印的是距离抛出异常最近的语句，接着是调用该方法的方法，一直到最开始被调用的方法。从下往上看，就可以得出程序运行的轨迹。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要内容是对 Java 的异常处理进行讲解，主要包含以下知识点：</p><ul><li>异常分类</li><li>声明及抛出</li><li>捕获异常</li><li>自定义异常</li><li>异常堆栈</li></ul><p>请大家务必手动完成代码并运行对比结果，这样才能更好的理解并掌握 Java 关于异常处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型与集合</title>
      <link href="/2016/12/18/fan-xing-yu-ji-he/"/>
      <url>/2016/12/18/fan-xing-yu-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 使用集合来组织和管理对象，本节我们重点讲解泛型和集合。主要介绍 Collection、List、ArrayList、Map、HashMap、Set 和 HashSet、Collections、算法等内容。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。</p><p>定义泛型的规则：</p><ul><li>只能是类类型，不能是简单数据类型</li><li>泛型参数可以有多个</li><li>可以用使用 extends 语句或者 super 语句 如<t extends="" superclass="">表示类型的上界，T 只能是 superClass 或* 其子类， <k super="" childclass="">表示类型的下界，K 只能是 childClass 或其父类。</k></t></li><li>可以是通配符类型，比如常见的 Class&lt;?&gt;<h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2>接下来我们来定义一个泛型类，它有一个成员，成员的类型待定。 在/home/project/目录下新建一个类TestDemo.java</li></ul><pre><code> /* 使用T代表类型，无论何时都没有比这更具体的类型来区分它。如果有多个类型参数，我们可能使用字母表中T的临近的字    母，比如S。*/class Test&lt;T&gt; {private T ob;/*定义泛型成员变量，定义完类型参数后，可以在定义位置之后的方法的任意地方使用类型参数，就像使用普通的类型一样。注意，父类定义的类型参数不能被子类继承。*///构造函数public Test(T ob) {    this.ob = ob;}//getter 方法public T getOb() {    return ob;}//setter 方法public void setOb(T ob) {    this.ob = ob;}public void showType() {    System.out.println("T的实际类型是: " + ob.getClass().getName());}}public class TestDemo {public static void main(String[] args) {    // 定义泛型类 Test 的一个Integer版本    Test&lt;Integer&gt; intOb = new Test&lt;Integer&gt;(88);    intOb.showType();    int i = intOb.getOb();    System.out.println("value= " + i);    System.out.println("----------------------------------");    // 定义泛型类Test的一个String版本    Test&lt;String&gt; strOb = new Test&lt;String&gt;("Hello Gen!");    strOb.showType();    String s = strOb.getOb();    System.out.println("value= " + s); }}</code></pre><p>编译运行：</p><pre><code>$ javac TestDemo.java$ java TestDemoT的实际类型是: java.lang.Integervalue= 88----------------------------------T的实际类型是: java.lang.Stringvalue= Hello Gen!</code></pre><h2 id="使用泛型方法"><a href="#使用泛型方法" class="headerlink" title="使用泛型方法"></a>使用泛型方法</h2><p>我们先来看一看代码：</p><p>在/home/project目录下新建一个 Animal 类</p><pre><code>// Animal.javapublic class Animal {public Animal(){    System.out.println("我是动物");}}</code></pre><p>在/home/project目录下新建一个 Dog 类</p><pre><code>// Dog.java public class Dog extends Animal {public Dog(){    System.out.println("我是狗");}}</code></pre><p>在/home/project目录下新建一个 Test 类</p><pre><code>// Test.javapublic class Test {/*注意：定义带类型参数的方法，其主要目的是为了表达多个参数以及返回值之间的关系。例如本例子中T和S的继承关系， 返回值的类型和第一个类型参数的值相同。*/public&lt;T, S extends T&gt; T testDemo(T t, S s){    System.out.println("我是 T 类型，我的类型是" + t.getClass().getName());    System.out.println("我是 S 类型，我的类型是" + s.getClass().getName());    return t;}public static void main(String[] args) {    // TODO Auto-generated method stub    Test test = new Test();    Dog d = new Dog();    Animal a0 = new Animal();    Animal a1  = test.testDemo(a0, d);    System.out.println("我是整数 a，我的类型是" + a1.getClass().getName());}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java Dog.java Animal.java$ java Test我是动物我是狗我是动物我是 T 类型，我的类型是Animal我是 S 类型，我的类型是Dog我是整数 a，我的类型是Animal</code></pre><p>上面的例子中我们对类型参数赋予了具体的类型，当然我们有时候也无法确定类型参数的类型，这个时候我们便可以使用通配符。如果仅仅是想实现多态，请优先使用通配符解决。</p><p>修改 Test 类：</p><pre><code>import java.util.List;import java.util.ArrayList;public class Test {public void testDemo(List&lt;?&gt; s){    for(Object obj:s){        System.out.println("我的类型是" + obj.getClass().getName());    }}public static void main(String[] args) {    // TODO Auto-generated method stub    Test test = new Test();    Dog a0 = new Dog();    Animal a1 = new Animal();    List&lt;Animal&gt; s = new ArrayList&lt;Animal&gt;();    s.add(a0);    s.add(a1);    test.testDemo(s);}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java Dog.java Animal.java$ java Test我是动物我是狗我是动物我的类型是Dog我的类型是Animal</code></pre><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。</p><p>下图是简化的集合框架关系图：<br><img src="http://image.lichongbing.com/static/4234a921848aded420a182bad470853a.png" alt="wm-20.png"><br><img src="http://image.lichongbing.com/static/b9900b6b8325fce1d5874276e942dd75.png" alt="截屏2019-12-1000.44.49.png"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="http://image.lichongbing.com/static/b9900b6b8325fce1d5874276e942dd75.png" alt="截屏2019-12-1000.44.49.png"></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList　类实现一个可增长的动态数组，位于 java.util.ArrayList<e>。实现了 List 接口，它可以存储不同类型的对象（包括 null 在内），而数组则只能存放特定数据类型的值。</e></p><p>ArrayList 编程实例</p><p>学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作。</p><p>先在/home/project/创建一个学生类Student.java：</p><pre><code>/*** 学生类*/public class Student {public String id;public String name;public Student(String id, String name){    this.id = id;    this.name = name;}@Overridepublic String toString() {    return "Student{" +            "id='" + id + '\'' +            ", name='" + name + '\'' +            '}';}}</code></pre><p>再在/home/project/创建一个ListTest.java，其中包含了一个学生列表，通过操作学生列表来管理学生</p><pre><code>import java.util.*;public class ListTest {//集合后面的&lt;&gt;代表泛型的意思//泛型是规定了集合元素的类型/** * 用于存放学生的List */public List&lt;Student&gt; students;public ListTest() {    this.students = new ArrayList&lt;Student&gt;();}/** * 用于往students中添加学生 */public void testAdd() {    // 创建一个学生对象，并通过调用add方法，添加到学生管理List中    Student st1 = new Student("1", "张三");    students.add(st1);    // 取出 List中的Student对象 索引为0 也就是第一个    Student temp = students.get(0);    System.out.println("添加了学生：" + temp.id + ":" + temp.name);    Student st2 = new Student("2", "李四");    //添加到list中，插入到索引为0的位置，也就是第一个    students.add(0, st2);    Student temp2 = students.get(0);    System.out.println("添加了学生：" + temp2.id + ":" + temp2.name);    // 对象数组的形式添加    Student[] student = {new Student("3", "王五"), new Student("4", "马六")};    // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表    students.addAll(Arrays.asList(student));    Student temp3 = students.get(2);    Student temp4 = students.get(3);    System.out.println("添加了学生：" + temp3.id + ":" + temp3.name);    System.out.println("添加了学生：" + temp4.id + ":" + temp4.name);    Student[] student2 = {new Student("5", "周七"), new Student("6", "赵八")};    students.addAll(2, Arrays.asList(student2));    Student temp5 = students.get(2);    Student temp6 = students.get(3);    System.out.println("添加了学生：" + temp5.id + ":" + temp5.name);    System.out.println("添加了学生：" + temp6.id + ":" + temp6.name);}/** * 取得List中的元素的方法 */public void testGet() {    int size = students.size();    for (int i = 0; i &lt; size; i++) {        Student st = students.get(i);        System.out.println("学生：" + st.id + ":" + st.name);    }}/** * 通过迭代器来遍历 * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动 */public void testIterator() {    // 通过集合的iterator方法，取得迭代器实例    Iterator&lt;Student&gt; it = students.iterator();    System.out.println("有如下学生（通过迭代器访问）：");    while (it.hasNext()) {        Student st = it.next();        System.out.println("学生" + st.id + ":" + st.name);    }}/** * 通过for each 方法访问集合元素 * */public void testForEach() {    System.out.println("有如下学生（通过for each）：");    for (Student obj : students) {        Student st = obj;        System.out.println("学生：" + st.id + ":" + st.name);    }    //使用java8 Steam将学生排序后输出    students.stream()//创建Stream            //通过学生id排序            .sorted(Comparator.comparing(x -&gt; x.id))            //输出            .forEach(System.out::println);}/** * 修改List中的元素 * */public void testModify() {    students.set(4, new Student("3", "吴酒"));}/** * 删除List中的元素 * */public void testRemove() {    Student st = students.get(4);    System.out.println("我是学生：" + st.id + ":" + st.name + "，我即将被删除");    students.remove(st);    System.out.println("成功删除学生！");    testForEach();}public static void main(String[] args) {    ListTest lt = new ListTest();    lt.testAdd();    lt.testGet();    lt.testIterator();    lt.testModify();    lt.testForEach();    lt.testRemove();}}</code></pre><p>编译运行：</p><pre><code>$ javac Student.java ListTest.java$ java ListTest添加了学生：1:张三添加了学生：2:李四添加了学生：3:王五添加了学生：4:马六添加了学生：5:周七添加了学生：6:赵八学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:王五学生：4:马六有如下学生（通过迭代器访问）：学生2:李四学生1:张三学生5:周七学生6:赵八学生3:王五学生4:马六有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:吴酒学生：4:马六Student{id='1', name='张三'}Student{id='2', name='李四'}Student{id='3', name='吴酒'}Student{id='4', name='马六'}Student{id='5', name='周七'}Student{id='6', name='赵八'}我是学生：3:吴酒，我即将被删除成功删除学生！有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：4:马六Student{id='1', name='张三'}Student{id='2', name='李四'}Student{id='4', name='马六'}Student{id='5', name='周七'}Student{id='6', name='赵八'}</code></pre><p>在上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 接口也是一个非常重要的集合接口，用于存储键/值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。</p><p><img src="http://image.lichongbing.com/static/bc0d8e843aa2b897eea674f72f29b456.jpeg" alt="wm-2.jpeg"><br><img src="http://image.lichongbing.com/static/dc5fc3f82b55f0f345f706afa4350e78.png" alt="截屏2019-12-1000.50.30.png"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是无序排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。</p><p>下面我们通过代码来学习 Map 中的方法吧。同学们都有过选课经历吧，我们就用 Map 来管理课程吧。</p><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><p>在/home/project/目录下创建一个 Course 类：</p><pre><code>// Course.javapublic class Course {public String id;public String name;public Course(String id, String name){    this.id = id;    this.name = name;}}</code></pre><p>在/home/project/目录下创建一个 MapTest 类：</p><pre><code>// MapTest.javaimport java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest {/** * 用来承装课程类型对象 */public Map&lt;String, Course&gt; courses;/** * 在构造器中初始化 courses 属性 * @param args */public MapTest() {    this.courses = new HashMap&lt;String, Course&gt;();}/** * 测试添加：输入课程 ID，判断是否被占用 * 若未被占用，输入课程名称，创建新课程对象 * 并且添加到 courses 中 * @param args */public void testPut() {    //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称    Scanner console = new Scanner(System.in);    for(int i = 0; i &lt; 3; i++) {        System.out.println("请输入课程 ID：");        String ID = console.next();        //判断该 ID 是否被占用        Course cr = courses.get(ID);        if(cr == null){            //提示输入课程名称            System.out.println("请输入课程名称：");            String name = console.next();            //创建新的课程对象            Course newCourse = new Course(ID,name);            //通过调用 courses 的 put 方法，添加 ID-课程映射            courses.put(ID, newCourse);            System.out.println("成功添加课程：" + courses.get(ID).name);        }        else {            System.out.println("该课程 ID 已被占用");            continue;        }    }}/** * 测试 Map 的 keySet 方法 * @param args */public void testKeySet() {    //通过 keySet 方法，返回 Map 中的所有键的 Set 集合    Set&lt;String&gt; keySet = courses.keySet();    //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value    for(String crID: keySet) {        Course cr = courses.get(crID);        if(cr != null){            System.out.println("课程：" + cr.name);        }    }}/** * 测试删除 Map 中的映射 * @param args */public void testRemove() {    //获取从键盘输入的待删除课程 ID 字符串    Scanner console = new Scanner(System.in);    while(true){        //提示输出待删除的课程 ID        System.out.println("请输入要删除的课程 ID！");        String ID = console.next();        //判断该 ID 是否对应的课程对象        Course cr = courses.get(ID);        if(cr == null) {            //提示输入的 ID 并不存在            System.out.println("该 ID 不存在！");            continue;        }        courses.remove(ID);        System.out.println("成功删除课程" + cr.name);        break;    }}/** * 通过 entrySet 方法来遍历 Map * @param args */public void testEntrySet() {    //通过 entrySet 方法，返回 Map 中的所有键值对    Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet();    for(Entry&lt;String,Course&gt; entry: entrySet) {        System.out.println("取得键：" + entry.getKey());        System.out.println("对应的值为：" + entry.getValue().name);    }}/** * 利用 put 方法修改Map 中的已有映射 * @param args */public void testModify(){    //提示输入要修改的课程 ID    System.out.println("请输入要修改的课程 ID：");    //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串    Scanner console = new Scanner(System.in);    while(true) {        //取得从键盘输入的课程 ID        String crID = console.next();        //从 courses 中查找该课程 ID 对应的对象        Course course = courses.get(crID);        if(course == null) {            System.out.println("该 ID 不存在！请重新输入！");            continue;        }        //提示当前对应的课程对象的名称        System.out.println("当前该课程 ID，所对应的课程为：" + course.name);        //提示输入新的课程名称，来修改已有的映射        System.out.println("请输入新的课程名称：");        String name = console.next();        Course newCourse = new Course(crID,name);        courses.put(crID, newCourse);        System.out.println("修改成功！");        break;    }}public static void main(String[] args) {    MapTest mt = new MapTest();    mt.testPut();    mt.testKeySet();    mt.testRemove();    mt.testModify();    mt.testEntrySet();}}</code></pre><p>编译运行：</p><pre><code>$ javac Course.java MapTest.java$ java MapTest 请输入课程 ID： 1请输入课程名称：语文成功添加课程：语文请输入课程 ID：1该课程 ID 已被占用请输入课程 ID：2请输入课程名称：数学成功添加课程：数学课程：语文课程：数学请输入要删除的课程 ID！1成功删除课程语文请输入要修改的课程 ID：2当前该课程 ID，所对应的课程为：数学请输入新的课程名称：英语修改成功！取得键：2对应的值为：英语</code></pre><h2 id="Set-和-HashSet"><a href="#Set-和-HashSet" class="headerlink" title="Set 和 HashSet"></a>Set 和 HashSet</h2><p>Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。</p><p>HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。</p><p>接下来我们通过代码的形式来详细看一看吧！</p><h2 id="编程实例-1"><a href="#编程实例-1" class="headerlink" title="编程实例"></a>编程实例</h2><p>假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧。</p><p>因为项目组的组长由一个老师担任，首先在/home/project目录下创建一个 PD 类</p><pre><code>// PD.javaimport java.util.HashSet;import java.util.Set;/** 项目组长类*/public class PD {public String id;public String name;//集合后面的&lt;&gt;代表泛型的意思//泛型是规定了集合元素的类型public Set&lt;Student&gt; students;public PD(String id, String name){    this.id = id;    this.name = name;    this.students = new HashSet&lt;Student&gt;();}}</code></pre><p>copy<br>在/home/project/创建一个学生类Student.java：</p><pre><code>/** * 学生类 */// Student.javapublic class Student {public String id;public String name;public Student(String id, String name){    this.id = id;    this.name = name;}@Overridepublic String toString() {    return "Student{" +            "id='" + id + '\'' +            ", name='" + name + '\'' +            '}';}}</code></pre><p>接下来我们便创建一个 SetTest 类，用来管理项目成员</p><pre><code>// SetTest.javaimport java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;public class SetTest {public List&lt;Student&gt; students;public SetTest() {    students = new ArrayList&lt;Student&gt;();}/* * 用于往students中添加学生 */public void testAdd() {    //创建一个学生对象，并通过调用add方法，添加到学生管理List中    Student st1 = new Student("1", "张三");    students.add(st1);    //添加到List中的类型均为Object，所以取出时还需要强转    Student st2 = new Student("2","李四");    students.add(st2);    Student[] student = {new Student("3", "王五"),new Student("4", "马六")};    students.addAll(Arrays.asList(student));    Student[] student2 = {new Student("5", "周七"),new Student("6", "赵八")};    students.addAll(Arrays.asList(student2));}/** * 通过for each 方法访问集合元素 * @param args */public void testForEach() {    System.out.println("有如下学生（通过for each）：");    for(Object obj:students){        Student st = (Student)obj;        System.out.println("学生：" + st.id + ":" + st.name);    }}public static void main(String[] args){    SetTest st = new SetTest();    st.testAdd();    st.testForEach();    PD pd = new PD("1","张老师");    System.out.println("请：" + pd.name + "选择小组成员！");    //创建一个 Scanner 对象，用来接收从键盘输入的学生 ID    Scanner console = new Scanner(System.in);    for(int i = 0;i &lt; 3; i++){        System.out.println("请输入学生 ID");        String studentID = console.next();        for(Student s:st.students){            if(s.id.equals(studentID)){                pd.students.add(s);            }        }    }    st.testForEachForSer(pd);    // 关闭 Scanner 对象    console.close();}//打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator //不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素public void testForEachForSer(PD pd){    for(Student s: pd.students) {    System.out.println("选择了学生：" + s.id + ":" + s.name);    }}}</code></pre><p>编译运行:</p><pre><code>$ javac PD.java SetTest.java Student.java$ java SetTest有如下学生（通过for each）：学生：1:张三学生：2:李四学生：3:王五学生：4:马六学生：5:周七学生：6:赵八请：张老师选择小组成员！请输入学生 ID4请输入学生 ID5请输入学生 ID6选择了学生：4:马六选择了学生：5:周七选择了学生：6:赵八</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections 是一个工具类，他包含了大量对集合进行操作的静态方法。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="http://image.lichongbing.com/static/c45f726c94de417866fb974a2217ad14.png" alt="截屏2019-12-1000.58.19.png"></p><h2 id="编程实例-2"><a href="#编程实例-2" class="headerlink" title="编程实例"></a>编程实例</h2><p>在/home/project目录下创建CollectionsDemo.java</p><pre><code> import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CollectionsDemo { public static void main(String[] args) { //        创建一个空List    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    //赋值    list.add(3);    list.add(5);    list.add(7);    list.add(9);    list.add(12);    System.out.print("初始顺序：");    list.forEach(v -&gt; System.out.print(v + "\t"));    //打乱顺序    Collections.shuffle(list);    System.out.print("\n打乱顺序：");    list.forEach(v -&gt; System.out.print(v + "\t"));    //反转    Collections.reverse(list);    System.out.print("\n反转集合：");    list.forEach(v -&gt; System.out.print(v + "\t"));    //第一个位和最后一位交换    Collections.swap(list,0,list.size()-1);    System.out.print("\n交换第一位和最后一位：");    list.forEach(v -&gt; System.out.print(v + "\t"));    //按自然升序排序    Collections.sort(list);    System.out.print("\nSort排序后：");    list.forEach(v -&gt; System.out.print(v + "\t"));    //二分查找 必须排序后    System.out.print("\n二分查找数值7的位置："+Collections.binarySearch(list, 7));    //返回线程安全的list    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list);}}</code></pre><p>编译执行</p><pre><code>$ javac CollectionsDemo.java$ java CollectionsDemo初始顺序：3    5    7    9    12    打乱顺序：5    7    3    12    9    反转集合：9    12    3    7    5    交换第一位和最后一位：5    12    3    7    9    Sort排序后：3    5    7    9    12    二分查找数值7的位置：2</code></pre><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量—维基百科</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><code>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</code></p><p>排序过程如下：</p><p>1.从第一个元素开始，该元素可以认为已经被排序</p><p>2.取出下一个元素，在已经排序的元素序列中从后向前扫描</p><p>3.如果该元素（已排序）大于新元素，将该元素移到下一位置</p><p>4.重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</p><p>5.将新元素插入到该位置后</p><p>6.重复步骤 2~5<br><img src="http://image.lichongbing.com/static/ee7ad72d0f49cc872c7ccb9fd601387c.gif" alt="wm.gif"><br>–图片来自维基百科</p><p>在/home/project目录下新建一个文件InsertSort.java</p><pre><code>import java.util.Arrays;public class InsertSort {public static void sort(int[] arr) {    int temp;    for (int i = 1; i &lt; arr.length; i++) {        for (int j = 0; j &lt; i; j++) {            //对已经排序好的元素比较，找到一个比插入元素大的元素 交换位置            if (arr[i] &lt; arr[j]) {                temp = arr[i];                arr[i] = arr[j];                arr[j] = temp;            }        }    }}public static void main(String[] args) {    int[] ints = {5, 3, 4, 1, 2};    sort(ints);    System.out.println(Arrays.toString(ints));}}</code></pre><p>编译运行：</p><pre><code>$ javac InsertSort.java$ java InsertSort[1, 2, 3, 4, 5]</code></pre><p>冒泡排序</p><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。<br>冒泡排序的运行过程如下：</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>在/home/project目录下新建一个文件BubbleSort.java</p><pre><code>import java.util.Arrays;public class BubbleSort {public static void sort(int[] arr) {    for (int i = 0; i &lt; arr.length-1; i++) {        for (int j = 0; j &lt; arr.length - i - 1; j++) {            //如果当前元素比后一位元素大 交换位置            if (arr[j] &gt; arr[j + 1]) {                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }}public static void main(String[] args) {    int[] ints = {5, 3, 4, 1, 2};    sort(ints);    System.out.println(Arrays.toString(ints));}}</code></pre><p>编译运行：</p><pre><code>$ javac BubbleSort.java$ java BubbleSort[1, 2, 3, 4, 5]</code></pre><p>归并排序</p><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>排序过程：</p><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤 3 直到某一指针到达序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾<br><img src="http://image.lichongbing.com/static/d58790be27ff7ae63fb3115ca5941bcc.png" alt="wm-21.png"><br>–图片来自维基百科</p><p>在/home/project目录下新建一个文件MergeSort.java</p><pre><code>import java.util.Arrays;public class MergeSort {public static void mergeSort(int[] arrays, int left, int right) {//        如果数组还可以拆分    if (left &lt; right) {        //数组的中间位置        int middle = (left + right) / 2;        //拆分左边数组        mergeSort(arrays, left, middle);        //拆分右边数组        mergeSort(arrays, middle + 1, right);        //合并        merge(arrays, left, middle, right);    }}/** * 合并数组 */public static void merge(int[] arr, int left, int middle, int right) {    //申请合并空间 大小为两个已经排序序列之和    int[] temp = new int[right - left + 1];    //i 和 j为两个已经排好序的数组的起始位置    int i = left;    int j = middle + 1;    int k = 0;    //排序    while (i &lt;= middle &amp;&amp; j &lt;= right) {        //将比较小的数组放入合并空间        if (arr[i] &lt; arr[j]) {            temp[k++] = arr[i++];        } else {            temp[k++] = arr[j++];        }    }    //将左边剩余元素写入合并空间    while (i &lt;= middle) {        temp[k++] = arr[i++];    }    //将右边剩余的元素写入合并空间    while (j &lt;= right) {        temp[k++] = arr[j++];    }    //将排序后的数组写回原来的数组    for (int l = 0; l &lt; temp.length; l++) {        arr[l + left] = temp[l];    }}public static void main(String[] args) {    int[] ints = {5, 3, 4, 1, 2};    mergeSort(ints,0,ints.length-1);    System.out.println(Arrays.toString(ints));}}</code></pre><p>编译运行：</p><pre><code>$ javac MergeSort.java$ java MergeSort[1, 2, 3, 4, 5]</code></pre><p>快速排序</p><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 O(nlogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。<br>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><p>步骤为：</p><p>从数列中挑出一个元素，称为“基准”（pivot），<br>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。<br>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<br><img src="http://image.lichongbing.com/static/d2ce22670438b3503ffee90067a8a4a3.gif" alt="wm-2.gif"><br><img src="http://image.lichongbing.com/static/c6b4707989a1044defb1f42ee03d61a5.png" alt="wm-22.png"><br>–来自维基百科</p><p>在/home/project目录下新建一个文件QuickSort.java</p><pre><code>import java.util.Arrays;public class QuickSort {public static void sort(int[] arr, int head, int tail) {    if (head &gt;= tail || arr == null || arr.length &lt;= 1) {        return;    }    //设置数组的起始位置 i 结束位置j 基准 pivot 为数组的中间    int i = head, j = tail, pivot = arr[(head + tail) / 2];    while (i &lt;= j) {        //当数组小于基准 循环结束后 相当于i所处的位置的值为大于基准的元素        while (arr[i] &lt; pivot) {            ++i;        }        //当数组大于基准 循环结束后 相当于j所处的位置的值为小于于基准的元素        while (arr[j] &gt; pivot) {            --j;        }        //如果i&lt;j 那么则将交互i j对应位置的值        if (i &lt; j) {            int t = arr[i];            arr[i] = arr[j];            arr[j] = t;            //将指针继续移动            ++i;            --j;        } else if (i == j) {//如果i=j 那么说明本次排序已经结束 将i++ 如果这里不使用i++ 那么后面的sort(arr,i,tail)将改为arr(arr,i+1,tail)            ++i;        }    }    //继续将数组分割      sort(arr, head, j);    sort(arr, i, tail);}public static void main(String[] args) {    int[] ints = {5, 3, 4, 1, 2};    sort(ints, 0, ints.length - 1);    System.out.println(Arrays.toString(ints));}}</code></pre><p>编译运行：</p><pre><code>$ javac QuickSort.java$ java QuickSort[1, 2, 3, 4, 5]</code></pre><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="线性搜索"><a href="#线性搜索" class="headerlink" title="线性搜索"></a>线性搜索</h3><p>线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。<br>在/home/project目录下新建一个文件LinearSearch.java</p><pre><code>public class LinearSearch {public static void main(String[] args) {    int[] ints = {5, 3, 4, 1, 2};    System.out.println(search(ints, 4));}public static int search(int[] arr, int key) {    //循环    for (int i = 0; i &lt; arr.length; i++) {        //比较是否等于key        if (arr[i] == key) {            return arr[i];        }    }    //找不到就返回-1    return -1;}}</code></pre><p>编译运行：</p><pre><code> $ javac LinearSearch.java $ java LinearSearch 4</code></pre><p>二分查找</p><p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br>在/home/project目录下新建一个文件BinarySearch.java</p><pre><code>public class BinarySearch {public static int search(int[] arr, int key) {    int low = 0;    int high = arr.length - 1;    while (low &lt;= high) {        int middle = (high + low) / 2;        //如果相等 返回值        if (key == arr[middle]) {            return key;        } else if (key &lt; arr[middle]) {            //如果key小于中间值，那么改变high，值可能在左边部（比较小的部分）            high = middle - 1;        }else {            //如果key大于中间值，那么改变low，值可能在右边部（比较大的部分）            low = middle + 1;        }    }    return -1;}public static void main(String[] args) {    int[] ints = {1, 2, 3, 4, 5};    System.out.println(search(ints, 4));}}</code></pre><p>编译运行：</p><pre><code>$ javac BinarySearch.java$ java BinarySearch4</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要讲解了泛型和集合，不仅涉及基础概念，而且针对常用方法都有列举示例。主要涵盖了以下知识点：</p><p>泛型</p><ul><li>Collection</li><li>List</li><li>ArrayList</li><li>Map</li><li>HashMap</li><li>Set 和 HashSet</li><li>Collections</li><li>算法<br>请大家务必手动完成代码并运行对比结果，这样才能更好对理解并熟练使用泛型和集合。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/2016/12/09/java-chang-yong-lei/"/>
      <url>/2016/12/09/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 类库提供了不少常用类，可以在编程中直接调用使用。本节讲重点讲解 Arrays、StringBuilder、Calendar、Date、Math、System、Random 类以及类的常用方法。</p><p>知识点</p><ul><li><p>Arrays</p></li><li><p>StringBuilder</p></li><li><p>Calendar</p></li><li><p>Date</p></li><li><p>Math</p></li><li><p>System</p></li><li><p>Random</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为 List。</p><h3 id="Arrays-常用方法"><a href="#Arrays-常用方法" class="headerlink" title="Arrays 常用方法"></a>Arrays 常用方法</h3><p>  方法                         描述</p><p>   <t> List<t> asList(T… a)    返回由指定数组构造的List</t></t></p><p>  void sort(Object[] a)    对数组进行排序</p><p>  void fill(Object[] a, Object val)    为数组的所有元素都赋上相同的值</p><p>  boolean equals(Object[] a, Object[] a2)    检查两个数组是否相等</p><p>  int binarySearch(Object[] a, Object key)    对排序后的数组使用二分法查找数据</p></li></ul><h3 id="Arrays-编程实例"><a href="#Arrays-编程实例" class="headerlink" title="Arrays 编程实例"></a>Arrays 编程实例</h3><p>在/home/project/下新建一个ArraysDemo.java</p><pre><code>import java.util.Arrays;import java.util.Random;public class ArraysDemo {public static void main(String[] args) {    int[] arr = new int[10];    //将数组元素都设为9    Arrays.fill(arr, 9);    System.out.println("fill:" + Arrays.toString(arr));    Random random = new Random();    for (int i = 0; i &lt; arr.length; i++) {        //使用100以内的随机数赋值数组        arr[i] = random.nextInt(101);    }    //重新赋值后的数组    System.out.println("重新赋值：" + Arrays.toString(arr));    //将索引为5的元素设为50    arr[5] = 50;    //排序    Arrays.sort(arr);    //排序后的数组    System.out.println("sort排序后：" + Arrays.toString(arr));    //查找50的位置    int i = Arrays.binarySearch(arr, 50);    System.out.println("值为50的元素索引："+i);    //复制一份新数组    int[] newArr = Arrays.copyOf(arr, arr.length);    //比较    System.out.println("equals:"+Arrays.equals(arr, newArr));}}</code></pre><p>编译运行：</p><pre><code>$ javac ArraysDemo.java$ java ArraysDemofill:[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]重新赋值：[69, 83, 40, 58, 94, 42, 2, 53, 43, 83]sort排序后：[2, 40, 43, 50, 53, 58, 69, 83, 83, 94]值为50的元素索引：3equals:true</code></pre><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>在/home/project/下新建一个ArraysTest.java</p><p>你需要完成以下需求：</p><ul><li><p>使用 Arrays 将数组[6, 17, 92, 32, 58, 22, 84, 66, 36, 33]进行排序</p></li><li><p>找出排序后 33 所在的位置</p></li><li><p>测试一下如果不排序能否找到值 33？</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Arrays;public class ArraysTest {public static void main(String[] args) {  int[] arr = {6, 17, 92, 32, 58, 22, 84, 66, 36, 33};  Arrays.sort(arr);  System.out.println(Arrays.binarySearch(arr, 33));}}</code></pre><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2></li></ul><p>StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）</p><p>StringBuilder 的构造方法<br><img src="http://image.lichongbing.com/static/a064d763ecb0d6a781da3448c490abe7.png" alt="截屏2019-12-0923.51.19.png"><br>上面的方法中我们选择几个，来写写代码吧：</p><p>在/home/project/目录下新建StringBuilderTest.java</p><pre><code>public class StringBuilderTest {public static void main(String[] args){    //定义和初始化一个StringBuilder类的字串s    StringBuilder s = new StringBuilder("I");    //在s后面添加字串" java"    s.append(" java");    //在s[1]的位置插入字串    s.insert(1, " love");    String t = s.toString(); //转为字符串    System.out.println(t);}}</code></pre><p>输出结果为： I love java</p><p>其他的方法，请同学们一定要自己亲自一一验证一下！</p><p>在这里只介绍了 StringBuilder 类常用的方法，其他方法可参照 JDK 文档。</p><h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p><img src="http://image.lichongbing.com/static/9bc74626252c78991fa25b042421121d.png" alt="截屏2019-12-0923.53.42.png"></p><pre><code>//太平洋时区的 ID 为 PSTTimeZone tz0 = TimeZone.getTimeZone("PST")//getDefault()可以获取主机所处时区的对象TimeZone tz1 = TimeZone.getDefault()</code></pre><p>Locale 只是一种机制，它用来标识一个特定的地理、政治或文化区域获取一个 Locale 对象的构造方法：</p><pre><code>//调用Locale类的构造方法Locale l0 = new Locale(String language)Locale l1 = new Locale(String language, String country)Locale l2 = new Locale(String languge, String country, String variant)//调用Locale类中定义的常量Locale  l1 = Locale.CHINA</code></pre><h2 id="Calendar-编程实例"><a href="#Calendar-编程实例" class="headerlink" title="Calendar 编程实例"></a>Calendar 编程实例</h2><p>在/home/project/目录下新建源代码文件CalendarDemo.java。</p><pre><code>import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class CalendarDemo {public static void main(String[] args) {    System.out.println("完整显示日期时间：");    // 字符串转换日期格式    DateFormat fdate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    String str = fdate.format(new Date());    System.out.println(str);    // 创建 Calendar 对象    Calendar calendar = Calendar.getInstance();    // 初始化 Calendar 对象，但并不必要，除非需要重置时间    calendar.setTime(new Date());    // 显示年份    System.out.println("年： " + calendar.get(Calendar.YEAR));    // 显示月份 (从0开始, 实际显示要加一)    System.out.println("月： " + calendar.get(Calendar.MONTH));    // 当前分钟数    System.out.println("分钟： " + calendar.get(Calendar.MINUTE));    // 今年的第 N 天    System.out.println("今年的第 " + calendar.get(Calendar.DAY_OF_YEAR) + "天");    // 本月第 N 天    System.out.println("本月的第 " + calendar.get(Calendar.DAY_OF_MONTH) + "天");    // 3小时以后    calendar.add(Calendar.HOUR_OF_DAY, 3);    System.out.println("三小时以后的时间： " + calendar.getTime());    // 格式化显示    str = (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS")).format(calendar.getTime());    System.out.println(str);    // 重置 Calendar 显示当前时间    calendar.setTime(new Date());    str = (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS")).format(calendar.getTime());    System.out.println(str);    // 创建一个 Calendar 用于比较时间    Calendar calendarNew = Calendar.getInstance();    // 设定为 5 小时以前，后者大，显示 -1    calendarNew.add(Calendar.HOUR, -5);    System.out.println("时间比较：" + calendarNew.compareTo(calendar));    // 设定7小时以后，前者大，显示 1    calendarNew.add(Calendar.HOUR, +7);    System.out.println("时间比较：" + calendarNew.compareTo(calendar));    // 退回 2 小时，时间相同，显示0    calendarNew.add(Calendar.HOUR, -2);    System.out.println("时间比较：" + calendarNew.compareTo(calendar));    // calendarNew创建时间点    System.out.println((new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS")).format(calendarNew.getTime()));    // calendar创建时间点    System.out.println((new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS")).format(calendar.getTime()));    System.out.println("时间比较：" + calendarNew.compareTo(calendar));}}</code></pre><p>编译运行：</p><pre><code>$ javac CalendarDemo.java$ java CalendarDemo完整显示日期时间：2018-12-12 15:50:49年： 2018月： 11分钟： 50今年的第 346天本月的第 12天三小时以后的时间： Wed Dec 12 18:50:49 CST 20182018-12-12 18:50:49:4492018-12-12 15:50:49:455时间比较：-1时间比较：1时间比较：12018-12-12 15:50:49:4562018-12-12 15:50:49:455时间比较：1</code></pre><p>大家运行上面的代码后，看见控制台上的输出结果会不会有所疑问呢？</p><p>其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。</p><p>有的同学可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><img src="http://image.lichongbing.com/static/42f9a0b95304da79906272ff0f75d1ca.png" alt="截屏2019-12-0923.58.28.png"></p><h2 id="Date-编程实例"><a href="#Date-编程实例" class="headerlink" title="Date 编程实例"></a>Date 编程实例</h2><p>在/home/project/目录下新建一个源代码文件DateDemo.java</p><pre><code>import java.text.SimpleDateFormat;import java.util.Date;public class DateDemo {public static void main(String[] args) {    String strDate, strTime;    Date objDate = new Date();    System.out.println("今天的日期是：" + objDate);    long time = objDate.getTime();    System.out.println("自1970年1月1日起以毫秒为单位的时间（GMT）：" + time);    strDate = objDate.toString();    //提取 GMT 时间    strTime = strDate.substring(11, (strDate.length() - 4));    //按小时、分钟和秒提取时间    strTime = "时间：" + strTime.substring(0, 8);    System.out.println(strTime);    //格式化时间    SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    System.out.println(formatter.format(objDate));  }}</code></pre><p>编译运行:</p><pre><code>$ javac DateDemo.java$ java DateDemo今天的日期是：Wed Dec 12 14:43:15 CST 2018自1970年1月1日起以毫秒为单位的时间（GMT）：1544596995669时间：14:43:152018-12-12 14:43:15</code></pre><p>Date 类的很多方法自 JDK 1.1 开始就已经过时了。</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><img src="http://image.lichongbing.com/static/58ef5f1b5f78fb8e8a5fb81d058a966b.png" alt="截屏2019-12-1000.00.55.png"></p><h2 id="Math-编程实例"><a href="#Math-编程实例" class="headerlink" title="Math 编程实例"></a>Math 编程实例</h2><p>在/home/project/下新建一个MathDemo.java</p><pre><code>public class MathDemo {public static void main(String[] args) {    System.out.println(Math.abs(-12.7));    System.out.println(Math.ceil(12.7));    System.out.println(Math.rint(12.4));    System.out.println(Math.random());    System.out.println("sin30 = " + Math.sin(Math.PI / 6));    // 计算30°的正弦值，参数是用弧度表示的角，即π的六分之一    System.out.println("cos30 = " + Math.cos(Math.PI / 6));    // 计算30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为double    System.out.println("tan30 = " + Math.tan(Math.PI / 6));    // 计算30°的正切值 } }</code></pre><p>编译运行：</p><pre><code>$ javac MathDemo.java$ java MathDemo 12.7 13.0 12.0 0.8011998172263968 sin30 = 0.49999999999999994 cos30 = 0.8660254037844387 tan30 = 0.5773502691896257</code></pre><h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><p>在/home/project/下新建一个MathTest.java</p><p>你需要完成以下需求：</p><ul><li><p>使用 Math.random()生成两个随机数 a 和 b</p></li><li><p>求出两个随机数中的较大值</p></li><li><p>只能使用 Math 类中的方法</p><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h3><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><p>  public class MathTest {<br>  public static void main(String[] args) {</p><pre><code>  double a = Math.random();  double b = Math.random();  System.out.println(a);  System.out.println(b);  System.out.println(Math.max(a, b));</code></pre><p>  }</p><p>  }</p></li></ul><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System 类提供了以下功能：</p><ul><li>标准输入，标准输出和错误输出流;</li><li>访问外部定义的属性和环境变量;</li><li>加载文件和库的方法;</li><li>以及用于快速复制数组的实用方法。</li></ul><p>System 不可以被实例化，只可以使用其静态方法。</p><pre><code>//从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length) //返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)public static long currentTimeMillis()  //终止当前正在运行的Java虚拟机，status为 0时退出public static void exit(int status)  //  运行垃圾收集器public static void gc() // 取得当前系统的全部属性public static Properties getProperties()//获取指定键的系统属性public static String  getProperty(String key) </code></pre><h2 id="System-使用示例"><a href="#System-使用示例" class="headerlink" title="System 使用示例"></a>System 使用示例</h2><p>在/home/project/目录下新建一个源代码文件SystemDemo.java</p><pre><code>import java.util.Arrays;public class SystemDemo {public static void main(String[] args) {    int[] a = {7, 8, 9, 10, 11};    int[] b = {1, 2, 3, 4, 5, 6};    //从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3    System.arraycopy(a, 1, b, 2, 3);    //输出结果    System.out.println(Arrays.toString(b));    System.out.println("当前时间：" + System.currentTimeMillis());    System.out.println("java版本信息：" + System.getProperty("java.version"));    //运行垃圾收集器    System.gc();    //退出    System.exit(0);    } }</code></pre><p>编译运行：</p><pre><code> $ javac SystemDemo.java $ java SystemDemo [1, 2, 8, 9, 10, 6] 当前时间：1544670501472 java版本信息：11</code></pre><h2 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h2><p>在/home/project/目录下新建一个源代码文件SystemTest.java</p><p>你需要完成以下需求：</p><ul><li>获取 Java 的安装目录(java.home)</li><li>练习 System.arraycopy 方法（自己随便复制两个数组）</li></ul><h2 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Arrays;public class SystemTest {public static void main(String[] args) {    int[] a = {7, 8, 9, 10, 11};    int[] b = {1, 2, 3, 4, 5, 6};    //从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3    System.arraycopy(a, 1, b, 2, 3);    //输出结果    System.out.println(Arrays.toString(b));    System.out.println("java版本信息：" + System.getProperty("java.home"));}}</code></pre><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>Random 类用于生成伪随机数流，在java.util包下。</p><h2 id="Random-编程实例"><a href="#Random-编程实例" class="headerlink" title="Random 编程实例"></a>Random 编程实例</h2><p>在/home/project/目录下新建一个源代码文件RandomDemo.java</p><pre><code>import java.util.Random;public class RandomDemo {public static void main(String[] args) {    Random random = new Random();    //随机生成一个整数 int范围    System.out.println(random.nextInt());    //生成 [0,n] 范围的整数  设n=100    System.out.println(random.nextInt(100 + 1));    //生成 [0,n) 范围的整数  设n=100    System.out.println(random.nextInt(100));    //生成 [m,n] 范围的整数  设n=100 m=40    System.out.println((random.nextInt(100 - 40 + 1) + 40));    //随机生成一个整数 long范围    System.out.print(random.nextLong());    //生成[0,1.0)范围的float型小数    System.out.println(random.nextFloat());    //生成[0,1.0)范围的double型小数    System.out.println(random.nextDouble());  }}</code></pre><p>、<br>编译运行：</p><pre><code>$ javac RandomDemo.java$ java RandomDemo 272128541 67 93 66-23177167376469717070.931040350.20044632645967309</code></pre><h2 id="练习题：输出随机数"><a href="#练习题：输出随机数" class="headerlink" title="练习题：输出随机数"></a>练习题：输出随机数</h2><p>在/home/project/目录下新建一个源代码文件RandomTest.java，你需要完成以下需求：</p><ul><li>从控制台中获取 Int 数据 m，n (m &lt; n)，先输入 m，后输入 n</li><li>输出一个[m,n]之间的随机数<br>示例：</li></ul><pre><code>输入： 30   40输出：   32</code></pre><h2 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a>参考答案</h2><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Random;import java.util.Scanner;public class RandomTest {public static void main(String[] args) {    Scanner in = new Scanner(System.in);    int m = in.nextInt();    int n = in.nextInt();    Random random = new Random();    System.out.println(random.nextInt(n - m + 1) + m);}}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 类库还拥有很多类，本节仅对常用的几种类进行讲解。主要内容包含以下知识点：</p><ul><li>Arrays</li><li>StringBuilder</li><li>Calendar</li><li>Date</li><li>Math</li><li>System</li><li>Random<br>请大家务必手动完成代码并运行对比结果，这样才能更好的理解并熟练使用常用类。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2016/10/19/mian-xiang-dui-xiang/"/>
      <url>/2016/10/19/mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p><strong>简介</strong></p><p>Java 是面向对象的高级编程语言，类和对象是 Java 程序的构成核心。本节讲重点讲解面向对象的相关内容，主要围绕 Java 类和 java 对象展开。</p><p>知识点</p><ul><li>类</li><li>对象</li><li>构造方法</li><li>引用与对象实例</li><li>static</li><li>final</li><li>封装</li><li>继承</li><li>方法重载与重写</li><li>多态</li><li>抽象类</li><li>接口</li><li>内部类</li></ul><p><strong>面向对象基本概念</strong></p><p>对象，从字面意思来看就是我们面对的物象。由此便可以知道，万事万物皆为对象。比如：一台电脑，一辆汽车，一部手机等等都是对象。</p><p>面向对象，从字面意思来看就是我们人面对着一个对象。其实就是指我们从这个对象的整体出发去看它，它由哪些部件组成，它可以做到哪些事情。</p><p>比如我们想要买一部手机，我们想要内存大一点的，最新款的，CPU 运算快一点的，能实现发短信和打电话功能的手机。那么这部手机是不是对象呢？它不是。当我们买了一部 iPhone 6 后，它满足我们上面的所有信息。于是我们拿在手上的这部 iphone 6 就是我们的对象。于是我们知道，对象一定是一个具体的、确定的物体。</p><p>而这部手机它的样式，颜色，大小，产地，编号等等，便是这部手机的“属性”，这部手机可以打电话、发短信，便是它的“行为”。</p><p>面向对象的思想，体现的是人所关注对象的信息聚集在了一个具体的物体上。人们就是通过对象的属性和行为来了解对象。</p><p><strong>类</strong></p><p>对于一个具体的对象而言，比如一部 iphone 6，世上还有许多跟这部手机有着同样属性或行为的对象，我们为了方便将它们归类起来，提取出他们相同的属性和行为，而我们把归类起来的这个抽象的概念，称之为类。</p><p>比如每个人就是一个对象，小张是一个对象，小明是一个对象。而每个人虽然不同，但却有许多相同的属性和行为，于是我们可以把他们抽象出来，变成一个类，比如人类。</p><p>类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。</p><p>由此可以总结出类的定义：</p><p>类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。<br>类是具有相同属性和方法（行为）的对象的集合<br>我们在上面反复强调对象的属性和行为，什么是对象的属性呢？什么又是对象的行为呢？</p><p>属性是对象具有的特征。每个对象的每个属性都拥有特定值。我们上面讲过对象是一个具体并且确定的事物，正是对象属性的值来区分不同的对象，比如我们可以通过一个人的外貌特征区分他。</p><p>那什么是对象的行为呢?在计算机中我们通过方法去实现对象的行为，而对象的方法便是对象所具有的操作，比如人会走路、会哭泣、会学习等等都是人的行为，也就是人的方法。</p><p>类和对象之间有什么关系吗？在上面的讲解中大家应该有些了解了。类就是对象的抽象(或者模板)，对象就是类的具体（或者实例）。比如手机是一个抽象的概念，它代表着类。而一部 iphone 6 便是手机具象化处理的实体，也就是一个对象。</p><p>说了那么多，那我们如何在计算机中定义一个类，如何实现一个类呢？</p><p>我们以前说过，Java 是面向对象的语言，而他的体现就在于 Java 程序都以类 class 为组织单元。而一个类是对象的抽象，所以类由属性和方法两部分组成。</p><p>定义一个类，主要有三个步骤：</p><p>1、定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public为权限修饰符。</p><pre><code>public class 类名{//定义属性部分（成员变量）属性1的类型 属性1;属性2的类型 属性2;...//定义方法部分方法1;方法2;...}</code></pre><p>2、编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性。</p><p>3、编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法。</p><p>在home/project/目录下建立源代码文件People.java</p><pre><code> public class People {//属性（成员变量） 有什么double height;  //身高int age;     //年龄int sex;    //性别，0为男性，非0为女性//方法 干什么void cry(){    System.out.println("我在哭！");}void laugh(){    System.out.println("我在笑！");}void printBaseMes(){    System.out.println("我的身高是"+height+"cm");    System.out.println("我的年龄是"+age+"岁");    if(this.sex==0)        System.out.println("我是男性！");    else         System.out.println("我是女性！");}}</code></pre><p>一个类可以包含以下类型变量：</p><ul><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造* * 方法和特定类的语句块访问。</li></ul><p><strong>对象</strong></p><p>创建对象的语法如下：</p><pre><code>类名 对象名 = new 类名();</code></pre><p>比如对People这个类，我想实例化LiLei这个人。LiLei 的数据类型便是 People 这个类型。（类可以看成使我们自己定义的数据类型）</p><pre><code>People LiLei = new People();</code></pre><p>定义类的时候不会为类开辟内存空间，但是一旦创建了对象，系统就会在内存中为对象开辟一块空间，用来存放对象的属性值和方法。新建一个 NewObject.java 文件。</p><pre><code>public class NewObject {public static void main(String[] args) {    People LiLei = new People(); //创建一个People对象LiLei    LiLei.height =170;    LiLei.age = 20;    LiLei.sex = 1;    LiLei.printBaseMes();}}</code></pre><p>编译运行：</p><pre><code>$ javac NewObject.java People.java$ java NewObject我的身高是170.0cm我的年龄是20岁我是女性！</code></pre><p><img src="http://image.lichongbing.com/static/86284a0b276cf6c8968fe2867e387ee2.png" alt="wm-15.png"><br>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 static 类型。<br>创建对象后，我们就要使用对象了，使用对象无非就是对属性和方法进行操作和调用。语法如下</p><pre><code>//引用对象属性对象名.属性//引用对象方法对象名.方法</code></pre><p>例如对 LiLei 的身高赋值，并调用哭这个方法</p><pre><code>LiLei.height = 170;LiLei.cry();</code></pre><p>刚刚我们引入了成员变量这个概念，那什么是成员变量呢？成员变量就是指的对象的属性，是在类中定义，来描述对象的特性。还有一种变量叫局部变量，它是由类的方法定义，在方法中临时保存数据。<br><img src="http://image.lichongbing.com/static/a3fac2e8d7c751e213329ed2e01b5ade.png" alt="wm-16.png"><br>在使用时注意，成员变量可以被本类的所有方法所使用，同时可以被与本类有关的其他类所使用。而局部变量只能在当前的方法中使用。</p><p>在这里我们要讲到一个关于作用域的知识了。作用域可以简单地理解为变量的生存期或者作用范围，也就是变量从定义开始到什么时候消亡。</p><ul><li>局部变量的作用域仅限于定义它的方法内。而成员变量的作用域在整个类内部都是可见的。</li><li>同时在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量。</li><li>成员变量和局部变量同名时，局部变量具有更高的优先级。 大家可以编写代码验证一下。</li></ul><p><strong>构造方法</strong><br>在面向对象中有一个非常重要的知识点，就是构造方法。每个类都有构造方法，在创建该类的对象的时候他们将被调用，如果没有定义构造方法，Java 编译器会提供一个默认构造方法。 创建一个对象的时候，至少调用一个构造方法。比如在新建一个对象new Object()，括号中没有任何参数，代表调用一个无参构造方法（默认构造方法就是一个无参构造方法）。构造方法的名称必须与类名相同，一个类可以定义多个构造方法。</p><p>构造方法的具体内容：</p><p>1、构造方法的名称与类名相同，且没有返回值。它的语法格式如下：</p><pre><code>//与类同名，可以指定参数，没有返回值public 构造方法名(){//初始化代码}</code></pre><p>下面是一个构造方法的例子：</p><pre><code>public class People{//无参构造方法public People(){}//有一个参数的构造方法public People(int age){}}</code></pre><p>又例如具体的构造方法：</p><pre><code>public class People {//属性（成员变量）有什么double height;     //身高int age;           //年龄int sex;       //性别，0为男性，非0为女性//构造函数，初始化了所有属性public People(double h, int a, int s){    height = h;    age = a;    sex = s;}}//创建对象，调用我们自己定义的有参构造方法People XiaoMing = new People(168, 21, 1);</code></pre><p>上面的例子中通过new关键字将类实例化成对象，而new后面跟的就是构造方法。于是可以知道new + 构造方法可以创建一个新的对象。</p><p>2、如果在定义类的时候没有写构造方法，系统会默认生成一个无参构造方法，这个构造方法什么也不会做。</p><p>3、当有指定的构造方法时，系统都不会再添加无参构造方法了。</p><p>4、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。</p><p><strong>引用与对象实例</strong></p><p>在新建对象实例时，需要为对象实例设置一个对象名，就像这样</p><pre><code>Object object=new Object();</code></pre><p>那么变量 object 就真的是 Object 对象么，这里其实只是创建了一个 object 对象的引用。如果同学们学过 C 语言，这里就和指针一样，变量 object 保存的其实 Object 对象的引用，指向了 Object 对象。</p><pre><code>     ----------           ----------     | object |---------&gt; | Object |     ----------           ----------     |        |           |        |     ----------           ----------     |        |           |        |     ----------           ----------     |        |           |        |     ----------           ----------     |        |           |        |     ----------           ----------</code></pre><p>再看下面的例子</p><pre><code>Object object1=new Object();Object object2=object1;System.out.println(object1==object2);</code></pre><p>运行得到的结果为 true，说明 object1 和 object2 的地址相同(==会比较两个对象的地址是否相同)，它们实际上是引用同一对象，如果改变 object1 对象内部的属性，那么 object2 的属性同样会改变，同学们可以下来验证这一点。</p><p><strong>static</strong></p><p>静态成员</p><p>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</p><p>如:</p><pre><code>public class StaticTest{public static String string="shiyanlou";public static void main(String[] args){    //静态成员不需要实例化 直接就可以访问    System.out.println(StaticTest.string);    //如果不加static关键字 需要这样访问    StaticTest staticTest=new StaticTest();    System.out.println(staticTest.string);    //如果加上static关键字，上面的两种方法都可以使用}}</code></pre><p>静态方法</p><p>被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法。</p><p><strong>final</strong></p><p>final关键字可以修饰类、方法、属性和变量</p><ul><li><p>final 修饰类，则该类不允许被继承，为最终类</p></li><li><p>final 修饰方法，则该方法不允许被覆盖（重写）</p></li><li><p>final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</p></li><li><p>final 修饰变量，则该变量的值只能赋一次值，即常量<br>如：</p><p>//静态常量<br>public final static String SHI_YAN_LOU=”shiyanlou”;</p></li></ul><p><strong>权限修饰符</strong><br>代码中经常用到private和public修饰符，权限修饰符可以用来修饰属性和方法的访问范围。<br><img src="http://image.lichongbing.com/static/0edbd1bae31bf774769196198ca902e1.png" alt="wm-17.png"><br>如图所示，代表了不同的访问修饰符的访问范围，比如private修饰的属性或者方法，只能在当前类中访问或者使用。默认是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。protected修饰的属性或者方法，对同一包内的类和所有子类可见。public修饰的属性或者方法，对所有类可见。</p><p>我们可以举一个例子，比如 money，如果我们用private修饰代表着这是私有的，只能我自己可以使用。如果是protected代表着我可以使用，和我有关系的人，比如儿子也可以用。如果是public就代表了所有人都可以使用。</p><p><strong>封装</strong></p><p><code>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别 这样做有什么好处？</code></p><p>1.只能通过规定的方法访问数据<br>2.隐藏类的实例细节，方便修改和实现。<br>我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装。</p><p>如何去实现类的封装呢？</p><p>1.修改属性的可见性，在属性的前面添加修饰符(private)<br>2.对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值） 方法，用于对私有属性的访问<br>3.在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。<br><img src="http://image.lichongbing.com/static/bb82714b2bf53bad27a51105e8f1cb36.png" alt="wm-18.png"><br>如果我们没有在属性前面添加任何修饰符，我们通过对象就可以直接对属性值进行修改，没有体现封装的特性。这在许多程序设计中都是不安全的，所以我们需要利用封装，来改进我们的代码。</p><p>首先在类里要将属性前添加private修饰符。然后定义getter和setter方法。修改 People.java 和 NewObject.java 的内容如下。</p><pre><code>public class People {//属性（成员变量）有什么，前面添加了访问修饰符private//变成了私有属性，必须通过方法调用private double height;     //身高//属性已经封装好了，如果用户需要调用属性//必须用getter和setter方法进行调用//getter和setter方法需要程序员自己定义public double getHeight(){    //getter 方法命名是get关键字加属性名（属性名首字母大写）//getter 方法一般是为了得到属性值    return height;}//同理设置我们的setter方法//setter 方法命名是set关键字加属性名（首字母大写）//setter 方法一般是给属性值赋值，所以有一个参数public void setHeight(double newHeight){    height = newHeight;}}</code></pre><p>现在 main 函数里的对象，不能再直接调用属性了，只能通过getter和setter方法进行调用。</p><pre><code>public class NewObject {public static void main(String[] args) {    People LiLei = new People();    //创建了一个People对象LiLei    //利用setter方法为属性赋值    LiLei.setHeight(170.0);    //利用getter方法取属性值    System.out.println("LiLei的身高是"+LiLei.getHeight());}}编译运行：javac NewObject.java People.javajava NewObject.java</code></pre><p>编译运行：</p><pre><code>$ javac NewObject.java People.java$ java NewObjectLiLei的身高是170.0</code></pre><p><strong>this</strong></p><p>this关键字代表当前对象。使用this.属性操作当前对象的属性，this.方法调用当前对象的方法。</p><p>用private修饰的属性，必须定义 getter 和 setter 方法才可以访问到(Eclipse IDEA 等 IDE 都有自动生成 getter 和 setter 方法的功能)。</p><p>如下：</p><pre><code>public void setAge(int age) {    this.age = age;}public int getAge() {    return age;}</code></pre><p>copy<br>创建好了 getter 和 setter 方法后，我们发现方法中参数名和属性名一样。</p><p>当成员变量和局部变量之间发生冲突时，在属性名前面添加了this关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理this关键字可以调用当前对象的方法，同学们自行验证一下吧。</p><p><strong>继承</strong></p><p>继承可以看成是类与类之间的衍生关系。比如狗类是动物类，牧羊犬类又是狗类。于是我们可以说狗类继承了动物类，而牧羊犬类就继承了狗类。于是狗类就是动物类的子类（或派生类），动物类就是狗类的父类（或基类）。</p><p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。<br>语法：</p><pre><code>class 子类 extends 父类</code></pre><p>例如我们定义了一个 Animal 类，再创建一个 Dog 类，我们需要它继承 Animal 类</p><pre><code>class Dog extends Animal {...}</code></pre><p>接下来我们就来练习一下吧！</p><p>我们先创建一个父类 Animal.java</p><pre><code>public class Animal {public int legNum;     //动物四肢的数量//类方法public void bark() {    System.out.println("动物叫！");}}</code></pre><p>接下来创建一个子类Dog.java</p><pre><code>public class Dog extends Animal {}</code></pre><p>Dog 类继承了父类 Animal，我们 Dog 类里什么都没有写，其实它继承了父类 Animal，所以 Dog 类拥有 Animal 类的全部方法和属性（除开 private 方法和属性）。我们创建一个测试类测试一下。</p><pre><code>public class Test{public static void main(String[] args) {    Dog a = new Dog();    a.legNum = 4;    a.bark();}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java Animal.java Dog.java$ java Test  动物叫！</code></pre><p>为什么需要继承？</p><p>如果有两个类相似，那么它们会有许多重复的代码，导致后果就是代码量大且臃肿，后期的维护性不高。通过继承就可以解决这个问题，将两段代码中相同的部分提取出来组成一个父类，实现代码的复用。</p><p>继承的特点：</p><ul><li>子类拥有父类除 private 以外的所有属性和方法</li><li>子类可以拥有自己的属性和方法</li><li>子类可以重写实现父类的方法</li><li>Java 中的继承是单继承，一个类只有一个父类<br>注： <code>Java 实现多继承的一个办法是 implements（实现）接口</code></li></ul><p><strong>super</strong></p><p>super关键字在子类内部使用，代表父类对象。</p><ol><li>访问父类的属性 super.属性名</li><li>访问父类的方法 super.bark()</li><li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super()</li></ol><p><strong>方法重载与重写</strong></p><p>方法重载</p><p>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。</p><pre><code>public class Test {void f(int i) {    System.out.println("i=" + i);}void f(float f) {    System.out.println("f=" + f);}void f(String s) {    System.out.println("s=" + s);}void f(String s1, String s2){    System.out.println("s1+s2="+(s1+s2));}void f(String s, int i){    System.out.println("s="+s+",i="+i);}public static void main(String[] args) {    Test test = new Test();    test.f(3456);    test.f(34.56f);    test.f("abc");    test.f("abc","def");    test.f("abc",3456);}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java$ java Test i=3456 f=34.56 s=abc s1+s2=abcdef s=abc,i=3456</code></pre><p>方法重载有以下几种规则：</p><ul><li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同。</li><li>重载的方法中允许抛出不同的异常</li><li>可以有不同的返回值类型，但是参数列表必须不同</li><li>可以有不同的访问修饰符<br>方法重写</li></ul><p>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。</p><p>比如 Animal 类中有bark()这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵。</p><p>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。</p><p>例如：</p><pre><code>public class Animal {//类方法public void bark() {    System.out.println("动物叫！");}}public class Dog extends Animal {   //重写父类的bark方法    public void bark() {    System.out.println("汪！汪！汪！");}}</code></pre><p>写个测试类来看看输出结果：</p><pre><code>public class Test{public static void main(String args[]){       Animal a = new Animal(); // Animal 对象    Dog d = new Dog();   // Dog 对象      Animal b = new Dog(); // Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解      a.bark();// 执行 Animal 类的方法     d.bark();//执行 Dog 类的方法      b.bark();//执行 Dog 类的方法   } }</code></pre><p>编译运行：</p><pre><code>$ javac Test.java Dog.java Animal.java$ java Test   动物叫！   汪！汪！汪！   汪！汪！汪！</code></pre><p><strong>多态</strong><br>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p><p><strong>向上转型</strong><br>要理解多态必须要明白什么是”向上转型”，比如，一段代码如下，Dog 类是 Animal 类的子类：</p><pre><code>Animal a = new Animal();  //a是父类的引用指向的是本类的对象Animal b = new Dog(); //b是父类的引用指向的是子类的对象</code></pre><p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 b 是可以指向 Dog 实例对象的。</p><p><code>注：不能使用一个子类的引用去指向父类的对象。</code></p><p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取。</p><p>新建一个Test.java，例如：</p><pre><code>class Animal {//父类方法public void bark() {    System.out.println("动物叫！");}}class Dog extends Animal {//子类重写父类的bark方法public void bark() {    System.out.println("汪、汪、汪！");}//子类自己的方法public void dogType() {    System.out.println("这是什么品种的狗？");}}public class Test {public static void main(String[] args) {    Animal a = new Animal();    Animal b = new Dog();    Dog d = new Dog();     a.bark();    b.bark();    //b.dogType();     //b.dogType()编译不通过    d.bark();    d.dogType();}}</code></pre><p>编译运行：</p><pre><code>$ javac Test.java$ java Test 动物叫！ 汪、汪、汪！ 汪、汪、汪！ 这是什么品种的狗？</code></pre><p>在这里，由于 b 是父类的引用，指向子类的对象，因此不能获取子类的方法（dogType()方法）,同时当调用 bark()方法时，由于子类重写了父类的 bark()方法,所以调用子类中的 bark()方法。</p><p><code>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写。（方法名，参数都相同）</code></p><p><strong>多态的实现条件</strong></p><p>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。</p><p>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p><strong>多态的实现方式</strong><br>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。</p><p><strong>抽象类</strong></p><p>在定义类时，前面加上abstract关键字修饰的类叫抽象类。 抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下：</p><pre><code>abstract void f();  //f()方法是抽象方法</code></pre><p>那我们什么时候会用到抽象类呢？</p><p>1 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类2 2 是约束子类必须要实现哪些方法，而并不关注方法如何去实现。<br>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。<br>所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节。</p><p>那抽象类如何用代码实现呢，它的规则如下：</p><pre><code>1 用 abstract 修饰符定义抽象类2 用 abstract 修饰符定义抽象方法，只用声明，不需要实现3 包含抽象方法的类就是抽象类4 抽象类中可以包含普通的方法，也可以没有抽象方法5 抽象类的对象不能直接创建，通常是定义引用变量指向子类对象。</code></pre><p>我们来写一写代码吧！</p><p>1、在home/project/目录下创建一个抽象类TelePhone.java。</p><p>2、填写需要子类实现的抽象方法。</p><pre><code> //抽象方法  public abstract class TelePhone {  public abstract void call();  //抽象方法,打电话  public abstract void message(); //抽象方法，发短信 }</code></pre><p>3、构建子类，并实现抽象方法。新建一个CellPhone.java。</p><pre><code>public class CellPhone extends TelePhone {@Overridepublic void call() {    System.out.println("我可以打电话！");}@Overridepublic void message() {    System.out.println("我可以发短信！");}public static void main(String[] args) {    CellPhone cp = new CellPhone();    cp.call();    cp.message();}</code></pre><p>}</p><p>在 CellPhone 类添加 main 方法测试运行结果：</p><p>编译运行：</p><pre><code>$ javac CellPhone.java TelePhone.java$ java CellPhone我可以打电话！我可以发短信！</code></pre><p><strong>接口</strong></p><p>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法。</p><p>接口的声明语法格式如下：</p><pre><code>修饰符 interface 接口名称 [extends 其他的接口名] {    // 声明变量    // 抽象方法}</code></pre><p>如声明一个 Animal 接口：</p><pre><code>// Animal.javainterface Animal {    //int x;    //编译错误,x需要初始化，因为是 static final 类型    int y = 5;    public void eat();    public void travel();}</code></pre><p>注意点：在Java8中</p><p>接口不能用于实例化对象<br>接口中方法只能是抽象方法、default 方法、静态方法<br>接口成员是 static final 类型<br>接口支持多继承<br>在Java9中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 default 方法和静态方法使用。</p><p>多继承实现方式：</p><pre><code>修饰符 interface A extends 接口1，接口2{}修饰符 class A implements 接口1，接口2{} </code></pre><p>实现上面的接口：</p><pre><code>// Cat.javapublic class Cat implements Animal{ public void eat(){     System.out.println("Cat eats"); } public void travel(){     System.out.println("Cat travels"); } public static void main(String[] args) {    Cat cat = new Cat();    cat.eat();    cat.travel();}}</code></pre><p>编译运行：</p><pre><code>$ javac Cat.java Animal.java$ java CatCat eatsCat travels</code></pre><p><strong>内部类</strong></p><p>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。</p><p>内部类的主要作用如下：</p><pre><code>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类内部类的方法可以直接访问外部类的所有数据，包括私有的数据内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便内部类允许继承多个非接口类型（具体将在以后的内容进行讲解）</code></pre><p>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 outer.class 和 outer$inner.class 两类。所以内部类的成员变量/方法名可以和外部类的相同。<br>我们通过代码来详细学习一下内部类吧！</p><pre><code> // People.java//外部类Peoplepublic class People {private String name = "LiLei";         //外部类的私有属性//内部类Studentpublic class Student {    String ID = "20151234";               //内部类的成员属性    //内部类的方法    public void stuInfo(){        System.out.println("访问外部类中的name：" + name);        System.out.println("访问内部类中的ID：" + ID);    }}//测试成员内部类public static void main(String[] args) {    People a = new People();     //创建外部类对象，对象名为a    Student b = a.new Student(); //使用外部类对象创建内部类对象，对象名为b    // 或者为 People.Student b = a.new Student();    b.stuInfo();   //调用内部对象的suInfo方法}}</code></pre><p>编译运行：</p><pre><code> $ javac People.java                                  $ java People 访问外部类中的name：LiLei 访问内部类中的ID：20151234</code></pre><p>成员内部类的使用方法：</p><pre><code>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）定义成员内部类后，必须使用外部类对象来创建内部类对象，即 内部类 对象名 = 外部类对象.new 内部类();如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字 如上述代码中：a.this</code></pre><p><code>注：成员内部类不能含有 static 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的。</code></p><p><strong>静态内部类</strong></p><p>静态内部类</p><pre><code> public class People { private String name = "LiLei";         //外部类的私有属性 /*外部类的静态变量。 Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。 */static String ID = "510xxx199X0724XXXX"; //静态内部类Studentpublic static class Student {    String ID = "20151234";               //内部类的成员属性    //内部类的方法    public void stuInfo(){        System.out.println("访问外部类中的name：" + (new People().name));        System.out.println("访问外部类中的ID：" + People.ID);        System.out.println("访问内部类中的ID：" + ID);    }}//测试成员内部类public static void main(String[] args) {    Student b = new Student();   //直接创建内部类对象，对象名为b    b.stuInfo();                 //调用内部对象的suInfo方法}}</code></pre><p>编译运行：</p><pre><code>$ javac People.java$ java People 访问外部类中的name：LiLei 访问外部类中的ID：510xxx199X0724XXXX 访问内部类中的ID：20151234</code></pre><p>静态内部类是 static 修饰的内部类，这种内部类的特点是：</p><pre><code>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();</code></pre><p><strong>局部内部类</strong></p><p>局部内部类，是指内部类定义在方法和作用域内。</p><p>例如：</p><pre><code>  // People.java  //外部类People  public class People {    //定义在外部类中的方法内：public void peopleInfo() {    final String sex = "man";  //外部类方法中的常量    class Student {        String ID = "20151234"; //内部类中的常量        public void print() {            System.out.println("访问外部类的方法中的常量sex：" + sex);            System.out.println("访问内部类中的变量ID:" + ID);        }    }    Student a = new Student();  //创建方法内部类的对象    a.print();//调用内部类的方法}//定义在外部类中的作用域内public void peopleInfo2(boolean b) {    if(b){        final String sex = "man";  //外部类方法中的常量        class Student {            String ID = "20151234"; //内部类中的常量            public void print() {                System.out.println("访问外部类的方法中的常量sex：" + sex);                System.out.println("访问内部类中的变量ID:" + ID);            }        }        Student a = new Student();  //创建方法内部类的对象        a.print();//调用内部类的方法    }}//测试方法内部类public static void main(String[] args) {    People b = new People(); //创建外部类的对象    System.out.println("定义在方法内：===========");    b.peopleInfo();  //调用外部类的方法    System.out.println("定义在作用域内：===========");    b.peopleInfo2(true);}}</code></pre><p>编译运行：</p><pre><code>$ javac People.java$ java People定义在方法内：===========访问外部类的方法中的常量sex：man访问内部类中的变量ID:20151234定义在作用域内：===========访问外部类的方法中的常量sex：man访问内部类中的变量ID:20151234</code></pre><p>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的。</p><p><strong>匿名内部类</strong></p><p>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。</p><p>例如：</p><pre><code>// Outer.javapublic class Outer { public Inner getInner(final String name, String city) {     return new Inner() {         private String nameStr = name;         public String getName() {             return nameStr;         }     };} public static void main(String[] args) {     Outer outer = new Outer();     Inner inner = outer.getInner("Inner", "NewYork");     System.out.println(inner.getName()); } } interface Inner { String getName(); }</code></pre><p>运行结果：Inner</p><p>匿名内部类是不能加访问修饰符的。要注意的是，new 匿名类，这个类是要先定义的,如果不先定义，编译时会报错该类找不到。</p><p>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为final。这里可以看到形参 name 已经定义为 final 了，而形参 city 没有被使用则不用定义为 final。</p><p>然而，因为匿名内部类没名字，是用默认的构造函数的，无参数的，如果需要该类有带参数的构造函数，示例如下：</p><pre><code> public Inner getInner(final String name, String city) {     return new Inner(name, city) {         private String nameStr = name;         public String getName() {             return nameStr;         }     }; } </code></pre><p>注意这里的形参 city，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造函数所使用，所以不必定义为 final。</p><p><strong>package</strong></p><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p><p>包的作用</p><ul><li><p>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p></li><li><p>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。</p></li><li><p>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。<br>定义包语法：</p><p>package 包名<br>//注意：必须放在源程序的第一行，包名可用”.”号隔开</p></li></ul><p>例如：</p><pre><code>//在定义文件夹的时候利用"/"来区分层次//包中用"."来分层package com.shiyanlou.java </code></pre><p>不仅是我们这样利用包名来区分类，系统也是这样做的。</p><p><img src="http://image.lichongbing.com/static/26876f2363a4ba22cc526175694c7e14.png" alt="wm-19.png"><br>如何在不同包中使用另一个包中的类？<br>使用import关键字。比如要导入包com.shiyanlou下People这个类，import com.shiyanlou.People。同时如果import com.shiyanlou.<em>这是将包下的所有文件都导入进来，</em>是通配符。</p><p>包的命名规范是全小写字母拼写。</p><p><strong>总结</strong><br>本节内容较多，不仅讲述面向对象的基础概念，而且针对面向对象所涉及的内容都尽可能地阐述了。主要包含以下知识点：</p><ul><li>类</li><li>对象</li><li>构造方法</li><li>引用与对象实例</li><li>static</li><li>final</li><li>封装</li><li>继承</li><li>方法重载与重写</li><li>多态</li><li>抽象类</li><li>接口</li><li>内部类<br>本节的示范例代码较多，请大家务必手动完成代码并运行对比结果。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2016/10/09/java-ji-chu-yu-fa/"/>
      <url>/2016/10/09/java-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>Java 概述及版本</strong></p><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 程序设计语言（以下简称 Java 语言）和 Java 平台的总称。Java 语言是一种面向对象的编程语言。虽然 Java 仅仅只产生了短短 20 年，但是它的发展是非常迅速的。在 2009 年 4 月 20 号，ORACLE 收购了 Sun 公司，也就是说 Java 这门语言现在归属于 ORACLE 这家公司门下。<br><img src="http://image.lichongbing.com/static/24e087e1b83a4b4ac205a21c54fc535a.jpeg" alt="wm.jpeg"><br>在 Java 这门语言体系当中，最基础的部分就是 Java SE 部分，Java 的标准版本。它包括 Java 最基础的一些结构，包括面向对象的一些特性等等，同时它也是 Java 技术基础和核心。在 Java SE 的基础之上，又分为了 Java EE（Java 的企业版），应用于大型企业级应用的开发。Java ME 主要用于嵌入式开发。初学的时候我们都是从 Java SE 开始的。<br><img src="http://image.lichongbing.com/static/22892b8f2d3e7b0ef0a05899bad594d7.png" alt="wm.png"><br>JVM 叫 Java 虚拟机，它也是整个 Java 技术的核心。Java 语言的跨平台就多亏了 JVM。</p><p>JDK 叫 Java 开发工具包，没有 JDK 就没有办法进行 Java 程序的开发。</p><p>JRE 叫 Java 运行环境，如果我们需要运行一个 Java 程序，就得安装 JRE。</p><p>JDK、JRE 和 JVM 之间的关系：</p><p><img src="http://image.lichongbing.com/static/045446ff4c0d5114dae9976d03e51b2a.png" alt="wm-2.png"></p><p><strong>学习方法</strong><br>推荐同学们在学习的同时可以边看文档边动手写代码，在遇到不懂得问题时可以查看实验楼其他课程或者查看官方文档解决。</p><p><strong>HelloWorld</strong></p><p>每门语言学习前，都会有一个 HelloWorld 的示例，Java 当然也不例外。<br>在/home/project/下新建一个文件<em>HelloWorld.java</em></p><pre><code>public class HelloWorld{public static void  main(String[] args){`   ` System.out.println("HelloWorld!");`    }}</code></pre><p>上面的例子虽然简单，但是包含了很多的知识点，Java 中所有的代码都必须包含在 class 中，main 方法是程序的入口，并且 Java 是区分大小写的，如果写成 Main，那么程序将不能运行。使用 public 修饰的 class 必须和源代码文件名相同。</p><p>编译源代码：打开命令行，切换到源代码目录这里是/home/project，输入javac HelloWorld.java，如果程序没有任何提示，并且在同级目录下生成了一个.class 扩展名的文件，那么说明编译成功，反之编译失败。<br>运行程序：输入java HelloWorld，这个时候不需要再添加扩展名了。</p><pre><code>$ javac HelloWorld.java$ java HelloWorld    HelloWorld!`</code></pre><p><strong>变量</strong></p><p>变量可以指在计算机存储器里存在值的被命名的存储空间。</p><p>变量通常是可被修改的，即可以用来表示可变的状态。这是 Java 的基本概念之一。</p><p>程序通过改变变量的值来改变整个程序的状态。为了方便使用变量，所以变量都需要命名，叫做变量名。</p><p>在 Java 中，变量需要先声明(declare)才能使用。在声明中，说明变量的类型，赋予变量以特别名字，以便在后面的程序中调用它。你可以在程序中的任意位置声明变量，语法格式如下：</p><p>数据类型 变量名称；</p><p>例如：</p><pre><code>int a = 1;</code></pre><p>在该语法格式中，数据类型可以是 Java 语言中任意的类型，如int。变量名称是该变量的标识符，需要符合标识符的命名规则，数据类型和变量名称之间使用空格进行间隔，使用;作为结束。</p><p>在/home/project/新建一个VarTest.java文件:</p><pre><code>public class VarTest{    public static void main(String[] args)    {        System.out.println("Define a variable a is ");        int a; //声明变量a        a = 5;        System.out.println(a);  // 打印一个整数a    }}</code></pre><p>编译运行</p><pre><code>$ javac VarTest.java$ java VarTestDefine a variable a is5</code></pre><p><strong>常量</strong></p><p>常量代表程序运行过程中不能改变的值。我们也可以把它们理解为特殊的变量，只是它们在程序的运行过程中是不允许改变的。常量的值是不能被修改的。</p><p>Java 中的final关键字可以用于声明属性（常量），方法和类。当final修饰属性时，代表该属性一旦被分配内存空间就必须初始化, 它的含义是“这是无法改变的”或者“终态的”。在变量前面添加关键字final即可声明一个常量。在 Java 编码规范中，要求常量名必须大写。</p><p>语法格式：</p><p>final 数据类型 常量名 = 值;<br>例如：</p><pre><code>final double PI = 3.14;</code></pre><p>常量也可以先声明，再进行赋值，但只能赋值一次，比如： ​<br>​ final int FINAL_VARIABLE; ​ FINAL_VARIABLE = 100;</p><p>在/home/project/下新建一个FinalVar.java</p><pre><code>public class FinalVar{public static void main(String[] args){    final String FINAL_STRING="shiyanlou";    System.out.println(FINAL_STRING);}}</code></pre><p>编译运行</p><pre><code>$ javac FinalVar.java$ java FinalVarshiyanlou</code></pre><p><strong>数据类型</strong><br>数据类型</p><p>Java 中一共八种基本数据类型，下表列出了基本数据类型的数据范围、存储格式、默认值、包装类型等。</p><pre><code>数据类型 默认值              存储格式                数据范围                                        包装类型short      0              2 个字节             -32,768 到 32767                                   Shortint        0              4 个字节            -2,147,483,648 到 2,147,483,647                     Integerbyte       0              1 个字节            -128 到 127                                         Bytechar       空              2 个字节    Unicode 的字符范围：’\u0000’（即为 0）到’\uffff’（即为 65,535） Characterlong       0L 或 0l        8 个字节    -9,223,372,036,854,775,808 到 9,223,372,036, 854,775,807   Longfloat      0.0F 或 0.0f    4 个字节           32 位 IEEEE-754 单精度范围                            Floatdouble     0.0 或 0.0D(d)  8 个字节           64 位 IEEE-754 双精度范围                             Doubleboolean    false           1 位                    true 或 false                                 Boolean</code></pre><p>整数</p><p>byte、short、int、long 四种基本数据类型表示整数，需要注意的是 long 类型，使用 long 修饰的变量需要在数值后面加上 L 或者 l，比如long num=1L;，一般使用大写 L，为了避免小写 l 与数值 1 混淆。</p><p>浮点数</p><p>float 和 double 类型表示浮点数，即可以表示小数部分。需要注意的是 float 类型的数值后面需要加上 F 或者 f，否则会被当成 double 类型处理。double 类型的数值可以加上 D 或 d，也可以不加。</p><p>char 类型</p><p>char 类型用于表示单个字符。需要将字符用单引号括起来char a=’a’，char 可以和整数互相转换，如果字符a也可以写成char a=97。也可以用十六进制表示char a = ‘\u0061’。</p><p>boolean 类型</p><p>boolean 类型（布尔类型）用于表示真值true或者假值false，Java 中布尔值不能和整数类型或者其它类型互相转换。</p><p><strong>String</strong></p><p>Java 中使用 String 类来定义一个字符串，字符串是常量，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。</p><p>String 对象的初始化格式有如下两种：</p><p>String s0 = “abc”;</p><p>String s1 = new String(“abd”);<br>copy<br>String 类具有丰富的方法，比如计算字符串的长度、连接字符串、比较字符串、提取字符串等等。</p><p>计算字符串长度</p><p>length()方法</p><p>//方法原型<br>public int length(){<br>}<br>copy<br>调用方法：字符串标识符.length();<br>返回一个 int 类型的整数（字符串中字符数，中文字符也是一个字符）。例如：</p><p>String s1 = “abc”;<br>String s2 = “Java语言”;<br>int len1 = s1.length();<br>int len2 = s2.length();<br>copy<br>则变量 len1 的值是 3，变量 len2 的值是 6。</p><p>字符串比较</p><p>equals() 方法,该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。</p><p>equals() 方法比较是从第一字符开始，一个字符一个字符依次比较。</p><p><img src="http://image.lichongbing.com/static/11088919cc152bb4ed2446e8b9b1d9eb.png" alt="wm-3.png"></p><p>如果想忽略掉大小写关系，比如：java 和 Java 是一样的，那怎么办呢？可以调用equalsIgnoreCase()方法，其用法与 equals 一致，不过它会忽视大小写。</p><p>比如：</p><pre><code>public class StringTest {public static void main(String[] args){    String s = new String("Java");    String m = "java";    System.out.println("用equals()比较，java和Java结果为"+s.equals(m));    System.out.println("用equalsIgnoreCase()比较，java和Java结果为"+s.equalsIgnoreCase(m));}}</code></pre><p>编译运行：</p><pre><code>$ javac StringTest.java$ java StringTest</code></pre><p>用equals()比较，java和Java结果为false<br>用equalsIgnoreCase()比较，java和Java结果为true<br>copy<br>而使用”==”比较的是两个对象在内存中存储的地址是否一样。例如:</p><pre><code> String s1 = "abc"; String s2 = new String("abc"); boolean b = (s1 == s2);</code></pre><p>则变量 b 的值是 false，因为 s1 对象对应的地址是”abc”的地址，而 s2 使用 new 关键字申请新的内存，所以内存地址和 s1 的”abc”的地址不一样，所以获得的值是 false。</p><p>字符串连接</p><p>字符串连接有两种方法：</p><p>使用+，比如String s = “Hello “ + “World!”<br>使用 String 类的 concat() 方法<br>代码示例：</p><pre><code>String s0 = new String("Hello ");String s1 = "World" + "!";   //+号连接String s2 = s0.concat(s1); //concat()方法连接System.out.println(s2);</code></pre><p>而且使用+进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。</p><p>charAt()方法</p><p>charAt()方法的作用是按照索引值(规定字符串中第一个字符的索引值是 0，第二个字符的索引值是 1，依次类推)，获得字符串中的指定字符。例如：</p><pre><code> String s = "abc"; char c = s.charAt(1);</code></pre><p>则变量 c 的值是’b’。</p><p>字符串常用提取方法</p><pre><code>方法                                      返回值       功能描述indexOf(int ch)                            int       搜索字符 ch 第一次出现的索引indexOf(String value)                      int       搜索字符串 value 第一次出现的索引lastIndexOf(int ch)                        int       搜索字符 ch 最后一次出现的索引lastIndexOf(String value)                  int       搜索字符串 value 最后一次出现的索引substring(int index)                       String    提取从位置索引开始到结束的字符串substring(int beginindex, int endindex)    String    提取 beginindex 和 endindex 之间的字符串部分trim()                                     String    返回一个前后不含任何空格的调用字符串的副本</code></pre><p>说明：在字符串中，第一个字符的索引为 0，子字符串包含 beginindex 的字符，但不包含 endindex 的字符。</p><p>来写一些代码，验证一下上面的方法吧</p><pre><code>public class StringTest {     public static void main(String[] args) {        String s = "abcdefabc";        System.out.println("字符a第一次出现的位置为"+s.indexOf('a'));        System.out.println("字符串bc第一次出现的位置为"+s.indexOf("bc"));        System.out.println("字符a最后一次出现的位置为"+s.lastIndexOf('a'));        System.out.println("从位置3开始到结束的字符串"+s.substring(3));        System.out.println("从位置3开始到6之间的字符串"+s.substring(3,6));     }}</code></pre><p>编译运行：</p><pre><code>$ javac StringTest.java$ java StringTest字符a第一次出现的位置为0字符串bc第一次出现的位置为1字符a最后一次出现的位置为6从位置3开始到结束的字符串defabc从位置3开始到6之间的字符串def</code></pre><p><strong>运算符</strong><br>运算符顾名思义是一种符号，它是连接一个以上的操作符，实现某种功能的运算。</p><p><strong>算术运算符</strong></p><p>算术运算符用在数学表达式中，主要实现的是算术运算，如常见的加法、减法、乘法、除法等。</p><p>表格中的例子中，变量a的值为 5，变量b的值为 3，变量i的值为 1：</p><pre><code>算术运算符    名称    描述    类型    举例+    加法    相加运算符两侧的值    双目运算符    a + b 等于 8-    减法    左操作数减去右操作数    双目运算符    a - b 等于 2*    乘法    相乘操作符两侧的值    双目运算符    a * b 等于 15/    除法    左操作数除以右操作数    双目运算符    a / b 等于 1%    取余    左操作数除右操作数的余数    双目运算符    a % b 等于 2++    自增    操作数的值增加 1    单目运算符    ++i（或 i++） 等于 2--    自减    操作数的值减少 1    单目运算符    --i（或 i--） 等于 0</code></pre><p>其中，自增(++)和自减(–)运算符有两种写法：前缀（++i,–i）和后缀（i++,i–）。</p><p>前缀自增自减法(++i,–i): 先进行自增或者自减运算，再进行表达式运算。<br>后缀自增自减法(i++,i–): 先进行表达式运算，再进行自增或者自减运算<br>新建一个源代码文件ArithmeticOperation.java。</p><pre><code>public class ArithmeticOperation {    public static void main(String args[]) {       int a = 5;       int b = 3;    i  nt c = 3;       int d = 3;       System.out.println("a + b = " + (a + b));       System.out.println("a - b = " + (a - b));       System.out.println("a * b = " + (a * b));       System.out.println("a / b = " + (a / b));       System.out.println("a % b = " + (a % b));       System.out.println("a++ = " + (a++));       System.out.println("++a = " + (++a));       System.out.println("b-- = " + (b--));       System.out.println("--b = " + (--b));       System.out.println("c++ = " + (c++));       System.out.println("++d = " + (++d));   }}</code></pre><p>编译运行：</p><pre><code>$ javac ArithmeticOperation.java$ java ArithmeticOperationa + b = 8a - b = 2a * b = 15a / b = 1a % b = 2a++ = 5++a = 7b-- = 3--b = 1c++ = 3++d = 4</code></pre><p><strong>位运算符</strong><br>Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算时先转换为二进制，再按位运算。</p><p>表格中的例子中，变量a的值为 60，变量b的值为 13：</p><pre><code>位运算符    名称    描述    举例&amp;    按位与    如果相对应位都是 1，则结果为 1，否则为 0    （a＆b），得到 12，即 0000 1100丨    按位或    如果相对应位都是 0，则结果为 0，否则为 1    （ a 丨 b ）得到 61，即 0011 1101^    按位异或    如果相对应位值相同，则结果为 0，否则为 1    （a^b）得到 49，即 0011 0001~    按位补    翻转操作数的每一位，即 0 变成 1，1 变成 0    （〜a）得到-61，即 1100 0011&lt;&lt;    按位左移    左操作数按位左移右操作数指定的位数    a&lt;&lt;2 得到 240，即 1111 0000&gt;&gt;    按位右移    左操作数按位右移右操作数指定的位数    a&gt;&gt;2 得到 15 即 1111&gt;&gt;&gt;    按位右移补零    左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充    a&gt;&gt;&gt;2 得到 15 即 0000 1111</code></pre><p>在/home/project目录下新建一个源代码文件BitOperation.java</p><pre><code>public class BitOperation {    public static void main(String args[]) {         int a = 60;         int b = 13;         System.out.println("a &amp; b = " + (a &amp; b));         System.out.println("a | b = " + (a | b));         System.out.println("a ^ b = " + (a ^ b));         System.out.println("~a = " + (~a));         System.out.println("a &lt;&lt; 2 = " + (a &lt;&lt; 2));         System.out.println("a &gt;&gt; 2 = " + (a &gt;&gt; 2));         System.out.println("a &gt;&gt;&gt; 2 = " + (a &gt;&gt;&gt; 2));    } }</code></pre><p>编译运行：</p><pre><code>$ javac BitOperation.java$ java BitOperationa &amp; b = 12a | b = 61a ^ b = 49~a = -61a &lt;&lt; 2 = 240a &gt;&gt; 2 = 15a &gt;&gt;&gt; 2 = 15</code></pre><p><strong>逻辑运算符</strong></p><p>逻辑运算符是通过运算符将操作数或等式进行逻辑判断的语句。</p><p>表格中的例子中，假设布尔变量 a 为真，变量 b 为假：</p><pre><code>逻辑运算符    名称    描述                                                      类型    举例&amp;&amp;           与    当且仅当两个操作数都为真，条件才为真                           双目运算符    （a &amp;&amp; b）为假｜｜          或    两个操作数任何一个为真，条件为真                              双目运算符    （a ｜｜ b）为真！           非    用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假      单目运算符    （!a）为假^           异或    如果两个操作数逻辑相同，则结果为假，否则为真                    双目运算符    （a ^ b）为真</code></pre><p>当使用&amp;&amp;(与)逻辑运算符时，在两个操作数都为 true 时，结果才为 true，但是当得到第一个操作为 false 时，其结果就必定是 false，这时候就不会再判断第二个操作了。 在/home/project目录下新建一个LogicOperation.java。</p><pre><code>public class LogicOperation {   public static void main(String args[]) {    boolean a = true;    boolean b = false;    System.out.println("a &amp;&amp; b = " + (a &amp;&amp; b));    System.out.println("a || b = " + (a || b));    System.out.println("!a = " + (!a));    System.out.println("a ^ b = " + (a ^ b));  }}</code></pre><p>编译运行：</p><pre><code>$ javac LogicOperation.java$ java LogicOperationa &amp;&amp; b = falsea || b = true!a = falsea ^ b = true</code></pre><p><strong>关系运算符</strong></p><p>关系运算符生成的是一个 boolean（布尔）结果，它们计算的是操作数的值之间的关系。如果关系是真实的，结果为 true（真），否则，结果为 false（假）。</p><p>表格中的例子中，假设变量 a 为 3，变量 b 为 5：</p><pre><code>比较运算符     名称                             描述                                  举例==           等于        判断两个操作数的值是否相等，如果相等则条件为真                 （a == b）为 false！=          不等于       判断两个操作数的值是否相等，如果值不相等则条件为真             (a != b) 为 true&gt;            大于        判断左操作数的值是否大于右操作数的值，如果是那么条件为真        （a &gt; b）为 false&lt;            小于        判断左操作数的值是否小于右操作数的值，如果是那么条件为真        （ a &lt; b）为 true&gt;=           大于等于     判断左操作数的值是否大于或等于右操作数的值，如果是那么条件为真    （a &gt;= b）为 false&lt;=           小于等于     判断左操作数的值是否小于或等于右操作数的值，如果是那么条件为真    （a &lt;= b）为 true</code></pre><p>除了上表列出的二元运算符，Java 还有唯一的一个三目运算符 ?: 。</p><p>语法格式： 布尔表达式？表达式 1 : 表达式 2</p><p>运算过程：如果布尔表达式的值为true ，则返回 表达式1 的值，否则返回 表达式2 的值。</p><p>在/home/project目录下新建一个源代码文件RelationalOperation.java。</p><pre><code>public class RelationalOperation {   public static void main(String args[]) {    int a = 3;    int b = 5;    System.out.println("a == b = " + (a == b));    System.out.println("a != b = " + (a != b));    System.out.println("a &gt; b = " + (a &gt; b));    System.out.println("a &lt; b = " + (a &lt; b));    System.out.println("a &gt;= b = " + (a &gt;= b));    System.out.println("a &lt;= b = " + (a &lt;= b));    System.out.println("a &gt; b ? a : b = " + (a &gt; b ? a : b));   }}</code></pre><p>编译运行：</p><pre><code>$ javac RelationalOperation.java$ java RelationalOperationa == b = falsea != b = truea &gt; b = falsea &lt; b = truea &gt;= b = falsea &lt;= b = truea &gt; b ? a : b = 5</code></pre><p>强调：</p><p>==和!=适用于所有的基本数据类型，其他关系运算符不适用于boolean，因为 boolean 值只有true和false，比较没有任何意义。<br>==和!=也适用于所有对象，可以比较对象的引用是否相同。<br>引用：Java 中一切都是对象，但操作的标识符实际是对象的一个引用。<br><strong>运算符优先级</strong><br>运算符的优先级是帮助我们在一个表达式中如何对于不同的运算符和相同的运算符，进行正确的运算顺序。</p><p>运算符的优先级不需要特别地去记忆它，比较复杂的表达式一般使用圆括号()分开，提高可读性。</p><p><img src="http://image.lichongbing.com/static/48fc9ba2d85e74d2b35805ead21c7499.png" alt="wm-4.png"><br><img src="http://image.lichongbing.com/static/6d7020feda8f66aa56c54c7bd6276609.png" alt="wm-5.png"><br><strong>练习：计算数字和</strong><br>在/home/project/目录下新建文件Sum.java，你需要实现以下需求：</p><ul><li> 获取控制台输入的两个整型参数</li><li>输出两个整型参数和<br> 比如输入 3 和 4 对应输出 7</li></ul><p>示例：</p><pre><code>输入：    3    4输出：    7</code></pre><p>提示：java.util.Scanner可以获取控制台输入。</p><pre><code>Scanner in =new Scanner(System.in);//获取int值int x1=in.nextInt();int x2=in.nextInt();</code></pre><p><strong>参考答案</strong></p><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Scanner;   public class Sum {   public static void main(String[] args) {       Scanner in = new Scanner(System.in);       int a = in.nextInt();       int b = in.nextInt();       System.out.println(a + b);   }   }</code></pre><p><strong>关键字和语句</strong></p><p>Java 的关键字对 java 的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名。</p><p>Java 关键字有如下表所列，目前共有 50 个 Java 关键字，其中，”const”和”goto”这两个关键字在 Java 语言中并没有具体含义。</p><p><img src="http://image.lichongbing.com/static/af57bbfecb1eb4f096d07b500148f7ab.png" alt="wm-6.png"></p><p><strong>方法</strong><br>Java 中的方法，可以将其看成一个功能的集合，它们是为了解决特定问题的代码组合。</p><p>方法的定义语法：</p><pre><code>  访问修饰符 返回值类型 方法名(参数列表){        方法体   }</code></pre><p>比如：</p><pre><code> public void functionName(Object arg){}</code></pre><p>在上面的语法说明中：</p><p>1.访问修饰符：代表方法允许被访问的权限范围， 可以是 public、protected、private 或者省略（default） ，其中 public 表示该方法可以被其他任何代码调用。</p><p>2.返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void (代表无类型)；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。</p><p>3.方法名：是方法的名字，必须使用合法的标识符。</p><p>4.参数列表：是传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p><p>5.方法体：方法体包含具体的语句，定义该方法的功能。<br>根据方法是否带参、是否带返回值，可将方法分为四类：</p><ul><li>无参无返回值方法</li><li>无参带返回值方法</li><li>带参无返回值方法</li><li>带参带返回值方法<br>当方法定义好之后，需要调用才可以生效，我们可以通过 main 方法（main 方法是 Java 程序的入口，所以需要用它来调用）来调用它，比如：</li></ul><p>在/home/project下建立MethodDemo.java</p><pre><code>  public class MethodDemo{   public static void main(String[] args){    method();   }    //这里要加上static关键字 应为静态方法只能调用静态方法   public static void method(){    System.out.println("方法被调用");      } }</code></pre><p>编译运行：</p><pre><code>  javac MethodDemo.java  java MethodDemo  方法被调用</code></pre><p><strong>练习题：方法使用</strong></p><p>在/home/project/目录下新建文件MethodTest.java，在其中新建一个方法methodDemo，运行该方法，在控制台输出Hello Shiyanlou。<br><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>    public class MethodTest {          private static void methodDemo() {              System.out.println("Hello Shiyanlou");          }          public static void main(String[] args) {         methodDemo();    }   }</code></pre><p><strong>IDE</strong><br>Java 常见的 IDE 有 IDEA，Eclipse 等，同学们可以任选一种安装在本地学习，在实验楼环境中并不会使用这两种 IDE，而是使用 WEB IDE 进行开发，同学们需要将这两种 IDE 之一装在本地进行学习。</p><p><strong>流程控制</strong></p><p>流程控制对任何一门编程语言都是至关重要的，它为我们提供了控制程序步骤的基本手段。常见对主要分为，条件语句、循环语句、跳转语句。</p><p><strong>if 语句</strong><br>if 语句是一种判断语句。</p><p>语法：</p><pre><code>if(条件){条件成立时执行的代码}</code></pre><p><img src="http://image.lichongbing.com/static/60a62d740f72fdf04f35dd06c82d8db2.png" alt="wm-7.png"><br>if…else 语句当条件成立时，则执行 if 部分的代码块； 条件不成立时，则进入 else 部分。例如，如果一个月天数大于 30 天，则为大月，否则为小月。</p><p>语法：</p><pre><code> if(条件){ 代码块1 } else{ 代码块2 }</code></pre><p><img src="http://image.lichongbing.com/static/fd684b1ac10dddf0aad77cf4b2372bcb.png" alt="wm-8.png"><br>多重 if 语句，在条件 1 不满足的情况下，才会进行条件 2 的判断，以此向下；当前面的条件均不成立时，最终执行 else 块内的代码。</p><p>语法：</p><pre><code>  if(条件1){ 代码块1 } else if(条件2){ 代码块2 } ... else { 代码块n}</code></pre><p><img src="http://image.lichongbing.com/static/c7074ea6610aa7ed470f0fb89125be9d.png" alt="wm-9.png"><br>注意：如果 if(或 else if，或 else)条件成立时的执行语句只有一条，是可以省略大括号的！但如果执行语句有多条，那么大括号就是不可或缺的。</p><p>比如：</p><pre><code>  int days = 31;  if(days &gt; 30)  System.out.println("本月是大月");  else  System.out.println("本月是小月");</code></pre><p>if 语句是可以在内层进行嵌套的。嵌套 if 语句，只有当外层 if 的条件成立时，才会判断内层 if 的条件。</p><p>语法：</p><pre><code>   if(条件1){  if(条件2){    代码块1   }  else{    代码块2  }  }  else{  代码块3 }</code></pre><p><img src="http://image.lichongbing.com/static/5e1871dfccfd8c06d54ec2e1286c4984.png" alt="wm-10.png"><br>f 语句练习：小明考了 78 分，60 分以上及格，80 分以上为良好，90 分以上为优秀，60 分以下要重考，编写源代码ScoreJudge.java，输出小明的情况。<br>参考代码如下：</p><pre><code>  public class ScoreJudge {  public static void main(String[] args){    int score = 78;    if(score &gt;= 60){        if(score &gt;= 80){            if(score &gt;= 90){                System.out.println("成绩优秀");            }            else{                System.out.println("成绩良好");            }        }        else{            System.out.println("成绩及格");        }    }    else{        System.out.println("需要补考");    } }}</code></pre><p>注：所有的条件语句都是利用条件表达式的真或假来决定执行路径，Java 里不允许将一个数字作为布尔值使用，虽然这在C和C++是允许的，如果要在布尔测试里使用一个非布尔值，需要先用一个条件表达式将其转换成布尔值，其他控制语句同理。<br>编译执行:</p><pre><code>$ javac ScoreJudge.java$ Java ScoreJude成绩及格</code></pre><p><strong>switch 语句</strong></p><p>当需要对选项进行等值判断时，使用 switch 语句更加简洁明了。比如：摇号摇到 1 的得一等奖，摇到 2 的得二等奖，摇到 3 的等三等奖，摇到其他的没有奖。</p><p>语法：</p><pre><code>switch(表达式){case 值1:    代码块1    break;case 值2:    代码块2    break;...default:    默认执行的代码块}</code></pre><p>当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。</p><p>新建一个源代码文件Draw.java。</p><pre><code> public class Draw {  public static void main(String[] args){    int num = 2;    switch(num){    case 1:        System.out.println("恭喜你，获得了一等奖");        break;    case 2:        System.out.println("恭喜你，获得了二等奖");        break;    case 3:        System.out.println("恭喜你，获得了三等奖");        break;    default:        System.out.println("很遗憾，下次再来");    }}}</code></pre><p>编译运行：</p><pre><code>$ javac Draw.java$ java Draw恭喜你，获得了二等奖</code></pre><p><strong>while 和 do-while 语句</strong><br>while语法：</p><pre><code>while(条件){代码块}</code></pre><p>while 的执行过程是先判断，再执行。</p><ul><li><p>判断 while 后面的条件是否成立( true or false )</p></li><li><p>当条件成立时，执行循环内的代码，然后重复执行1.、2.， 直到循环条件不成立为止<br><img src="http://image.lichongbing.com/static/13b4d199185c3d976c318367a3fde38b.png" alt="wm-11.png"><br>do-while语法：</p><pre><code> do{   代码块   }while(条件);</code></pre></li></ul><p><img src="http://image.lichongbing.com/static/2f7b2137c8db4d96cc4fc492c40fefd2.png" alt="wm-12.png"><br>如：</p><pre><code>int i = 0;while(i &lt; 100){System.out.println("I love ShiYanlou!");i++;}int i = 0;do {System.out.println("I love ShiYanlou!");i++;} while(i &lt; 100);</code></pre><p>练习：分别用 while 和 do-while 两种方法，编写源代码文件SumOfEven.java，实现 1-1000 中所有偶数的和，并输出。验证一下两种方法你输出的结果是一致吗？</p><p>参考代码如下：</p><pre><code>public class SumOfEven {public static void main(String[] args){    int i1 = 1, i2 = 1;    int sum1 = 0, sum2 = 0;    while (i1 &lt;= 1000){     //循环1000次        if(0 == i1 % 2){   //判断是否为偶数            sum1 += i1;    //将偶数加入到总数里        }        i1++;              //i自增1    }    System.out.println("用while，1到1000中，所有偶数的和为："+sum1);    do {        if (0 == i2 % 2){   //在条件语句中，将数值写在前面是为了防止将==写成了=            sum2 += i2;        }        i2++;    } while(i2 &lt;= 1000);    System.out.println("用do-while，1到1000中，所有偶数的和为："+sum2);}}</code></pre><p>编译运行：</p><pre><code>$ javac SumOfEven.java$ java SumOfEven用while，1到1000中，所有偶数的和为：250500用do-while，1到1000中，所有偶数的和为：250500</code></pre><p><strong>for 语句</strong><br>for语法：</p><pre><code>for(循环变量初始化; 循环条件; 循环变量变化){   循环操作}</code></pre><p>for 相比 while 和 do-while 语句结构更加简洁易读，它的执行顺序：</p><ul><li><p>执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次</p></li><li><p>进行循环条件的判断，如果条件为 true，则执行循环体内代码；如果为 false ，则直接退出循环</p></li><li><p>执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断</p></li><li><p>依次重新执行2.、3.、4.，直到退出循环<br><img src="http://image.lichongbing.com/static/13b4d199185c3d976c318367a3fde38b.png" alt="wm-13.png"><br>例如，计算 100 以内不能被 3 整除的数之和：</p><p>int sum = 0; // 保存不能被3整除的数之和<br>// 循环变量 i 初始值为 1 ,每执行一次对变量加 1，只要小于等于 100 就重复执行循环<br>for (int i = 1;i&lt;=100;i++) {<br>// 变量 i 与 3 进行求模（取余），如果不等于 0 ，则表示不能被 3 整除<br>if (i % 3 != 0) {<br>sum = sum + i; // 累加求和<br>}<br>}<br>System.out.println(“1到100之间不能被3整除的数之和为：” + sum);</p></li></ul><p>练习：编写源代码文件SumOfEven.java，实现 1-1000 中所有偶数的和，并输出。</p><p>参考代码如下：</p><pre><code>public class SumOfEven {public static void main(String[] args){    int sum = 0;    for(int i = 1; i &lt;= 1000; i++){        if(0 == i % 2){            sum += i;        }    }    System.out.println("用for，1到1000中，所有偶数和为："+sum);}}</code></pre><p>编译运行：</p><pre><code>$ javac SumOfEven.java$ java SumOfEven用for，1到1000中，所有偶数和为：250500</code></pre><p><strong>练习题：字符串处理</strong></p><p>在/home/project/目录下新建StringUtil.java，你需要实现以下需求：</p><ul><li><p>从控制台输入一行字符串</p></li><li><p>去除字符串中的所有空格</p></li><li><p>打印去除空格后的字符串<br>示例：</p><pre><code>输入：  shi ya n  lou输出：  shiyanlou</code></pre></li></ul><p>提示：java.util.Scanner可以获取控制台输入。</p><pre><code>Scanner in =new Scanner(System.in);//获取String值String a=in.nextLine();</code></pre><p><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Scanner;public class StringUtil {     public static void main(String[] args) {    Scanner in =new Scanner(System.in);    //获取String值    String a=in.nextLine();    StringBuilder stringBuilder = new StringBuilder(a);    for (int i = 0; i &lt; stringBuilder.length(); i++) {        if (stringBuilder.charAt(i)==' ') {            System.out.println(i);            stringBuilder.deleteCharAt(i);            i--;        }else {            stringBuilder.charAt(i);        }    }    System.out.println(stringBuilder.toString());    }}</code></pre><p><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Scanner;public class ContrastString {public static void main(String[] args) {    Scanner in = new Scanner(System.in);    //获取String值    String a = in.nextLine();    String b = in.nextLine();    if (a.length() != b.length()) {        System.out.println("不同");        return;    }    for (int i = 0; i &lt; a.length(); i++) {        if (a.charAt(i) != b.charAt(i)) {            System.out.println("不同");            return;        }    }    System.out.println("相同");}}</code></pre><p><strong>跳转语句</strong></p><p>break关键字经常用在条件和循环语句中，用来跳出循环语句。</p><p>continue关键字的作用是跳过循环体中剩余的语句执行下一次循环。 新建一个源代码文件Jump.java。</p><pre><code>public class Jump{public static void main(String[] args){    //break 练习    for(int i = 1; i &lt;= 10; i++){        System.out.println("循环第"+i+"次");        if(0 == i % 3){            break;        }        if(0 == i % 5){            System.out.println("我进来了！");        }    }    //continue练习 打印10以内的所有奇数    for(int i = 1; i &lt;= 10; i++){        if(0 == i % 2) //判断i是否为偶数            continue;  //通过continue结束本次循环        System.out.println(i);    }}}</code></pre><p>编译运行：</p><pre><code>$ javac Jump.java$ java Jump 循环第1次循环第2次循环第3次13579</code></pre><p><strong>练习题：打印星期</strong><br>在/home/project/目录下新建一个源代码文件PrintWeek.java。</p><p>你需要在实现以下需求：</p><ul><li>从控制台获取一个整型参数</li><li>当输入数字 1 时输出今天是星期一</li><li>当输入数字 2 时输出今天是星期二</li><li>……</li><li>当输入数字 7 时输出今天是星期天</li></ul><p>示例：</p><pre><code>输入：1输出：今天是星期一</code></pre><p>提示：java.util.Scanner可以获取控制台输入。</p><pre><code>Scanner in =new Scanner(System.in);//获取int值int x=in.nextInt();</code></pre><p><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code> import java.util.Scanner; public class PrintWeek { public static void main(String[] args) {    Scanner in = new Scanner(System.in);    //获取int值    int x = in.nextInt();    switch (x) {        case 1:            System.out.println("今天是星期一");            break;        case 2:            System.out.println("今天是星期二");            break;        case 3:            System.out.println("今天是星期三");            break;        case 4:            System.out.println("今天是星期四");            break;        case 5:            System.out.println("今天是星期五");            break;        case 6:            System.out.println("今天是星期六");            break;        case 7:            System.out.println("今天是星期天");            break;    } }}</code></pre><p><strong>数组</strong><br>所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便，把具有相同类型的若干元素按无序的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称为数组。数组是用于储存多个相同类型数据的集合。–来自百度百科<br><strong>数组</strong><br>数组就是相同数据类型的元素按一定顺序排列的集合。可以把它看成一个大的盒子，里面按顺序存放了多个数据类型相同的数据。<br><img src="http://image.lichongbing.com/static/4631e9ce8c8c88d3c2181dff61654432.png" alt="wm-14.png"><br>数组中的元素都可以通过下标来访问，下标从 0 开始，到数组长度-1 结束。例如，可以通过 ages[0] 获取数组中的第一个元素 18 ，ages[3] 就可以取到第四个元素 10。</p><p>使用数组前要声明数组。</p><p>语法：</p><pre><code>数据类型[ ] 数组名;   //或者: 数据类型 数组名[ ];</code></pre><p>数组名为任意合法的变量名，如：</p><pre><code>int ages[];      //存放年龄的数组，类型为整型char symbol[];   //存放符号的数组，类型为字符型String [] name;  //存放名称的数组，类型为字符串型</code></pre><p>声明数组后，需要为数组分配空间，也就是定义多大的数组。</p><p>语法：</p><pre><code>数组名 = new  数据类型 [ 数组长度 ];</code></pre><p>数组长度就是数组最多可存放元素的个数。可以在数组声明的时候初始化数组，或者在声明时就为它分配好空间，这样就不用再为数组分配空间。</p><p>语法：</p><pre><code>int [] ages = {12,18,9,33,45,60}; //声明并初始化了一个整型数组，它有6个元素char [] symbol = new char[10] //声明并分配了一个长度为10的char型数组</code></pre><p>分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的。 如：</p><pre><code>ages[0]=12;</code></pre><p>Java 中可以将一个数组赋值给另一个数组，如：</p><pre><code>int [] a1 = {1,2,3};int [] a2;a2 = a1;</code></pre><p>这里只是复制了一个引用，即 a2 和 a1 是相同数组的不同名称。</p><p>在/home/project/下新建一个Test.java测试一下。</p><pre><code>public class Test {public static void main(String[] args) {    int [] a1 = {1,2,3};    int [] a2;    a2 = a1;    for(int i = 0; i &lt; a2.length; i++){        a2[i]++;    }    for(int i = 0; i &lt; a1.length; i++){        System.out.println(a1[i]);    }}}</code></pre><p>编译输出：</p><pre><code>$ javac Test.java$ java Test234</code></pre><p>可以看到，修改 a2 的值，a1 的值也跟着变化。</p><p>数组遍历：</p><pre><code>int [] ages = {12, 18, 9, 33, 45, 60};for(int i = 0; i &lt; ages.length; i++){ //ages.length是获取数组的长度System.out.println("数组中第"+(i+1)+"个元素是 "+ages[i]); //数组下标是从零开始，一定要注意}</code></pre><p>注意：</p><p>数组下标从 0 开始。所以数组的下标范围是 0 至 数组长度 -1。<br>数组不能越界访问，否则会报错。<br>for 语句在数组内可以使用特殊简化版本，在遍历数组、集合时，foreach 更简单便捷。从英文字面意思理解 foreach 也就是“ for 每一个”的意思。</p><p>语法：</p><p>for(元素类型 元素变量:遍历对象){<br>执行的代码<br>}</p><p>在/home/project/下新建JudgePrime.java</p><pre><code>public class JudgePrime {public static void main(String[] args){    int [] ages = {12, 18, 9, 33, 45, 60};    int i = 1;    for(int age:ages){        System.out.println("数组中第"+i+"个元素是"+age);        i++;    }}}</code></pre><p>编译运行：</p><pre><code>$ javac JudgePrime.java$ java JudgePrime数组中第1个元素是12数组中第2个元素是18数组中第3个元素是9数组中第4个元素是33数组中第5个元素是45数组中第6个元素是60</code></pre><p><strong>二维数组</strong></p><p>二维数组可以看成是一间有座位的教室，座位一般用第几排的第几个进行定位，每一个座位都有一个行和一个列的属性，一排的座位相当于一个一维数组，所以可以将二维数组简单的理解为是一种“特殊”的一维数组，它的每个数组空间中保存的是一个一维数组。</p><p>二维数组也需要声明和分配空间。</p><p>语法：</p><pre><code>数据类型 [][] 数组名 = new 数据类型[行的个数][列的个数];</code></pre><p>//或者</p><pre><code> 数据类型 [][] 数组名; 数组名 = new 数据类型[行的个数][列的个数];</code></pre><p>//也可以</p><pre><code>  数据类型 [][] 数组名 = { {第一行值1,第一行值2,...} {第二行值1,第二行值2,...} ... }</code></pre><p>//二维数组的赋值和访问，跟一维数组类似，可以通过下标来逐个赋值和访问，注意索引从 0 开始</p><pre><code>数组名[行的索引][列的索引] = 值;</code></pre><p>在/home/project/下新建ArrayTest.java</p><pre><code>public class ArrayTest {public static void main(String[] args) {    String[][] name = {{"ZhaoYi", "QianEr", "SunSan"},                {"LiSi", "ZhouWu", "WuLiu"}};    for (int i = 0; i &lt; 2; i++) {        for (int j = 0; j &lt; 3; j++) {            System.out.println(name[i][j]);        }    }}}</code></pre><p>编译运行：</p><pre><code>$ javac ArrayTest.java$ java ArrayTest ZhaoYi QianEr SunSan LiSi ZhouWu WuLiu copy</code></pre><p><strong>练习题：数组应用</strong></p><p>有一份成绩单，上面有 10 位学生的成绩（61，57，95，85，75，65，44，66，90，32），请求出平均成绩并输出。</p><p>在/home/project/目录下新建文件AverageScore.java，并在其中编写正确的代码。</p><p>提示：</p><ul><li>将 10 位同学的成绩保存在数组中</li></ul><p><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>public class AverageScore {public static void main(String[] args) {    int[] data = {61, 57, 95, 85, 75, 65, 44, 66, 90, 32};    int sum = 0;    for (int i = 0; i &lt; data.length; i++) {        sum += data[i];    }    System.out.println("平均成绩：" + sum / data.length);}}</code></pre><p><strong>用户输入操作</strong><br>Java 可以使用java.util包下的Scanner类来获取用户的输入。使用import java.util.Scanner;即可导入 Scanner，使用方法示例：</p><p>在/home/project目录下新建ScannerDemo.java类</p><pre><code>import java.util.Scanner;public class ScannerDemo {public static void main(String[] args) {    Scanner in=new Scanner(System.in);    //获取用户输入的一行数据  返回为字符串    String s = in.nextLine();    System.out.println(s);    //返回用户输入的int值    int i = in.nextInt();    System.out.println(i);    //循环读取String数据，当输入exit时退出循环    while (!in.hasNext("exit")) {        System.out.println(in.nextLine());    }    //关闭输入    in.close();  } }</code></pre><p>编译运行：</p><pre><code>javac ScannerDemo.javajava ScannerDemo</code></pre><p>运行结果示例：</p><pre><code>shiyanloushiyanlouaaaabbbbbbccccexit</code></pre><p>除去以上列举的方法，其他方法可以在 api 中查询<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html">https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html</a><br><strong>练习题：用户输入</strong><br>在/home/project/目录下新建文件InputTest.java，你需要完成以下需求：</p><p>获取用户的输入信息（字符串）<br>当用户输入 end 时，结束输入并打印用户之前输入的所有信息（输入的信息数量不超过 100 个）<br>示例：</p><pre><code>输入： shi yan lou end输出： shi yan lou</code></pre><p>提示：</p><ul><li>使用数组保存元素</li></ul><p><strong>参考答案</strong><br>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Scanner;public class InputTest {public static void main(String[] args) {    String[] data = new String[100];    Scanner in = new Scanner(System.in);    for (int i = 0; i &lt; 100; i++) {        if ((data[i] = in.nextLine()).equals("end")) {            break;        }    }    for (String a : data) {        if (a.equals("end")) {            break;        }        System.out.println(a);    }}}</code></pre><p><strong>练习题：最大最小值</strong></p><p>现给出一串数据（313, 89, 123, 323, 313, 15, 90, 56, 39）求出最大值和最小值并输出。</p><p>在/home/project/目录下新建文件MaxAndMin.java，在其中编写正确的代码。</p><p><strong>参考答案</strong></p><p>注意：请务必先独立思考获得 PASS 之后再查看参考代码，直接拷贝代码收获不大</p><pre><code>import java.util.Arrays;public class MaxAndMin {public static void main(String[] args) {    int[] data = {313, 89, 123, 323, 313, 15, 90, 56, 39};    //    方法1    int max = data[0];    int min = data[0];    for (int i = 0; i &lt; data.length; i++) {        if (data[i] &gt; max) {            max = data[i];        }        if (data[i] &lt; min) {            min = data[i];        }    }    System.out.println(min);    System.out.println(max);    //方法二    //Arrays.sort(data);    //System.out.println(data[0]);    //System.out.println(data[data.length - 1]);    //方法三    //System.out.println(Arrays.stream(data).min().getAsInt());    //System.out.println(Arrays.stream(data).max().getAsInt());}}</code></pre><p><strong>总结</strong></p><ul><li>变量</li><li>常量</li><li>数据类型</li><li>String</li><li>运算符</li><li>关键字和语句</li><li>方法</li><li>流程控制</li><li>数组</li><li>用户输入操作</li></ul><p>到目前为止，已经完成了所有 Java 基础语法的学习，希望大家能够多根据文档中的例子进行练习，理解并掌握各个基础知识。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
